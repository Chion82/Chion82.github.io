<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ChionLab | 一个萌豚开发者的窝 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="ChionLab">
<meta property="og:url" content="https://blog.chionlab.moe/page/2/index.html">
<meta property="og:site_name" content="ChionLab">
<meta property="og:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChionLab">
<meta name="twitter:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="ChionLab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
  
  <link href="/stylesheets/googlefonts.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    .article-duoshuo-link {
      float: right;
      margin-left: 20px;
    }
    .article-duoshuo-link:before {
      content: "\f086";
      font-family: "FontAwesome";
      padding-right: 8px;
    }
    .jc-bs3-container {
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <link href="/stylesheets/jquery-confirm.min.css" rel="stylesheet" type="text/css">
  <script src="/scripts/jquery-2.2.0.min.js"></script>
  <script src="/scripts/jquery-confirm.min.js"></script>
  <!--
  
    <script>
      var yunModuleEnv = true;
    </script>
    <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
  
  -->

  
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script>
    var JS_COOKIES_DOMAIN = '.chionlab.moe';
    var JsCookies = {
      // this gets a cookie and returns the cookies value, if no cookies it returns blank ""
      get: function(c_name) {
        if (document.cookie.length > 0) {
          var c_start = document.cookie.indexOf(c_name + "=");
          if (c_start != -1) {
            c_start = c_start + c_name.length + 1;
            var c_end = document.cookie.indexOf(";", c_start);
            if (c_end == -1) {
              c_end = document.cookie.length;
            }
            return unescape(document.cookie.substring(c_start, c_end));
          }
        }
        return "";
      },

      // this sets a cookie with your given ("cookie name", "cookie value", "good for x days")
      set: function(c_name, value, expiredays) {
        var exdate = new Date();
        if (expiredays)
          exdate.setDate(exdate.getDate() + expiredays);
        document.cookie = c_name + "=" + escape(value) + "; path=/" + "; domain=" + JS_COOKIES_DOMAIN + ((expiredays == undefined) ? "" : "; expires=" + exdate.toUTCString());
      },

      // this checks to see if a cookie exists, then returns true or false
      check: function(c_name) {
        c_name = JsCookies.get(c_name);
        if (c_name != null && c_name != "") {
          return true;
        } else {
          return false;
        }
      }

    };
  </script>

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChionLab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎来到Chion82的未来道具研究所 ( ゜- ゜)つロ 乾杯~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="https://github.com/Chion82">GitHub</a>
        
          <a class="main-nav-link" href="/about.html">About Me</a>
        
        <!-- <a class="main-nav-link nav-link-switch-cdn" href="//cn2.chionlab.moe" data-domain="cn2">CN2加速</a>
        <a class="main-nav-link nav-link-switch-cdn" href="//blog.chionlab.moe" data-domain="blog">CF加速</a> -->

        
          <div style="clear: both;"></div>
          <style>
            .switch-theme-btn {
              opacity: 0.8 !important;
            }

            .switch-theme-btn:hover {
              opacity: 1.0 !important;
            }
          </style>
          <div>
            <!--
              
                <a class="main-nav-link switch-theme-btn"
                  title="uzume" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/css/style.css"
                  data-theme-name="uzume">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_uzume.png" />
                  </div>
                </a>
              
                <a class="main-nav-link switch-theme-btn"
                  title="miria" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/stylesheets/theme_miria.css"
                  data-theme-name="miria">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_miria.png" />
                  </div>
                </a>
              
            -->
          </div>
          <script>
            // (function(){
            //
            //   function switchThemeCSS(themeName, cssUrl) {
            //     document.querySelector('head').querySelectorAll('link[rel=stylesheet]')[1].href = cssUrl;
            //   }
            //
            //   var switchThemeBtns = document.querySelectorAll('.switch-theme-btn');
            //   for (var i=0; i<switchThemeBtns.length; i++) {
            //     var switchThemeBtn = switchThemeBtns[i];
            //     (function(switchThemeBtn) {
            //       switchThemeBtn.addEventListener('click', function(){
            //         switchThemeCSS(switchThemeBtn.dataset.themeName, switchThemeBtn.dataset.cssUrl);
            //         JsCookies.set('theme', switchThemeBtn.dataset.themeName, 30);
            //       });
            //     })(switchThemeBtn);
            //   }
            //
            //   var initTheme = JsCookies.get('theme');
            //   if (initTheme) {
            //     var cssUrl = document.querySelector(".switch-theme-btn[data-theme-name='" + initTheme + "']").dataset.cssUrl;
            //     switchThemeCSS(initTheme, cssUrl);
            //   }
            //
            // })();
          </script>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.chionlab.moe"></form>
      </div>
    </div>
  </div>
  <script>
    // function getGeolocation(geoInfo) {
    //   var rootDomain = 'chionlab.moe';
    //   if (geoInfo.country_code === 'CN') {
    //     if (window.location.hostname === 'cn2' + '.' + rootDomain) {
    //       JsCookies.set('domain', 'cn2', 30);
    //       return;
    //     }
    //     $.confirm({
    //       title: '线路优化建议',
    //       content: '检测到您是境内用户，为了提高您的访问体验，是否切换到CN2线路？',
    //       buttons: {
    //         '好的': function() {
    //           JsCookies.set('domain', 'cn2', 30);
    //           window.location.href = '//' + 'cn2' + '.' + rootDomain + window.location.pathname;
    //         },
    //         '不用了': function() {
    //           JsCookies.set('domain', 'blog', 30);
    //         }
    //       }
    //     })
    //   } else {
    //     JsCookies.set('domain', 'blog', 30);
    //     if ('blog' + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + 'blog' + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    // }
    // (function(){
    //   var rootDomain = 'chionlab.moe';
    //
    //   if (!JsCookies.check('domain')) {
    //     var geoLocationScript = document.createElement('script');
    //     geoLocationScript.setAttribute('src','//freegeoip.net/json/?callback=getGeolocation');
    //     document.head.appendChild(geoLocationScript);
    //   } else {
    //     if (JsCookies.get('domain') + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + JsCookies.get('domain') + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    //
    //   var switchBtns = document.querySelectorAll('.nav-link-switch-cdn');
    //   for (var i=0; i<switchBtns.length; i++) {
    //     (function(switchBtn){
    //       if (switchBtn.dataset.domain === JsCookies.get('domain')) {
    //         switchBtn.style.display = 'none';
    //       }
    //       switchBtn.addEventListener('click', function(ev) {
    //         JsCookies.set('domain', switchBtn.dataset.domain);
    //       });
    //     })(switchBtns[i]);
    //   }
    // })();
  </script>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-WeChatMomentStat-update-log" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/WeChatMomentStat-update-log/" class="article-date">
  <time datetime="2016-03-31T02:32:52.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/安卓/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/WeChatMomentStat-update-log/">WeChatMomentStat：微信朋友圈导出工具开发记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GitHub-repo"><a href="#GitHub-repo" class="headerlink" title="GitHub repo"></a>GitHub repo</h2><p><a href="https://github.com/Chion82/WeChatMomentStat-Android" target="_blank" rel="noopener">https://github.com/Chion82/WeChatMomentStat-Android</a></p>
<h2 id="关于WeChatMomentStat-Android"><a href="#关于WeChatMomentStat-Android" class="headerlink" title="关于WeChatMomentStat-Android"></a>关于WeChatMomentStat-Android</h2><p>博主之前开发过<a href="https://github.com/Chion82/WeChatMomentExport" target="_blank" rel="noopener">WeChatMomentExport</a>，借助Xposed实现了导出微信朋友圈数据。该项目在GitHub上获得了不少Star，被应用平台收录之后也有几千的下载量，可见这个需求是存在的。但是，对于WeChatMomentExport，还存在以下问题：  </p>
<ul>
<li>作为Xposed模块，必需依赖Xposed才能运行  </li>
<li>因为数据抓取方式为hook，故用户需要在微信朋友圈页面手动下滑加载</li>
<li>微信版本每更新一次会导致源码被重新混淆，相应的本项目也需要更新钩子逻辑</li>
<li>项目的定位是将导出数据作为开发者二次开发所需的数据源，但从酷安网的用户评论看，普通用户不能理解需求</li>
</ul>
<p>对于上述问题，博主考虑了以下相应对策：</p>
<ul>
<li>从<a href="https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/">上次的逆向分析结果</a>看，只要想办法调用到这几个类（以下称为parser），就可以解析微信SQLite缓存中的blob数据，这样就不需要借助Xposed的hook了，也能实现一键导出</li>
<li>考虑到blob格式不会经常变更，因此可在项目中整合parser，这样本项目就无需经常更新</li>
<li>博主在开发WeChatMomentExport之后随手写的<a href="https://github.com/Chion82/WeChatMomentStat" target="_blank" rel="noopener">朋友圈数据统计脚本</a>也获得了少量star，因此认为，对于普通用户，生成这样的简易统计数据更有吸引性</li>
</ul>
<p>于是，决定整合WeChatMomentExport和统计脚本，做一个功能稍完善的工具。</p>
<h2 id="几个技术难点"><a href="#几个技术难点" class="headerlink" title="几个技术难点"></a>几个技术难点</h2><p>要做这样的一个独立的APP，而不是一个Xposed模块，需要解决以下问题：</p>
<ol>
<li>如何在APP中整合parser？parser的逻辑代码被混淆在微信的dex中，直接分析其算法难度太大。</li>
<li>如何越权获得微信的SQLite缓存数据？</li>
<li>如何确保从SQLite缓存中取得的朋友圈数据足够齐全？</li>
</ol>
<p>经过查阅各种文档和亲自实验，还是找到了解决方案。</p>
<h2 id="使用DexClassLoader直接加载微信apk中的parser"><a href="#使用DexClassLoader直接加载微信apk中的parser" class="headerlink" title="使用DexClassLoader直接加载微信apk中的parser"></a>使用DexClassLoader直接加载微信apk中的parser</h2><p>DexClassLoader可直接解析apk中的classes.dex，并从中取得所需类，通过java反射，可以获得所需的parser方法。因此，无需再分析parser算法，而是直接调用就可以了。<br>通过DexClassLoader取得parser方法的关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader cl = <span class="keyword">new</span> DexClassLoader(</span><br><span class="line">                    apkFile.getAbsolutePath(),  <span class="comment">//apkFile为微信apk文件</span></span><br><span class="line">                    context.getDir(<span class="string">"outdex"</span>, <span class="number">0</span>).getAbsolutePath(),</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">Class SnsDetailParser = cl.loadClass(<span class="string">"com.tencent.mm.plugin.sns.f.i"</span>);</span><br><span class="line">Class SnsDetail = cl.loadClass(<span class="string">"com.tencent.mm.protocal.b.atp"</span>);</span><br><span class="line">Class SnsObject = cl.loadClass(<span class="string">"com.tencent.mm.protocal.b.aqi"</span>);</span><br><span class="line"><span class="comment">//之后只需使用java反射即可取得所需方法</span></span><br></pre></td></tr></table></figure></p>
<p>还需要提供一个微信的apk文件。因此将微信apk放在assets中，首次运行本工具的时候释放到外部存储中。</p>
<h2 id="通过su调用，拷贝微信的SQLite数据库文件"><a href="#通过su调用，拷贝微信的SQLite数据库文件" class="headerlink" title="通过su调用，拷贝微信的SQLite数据库文件"></a>通过su调用，拷贝微信的SQLite数据库文件</h2><p>需要越权操作的话，获取root权限是很难避免的。通过调用su，可以复制出微信的SQLite数据库文件到本工具可读写的目录下。<br>微信朋友圈的SQLite文件在<code>/data/data/com.tencent.mm/MicroMsg/XXXXXXXXXXXXX/SnsMicroMsg.db</code>。其中，<code>XXXXXXXXXXXXX</code>是微信生成的hash值，每台设备上都可能不一样。由于在Android的shell中没有<code>find</code>或类似的命令，需要复制出这个<code>SnsMicroMsg.db</code>还得费一点功夫。最终，博主采用<code>ls</code>列目录并循环尝试<code>cp</code>的方法强行取得<code>SnsMicroMsg.db</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copySnsDB</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String dataDir = Environment.getDataDirectory().getAbsolutePath();</span><br><span class="line">    String destDir = Config.EXT_DIR;</span><br><span class="line">    Process su = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">    DataOutputStream outputStream = <span class="keyword">new</span> DataOutputStream(su.getOutputStream());</span><br><span class="line">    outputStream.writeBytes(<span class="string">"mount -o remount,rw "</span> + dataDir + <span class="string">"\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"cd "</span> + dataDir + <span class="string">"/data/"</span> + Config.WECHAT_PACKAGE + <span class="string">"/MicroMsg\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"ls | while read line; do cp $&#123;line&#125;/SnsMicroMsg.db "</span> + destDir + <span class="string">"/ ; done \n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"sleep 1\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"chmod 777 "</span> + destDir + <span class="string">"/SnsMicroMsg.db\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"exit\n"</span>);</span><br><span class="line">    outputStream.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，还需要修改db文件的权限为<code>777</code>，否则工具无权读取数据库。另外，<code>sleep</code>是为了避免稍后偶然性出现的读取数据库失败的情况（可能文件复制不完整或未被去锁？）。</p>
<h2 id="关于SQLite中数据完整性的问题"><a href="#关于SQLite中数据完整性的问题" class="headerlink" title="关于SQLite中数据完整性的问题"></a>关于SQLite中数据完整性的问题</h2><p>经过测试，微信的SQLite数据库中缓存了几乎所有加载过的朋友圈，理论上应当不会漏数据。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>本来这个app计划于2月中旬就写出来的，由于博主不是安卓开发者，没有系统地学过安卓开发，当时还不知道有<code>DexClassLoader</code>，写的第一个demo用的依然是Xposed，但是不同于WeChatMomentExport，这里用Xposed仅仅是为了取得那几个parser的类而已。2月底开学后，通过各种渠道了解到了<code>DexClassLoader</code>，才有现在的这个思路。<br>博主现在读大二，这学期开学后课程比较紧张，再者在工作室外包项目的压力下（团队管理问题，还有涉及的利益问题出现冲突的时候，处理起来非常棘手），一时失去了搞开源轮子的动力，甚至连续一个月都没有更新博客，于是才导致了这个项目拖到现在才基本完成。<br>看到了GitHub上的项目star和follower每隔几天就多一个，本站也陆续有网友来评论，每日UV也保持在100以上，就重拾了动力去继续折腾。<br>非常感谢前来光临本站和GitHub profile的各位！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/03/31/WeChatMomentStat-update-log/" data-id="cjf4w2oad00036t2hhnqv1qeo" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/03/31/WeChatMomentStat-update-log/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hack/">hack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat/">wechat</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-react-server-side-rendering" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/03/react-server-side-rendering/" class="article-date">
  <time datetime="2016-03-03T12:11:17.000Z" itemprop="datePublished">2016-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/03/react-server-side-rendering/">自译：如何使用服务端渲染加速React APP首屏加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文：<a href="https://www.terlici.com/2015/03/18/fast-react-loading-server-rendering.html" target="_blank" rel="noopener">How to build React apps that load quickly using server side rendering (by Stefan Fidanov)</a></p>
<p>使用客户端框架（译者注：此处指大多数在浏览器端运行的前端MV*框架）可快速开发用户交互丰富、性能高效的web app，前端开发者都非常喜欢使用该类框架。<br>不幸的是，客户端框架也有缺点，其中最主要的问题是首屏加载速度。<br>客户端首先从服务器接收少量的HTML代码，但是之后却需要接收大量的JavaScript代码。<br>然后，它们（指前端框架）需要向服务器请求数据，等待收到数据，进行必要的数据处理，并最终渲染到用户的浏览器上。<br>相比之下，传统的web做法是，全部数据由服务端进行渲染，当服务端向用户首次递交HTML时，用户端浏览器就收到了渲染完成的页面了。<br>再者，大多数情况下，web服务器的渲染速度要快于客户端的渲染。所以，（传统web）的首屏渲染是非常快速的。</p>
<h2 id="React的解决方案"><a href="#React的解决方案" class="headerlink" title="React的解决方案"></a>React的解决方案</h2><p>很自然的，你会想同时拥有上述两者（分别指：使用了MV*框架的web app、传统的web站点）的全部优点。快速的首屏加载、高度的交互性和快速的响应。React可以帮助你同时做到这几点。<br>React是这样做到的：首先，它可以在服务端渲染任意的组件（Component），包括这些组件的数据，这样渲染得到的结果是一些HTML代码，这些HTML代码在这之后可以直接发送到浏览器。<br>当这些HTML在用户浏览器上被显示出来时，React会在本地（这里的本地指用户浏览器）进行计算。它的智能算法将进行判断并得出：React即将要在浏览器端动态渲染出来的结果，跟当前已经被显示出来的页面一样。<br>在这之后，除了添加必要的事件处理，React不会对页面做任何的修改。<br>那么为什么这样会更快呢？我们不是在做几乎跟客户端一样的事情吗？<br>是的。但仅仅是“几乎”而已。<br>首先，当服务器响应浏览器请求时，用户马上就能看到整个页面了。所以页面响应速度更快了。<br>其次，因为React能够判断出无需再对DOM做修改，它就不会再去碰DOM。修改DOM是前端渲染中最慢的部分。<br>再者，这样可以节省请求次数。因为所有数据已经被渲染所以React不需要再向服务器请求。</p>
<p><strong>那么有没有可能：当页面加载时，页面已经显示出来但是用户不能对其进行交互，因为这时事件处理尚未被添加？</strong><br>理论上这种情况是有可能发生的。但是因为用了服务端渲染，我们就避免了所有的高开销操作，而且这样不但加速了页面响应速度，添加事件处理的速度也会变得很快。<br>所以，你的应用将总是可交互的，并且用户不会察觉到有什么问题。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>光说无用，我们来看看如何在代码中实现。我们的第一个示例是非常简单的。我们要显示一个”hello”消息，并且点击后会有提示。<br>我们的示例将使用NodeJS作为服务端部分，不过这里的一切都可以应用在其他平台，比如PHP, Ruby, Python, Java或者.NET。</p>
<p>我们需要以下Node模块：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel react react-dom express jade</span></span><br></pre></td></tr></table></figure></p>
<p>我们将使用<code>express</code>和<code>jade</code>来做一个示例服务器。<br><code>react</code>和<code>react-dom</code>包可提供React组件的服务端渲染。<br><code>babel</code>包允许我们通过node直接加载JSX模块，比如<code>require(&#39;some-component.jsx&#39;)</code>或者<code>require(&#39;some-component.js&#39;)</code>。<br><code>babel</code>实际上更加强大。现在你可以用ES6支持。<br>我们的应用只有3个文件，文件结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public/components.js</span><br><span class="line">views/index.jade</span><br><span class="line">app.js</span><br></pre></td></tr></table></figure></p>
<p><code>components.js</code>包含了我们的React组件；<code>index.jade</code>是网站的基本模板文件，将会加载全部JavaScript；<code>app.js</code>是node服务器。<br>让我们来看看<code>index.jade</code>里面有什么内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">doctype</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    title React Server Side Rendering Example</span><br><span class="line">  body</span><br><span class="line">    div(id='react-root')!= react</span><br><span class="line"></span><br><span class="line">    script(src='https://fb.me/react-0.14.0.js')</span><br><span class="line">    script(src='https://fb.me/react-dom-0.14.0.js')</span><br><span class="line">    script(src='https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js')</span><br><span class="line"></span><br><span class="line">    script(src='/components.js', type='text/babel')</span><br></pre></td></tr></table></figure></p>
<p><code>div(id=&#39;react-root&#39;)!= react</code>是最关键的部分。它的作用是作为React根组件的容器。另外，<code>react</code>变量的值是服务端渲染React组件后得到的HTML。<br>前两个引用进来的JavaScript文件是React本身，如果你想要在组件里面使用JSX，还需要引用一个Babel。<br>最后一个引用的文件是具体的组件。我们要把type设成<code>text/babel</code>好让Babel来处理这个文件。<br>这将提供一个基本的HTML结构，并加载全部的JavaScript和你需要的React组件。<br>来看看这个简单的服务器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">  , app = express()</span><br><span class="line">  , React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line">  , ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>)</span><br><span class="line">  , components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'jade'</span>, <span class="built_in">require</span>(<span class="string">'jade'</span>).__express)</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>)</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: ReactDOM.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening on port 3000...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这部分代码中，大部分和一个普通的express应用程序没有多大区别。但是其中有些行需要注意。<br>第一行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br></pre></td></tr></table></figure></p>
<p>加载Babel到你的依赖。这么做，你可以直接导入(<code>require()</code>)由JSX组成的React组件，它们会被自动翻译为JavaScript，就像后面的两行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，第一行导入JSX编写的React组件。然后，由<code>React.createFactory</code>生成一个函数，该函数可以创建<code>HelloMessage</code>的组件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: ReactDOM.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面这里就是渲染React组件的代码，并且渲染包含该组件的页面然后发送至浏览器。<br>首先，使用值为<code>John</code>的<code>name</code>属性创建一个新的<code>HelloMessage</code>组件，然后使用<code>React.renderToString</code>将这个组件渲染为HTML。<br>这里需要注意的是，组件仅仅被渲染(rendered)，而没有被挂载(mounted)，所以 <strong>所有关于挂载的方法都不会被调用</strong> 。<br>在创建组件之后，将组件的HTML传递到index模版。<br>我们的组件看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNode = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports</span><br><span class="line">  , React = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.React</span><br><span class="line">  , ReactDOM = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.ReactDOM</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'You clicked!'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNode) &#123;</span><br><span class="line">  exports.HelloMessage = HelloMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, document.getElementById('react-root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>你可以看见，这跟一般的由JSX编写的React组件没有什么不同，除了开头和结尾。这里就是你要让组件能同时在浏览器和Node端运行所需要注意的地方。</p>
<h2 id="高级示例：加载服务端数据"><a href="#高级示例：加载服务端数据" class="headerlink" title="高级示例：加载服务端数据"></a>高级示例：加载服务端数据</h2><p>真正的Web app做的事情通常远不止你看见的这些。它们经常需要跟服务器交互并从服务器加载数据。<br>但是，我们不希望这在服务端渲染时发生。<br>我们来对这个示例程序做一些小修改。首先，模版文件需要引用jQuery，在这里它的唯一作用是从服务端请求数据。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doctype</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    title React Server Side Rendering Example</span><br><span class="line">  body</span><br><span class="line">    div(id='react-root')!= react</span><br><span class="line"></span><br><span class="line">    script(src='https://fb.me/react-0.14.0.js')</span><br><span class="line">    script(src='https://fb.me/react-dom-0.14.0.js')</span><br><span class="line">    script(src='https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js')</span><br><span class="line">    script(src='http://code.jquery.com/jquery-2.1.3.js')</span><br><span class="line"></span><br><span class="line">    script(src='/components.js', type='text/babel')</span><br></pre></td></tr></table></figure></p>
<p>我们的服务器现在需要增加一个请求路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">  , app = express()</span><br><span class="line">  , React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line">  , ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>)</span><br><span class="line">  , components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'jade'</span>, <span class="built_in">require</span>(<span class="string">'jade'</span>).__express)</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>)</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: React.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"Paul, "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening on port 3000...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里跟之前的例子唯一的不同之处在于这三行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"Paul, "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这三行代码的作用是，当<code>/name</code>被请求时，返回名字<code>Paul</code>和当前时间。<br>来看看这整个应用最有趣和最重要的部分，即React组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNode = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports</span><br><span class="line">  , React = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.React</span><br><span class="line">  , ReactDOM = isNode ? <span class="built_in">require</span>(<span class="string">'react-dom'</span>) : <span class="built_in">window</span>.ReactDOM</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  loadServerData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: result&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervalID = setInterval(<span class="keyword">this</span>.loadServerData, <span class="number">3000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.intervalID)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'You clicked!'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="keyword">this</span>.state.name ? <span class="keyword">this</span>.state.name : <span class="keyword">this</span>.props.name</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNode) &#123;</span><br><span class="line">  exports.HelloMessage = HelloMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, document.getElementById('react-root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们只添加了这4个方法，其他和之前的例子相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">loadServerData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: result&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.intervalID = setInterval(<span class="keyword">this</span>.loadServerData, <span class="number">3000</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.intervalID)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>当组件被挂载后，每隔3秒它会向服务器请求数据<code>/name</code>并且显示出来。<br><code>componentDidMount</code>和<code>componentWillUnmount</code>在组件被渲染时是不会被调用的，它们只有在组件被挂载时才会被调用。<br>所以这两个方法在服务端渲染时不会被调用，<code>loadServerData</code>方法也不会被调用。<br>这三个方法只有当组件被挂载时才会被执行，而这只会发生在浏览器端。<br>由此可见，想要从整体中分离出只在浏览器运行的那部分，并且保持代码的复用是很简单的。</p>
<h2 id="在这之后？"><a href="#在这之后？" class="headerlink" title="在这之后？"></a>在这之后？</h2><p>你已经学会了如何借助服务端渲染创建一个能被快速加载的React应用程序。但是，我的这个示例只是针对NodeJS服务器。<br>如果你在使用其他技术（比如PHP, .NET, Ruby, Python或者Java），你一样可以利用React服务端渲染的优点，这将会是你下一步要研究的方向。<br>另外，我直接在浏览器端使用了JSX，这将多亏于Babel，但是这也会降低性能。在生产环境中，在将JSX提供给浏览器之前先将之转换为JavaScript会更快。<br>我相信你一定可以找到你最喜欢的开发语言和Web框架下的类似解决方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/03/03/react-server-side-rendering/" data-id="cjf4w2obx00196t2hrj862oje" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/03/03/react-server-side-rendering/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-hello-old-driver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/hello-old-driver/" class="article-date">
  <time datetime="2016-02-28T05:14:53.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/hello-old-driver/">你好，老司机：种子爬虫企划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在老司机的安利之下，学会了从<a href="http://www.hacg.li" target="_blank" rel="noopener">琉璃神社</a>找各种神奇的资源。于是萌生了造这个轮子的欲望。国内这种福利站不知还能维持多久，所以将资源大量扒下来存档是有点卵用的。</p>
<h2 id="GitHub-repo"><a href="#GitHub-repo" class="headerlink" title="GitHub repo"></a>GitHub repo</h2><p><a href="https://github.com/Chion82/hello-old-driver" target="_blank" rel="noopener">https://github.com/Chion82/hello-old-driver</a></p>
<h2 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h2><p>为了兼容多个站点，我的爬虫脚本并没有针对某个特定的网站进行抓取逻辑定制，而是采取递归遍历网站全部页面+正则匹配磁力链hash的方式抓取整站的磁力链资源。磁力链的hash协议大多数时候是BTIH，hash值为40位的hex字符串，匹配的正则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^0-9a-fA-F]([0-9a-fA-F]&#123;40&#125;)[^0-9a-fA-F]</span><br></pre></td></tr></table></figure></p>
<p>注意，为了保证hash串长度为40字节，在其前后应加上非hex的匹配，即<code>[^0-9a-fA-F]</code>。</p>
<p>这样将可能导致一个问题，网站页面源码中可能还存在磁力链以外的SHA-1值，比如琉璃神社在每条用户评论后在一个标签属性内有40字节长的一段hash值，目前的解决方法是忽略HTML标签<code>&lt;&gt;</code>内的属性内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ignore_html_label): <span class="comment">#为了增强扩展性，这类fix逻辑应该可控</span></span><br><span class="line">		result_text = re.sub(<span class="string">r'&lt;.*?&gt;'</span>, <span class="string">''</span>, result_text)</span><br></pre></td></tr></table></figure></p>
<p>每个磁力链资源应当要有对应的标题以方便查找，这里以网页的标题作为资源标题，匹配正则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;(.+?)&lt;/title&gt;</span><br></pre></td></tr></table></figure></p>
<p>经测试发现，每轮抓取结束后，抓取到的资源数量可能不一样，可能的原因是网站方对访问频次做了限制或者是本地网络质量问题，就算通过连接失败重试、服务器返回5XX后重试等方法也不能解决。于是决定：每次抓取不覆盖上次抓取的结果，而是保留上次的结果，并新增本次抓取到的、上次结果中没有的新磁力链资源。</p>
<p>其他的一些必需属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookie = <span class="string">''</span> <span class="comment">#每次请求需要带上的Cookie。由于琉璃神社目前不需要登录，暂为空串</span></span><br><span class="line">max_depth = <span class="number">40</span> <span class="comment">#递归最大深度，即从一个网页查找全部链接并依次往下递归访问，最大的深度为40</span></span><br><span class="line">viewed_urls = [] <span class="comment">#访问过的URL，避免重复访问</span></span><br><span class="line">found_magnets = [] <span class="comment">#查找出来的磁力链资源，避免重复抓取</span></span><br><span class="line">ignore_url_param = <span class="keyword">True</span> <span class="comment">#是否忽略URL中的参数，比如"index.html?xxx=11"将被替换为"index.html"</span></span><br><span class="line">ignore_html_label = <span class="keyword">True</span> <span class="comment">#是否忽略HTML标签内属性</span></span><br></pre></td></tr></table></figure></p>
<p>需要定时执行抓取脚本以保证与原网站同步。写了一个shell脚本，<code>sync.sh</code>，作用如下：</p>
<ul>
<li>测试目标网站是否可访问</li>
<li>复制上次的抓取结果<code>magnet_output</code>和<code>resource_list.json</code>到<code>archives</code>目录下存档，以当前时间重命名</li>
<li>复制上次的抓取日志<code>lastsync.log</code>和<code>lasterror.log</code>到<code>log</code>目录下存档，以当前时间重命名</li>
<li>运行Python抓取脚本，这将覆盖项目根目录下的上述抓取结果文件和抓取日志文件</li>
<li>将本次的抓取结果梗概（是否成功、新增几条记录以及一些简单统计数据）添加到<code>README.md</code>中</li>
<li>推送到GitHub</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/02/28/hello-old-driver/" data-id="cjf4w2ob9000l6t2h2v00i8pe" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/02/28/hello-old-driver/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/crawler/">crawler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-wechat-sns-reflect-classes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/20/wechat-sns-reflect-classes/" class="article-date">
  <time datetime="2016-02-19T16:16:42.000Z" itemprop="datePublished">2016-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/逆向/">逆向</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/20/wechat-sns-reflect-classes/">逆向纪录：微信朋友圈相关的几个类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本纪录针对微信安卓端版本<code>6.3.13</code>。本文纪录逆向微信过程中找到的几个朋友圈内容相关的数据结构类。</p>
<ol>
<li><p>朋友圈详细内容<br>类名: <code>com.tencent.mm.protocal.b.atp</code><br>[方法]添加属性（可作为hook的方法）: <code>protected final int a(int paramInt, object... objectArray)</code><br>[方法]从BLOB数据导入：<code>public a am(byte[])</code></p>
</li>
<li><p>可将<code>com.tencent.mm.protocal.b.atp</code>实例格式化为XML的类<br>类名: <code>com.tencent.mm.plugin.sns.f.i</code><br>[方法]输出朋友圈内容XML: <code>static public String a(com.tencent.mm.protocal.b.atp atpObject)</code></p>
</li>
<li><p>朋友圈评论和点赞数据<br>类名: <code>com.tencent.mm.protocal.b.aqi</code><br>[方法]添加属性（可作为hook的方法）: <code>protected final int a(int paramInt, object... objectArray)</code><br>[方法]从BLOB数据导入：<code>public a am(byte[])</code><br>[属性]用户ID：<code>String iYA</code><br>[属性]用户昵称：<code>String jyd</code><br>[属性]时间戳：<code>long fpL</code><br>[属性]评论列表：<code>LinkedList&lt;com.tencent.mm.protocal.b.apz&gt; jJX</code><br>[属性]点赞列表：<code>LinkedList&lt;com.tencent.mm.protocal.b.apz&gt; jJU</code></p>
</li>
<li><p>评论或点赞数据详情<br>类名: <code>com.tencent.mm.protocal.b.apz</code><br>[属性]用户ID： <code>String iYA</code><br>[属性]用户昵称：<code>String jyd</code><br>[属性]评论回复给谁(对方用户ID)：<code>String jJM</code><br>[属性]评论内容：<code>String fsI</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/" data-id="cjf4w2oc7001l6t2hugvhjrhg" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hack/">hack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat/">wechat</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-generate-thumbnails-with-nginx-image-filter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/02/generate-thumbnails-with-nginx-image-filter/" class="article-date">
  <time datetime="2016-02-01T17:05:24.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/后端/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/generate-thumbnails-with-nginx-image-filter/">使用nginx image filter动态生成缩略图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx提供<code>ngx_http_image_filter_module</code>模块，可用来动态生成图片的缩略图。当然，最好的办法是在后端进行图片压缩。但是当不方便修改后端代码时，在牺牲些许性能的代价下，使用image filter生成缩略图还是很方便的。</p>
<h2 id="编译安装nginx"><a href="#编译安装nginx" class="headerlink" title="编译安装nginx"></a>编译安装nginx</h2><p>大部分预编译的nginx默认不带<code>ngx_http_image_filter_module</code>模块，这时需要手动编译nginx。<br>在执行<code>configure</code>时带上参数<code>--with-http_image_filter_module</code>。<br>在水果上编译可参考<a href="/2016/02/02/compile-nginx-on-osx/">OSX上编译安装nginx</a></p>
<h2 id="在配置文件中使用image-filter生成缩略图"><a href="#在配置文件中使用image-filter生成缩略图" class="headerlink" title="在配置文件中使用image_filter生成缩略图"></a>在配置文件中使用image_filter生成缩略图</h2><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">    image_filter resize 200 200;</span><br><span class="line">    image_filter_buffer 10M;</span><br><span class="line">    image_filter_jpeg_quality 90;</span><br><span class="line">    root /path/to/website;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>image_filter resize 200 200</code>表示按比例缩放图片，长和宽中较大者为200。比如，原图大小为1000x500，处理后为200x100。</li>
<li><code>image_filter_buffer 10M</code>表示处理图片的缓冲区最大为10M。</li>
<li><code>image_filter_jpeg_quality 90</code>设置jpeg压缩质量为90%。</li>
</ul>
<p>经过这样的配置后，访问<code>HOSTNAME/images/XXX.jpg|png|gif</code>即可得到经过压缩的缩略图。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/02/02/generate-thumbnails-with-nginx-image-filter/" data-id="cjf4w2oay000e6t2hdjostpkc" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/02/02/generate-thumbnails-with-nginx-image-filter/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/backend/">backend</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-compile-nginx-on-osx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/02/compile-nginx-on-osx/" class="article-date">
  <time datetime="2016-02-01T16:31:21.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OSX/">OSX</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/compile-nginx-on-osx/">在OSX上编译安装nginx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在OSX上，一般情况下，使用<code>brew</code>安装nginx，再链接一个plist到<code>/Library/LaunchDaemons</code>即可。但是有时候brew中的nginx缺少某些模块，比如上文提到的<code>ngx_http_image_filter_module</code>，这时就需要重新编译nginx。<br>更正：homebrew中提供<code>nginx-full</code>包，包含了常用的绝大多数模块。当然如果需要添加第三方模块还是需要手动编译。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install pcre</span><br><span class="line">$ brew install gd #image filter依赖gd</span><br><span class="line">$ brew link --force openssl #避免编译openssl时报错</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>下面的示例中，添加以下几个模块：</p>
<ul>
<li>http_image_filter_module</li>
<li>http_ssl_module</li>
<li>http_gzip_static_module</li>
<li>http_sub_module<br>并且其他配置和homebrew的nginx大致相同（带版本号的路径除外）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#cd到nginx源码目录</span><br><span class="line">$ ./configure --with-http_image_filter_module --with-http_ssl_module --with-http_gzip_static_module --with-http_sub_module \</span><br><span class="line">--prefix=/usr/local/Cellar/nginx/1.9.10 \</span><br><span class="line">--with-cc-opt=&quot;-I /usr/local/include&quot; --with-ld-opt=&quot;-L /usr/local/lib&quot; \</span><br><span class="line">--sbin-path=/usr/local/Cellar/nginx/1.9.10/bin/nginx \</span><br><span class="line">--conf-path=/usr/local/etc/nginx/nginx.conf \</span><br><span class="line">--pid-path=/usr/local/var/run/nginx.pid \</span><br><span class="line">--http-log-path=/usr/local/var/log/nginx/access.log \</span><br><span class="line">--error-log-path=/usr/local/var/log/nginx/error.log --with-pcre --with-ipv6 \</span><br><span class="line">--lock-path=/usr/local/var/run/nginx.lock \</span><br><span class="line">--http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp \</span><br><span class="line">--http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp \</span><br><span class="line">--http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp \</span><br><span class="line">--http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp \</span><br><span class="line">--http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中，<code>--with-cc-opt=&quot;-I /usr/local/include&quot; --with-ld-opt=&quot;-L /usr/local/lib&quot;</code>可避免报<code>Undefined symbols for architecture x86_64</code>错误。<code>/usr/local/Cellar/nginx/1.9.10</code>这里的<code>1.9.10</code>替换为将要编译的nginx版本号。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果之前未安装过nginx，运行这条命令来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make install</span><br></pre></td></tr></table></figure></p>
<p>如果已使用brew安装nginx，可以通过替换文件的方式换成刚才编译的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#备份原来的binary</span><br><span class="line">$ cp /usr/local/opt/nginx/bin/nginx /usr/local/opt/nginx/bin/nginx.bak</span><br><span class="line">#先cd到nginx源码目录</span><br><span class="line">$ sudo cp objs/nginx /usr/local/opt/nginx/bin/nginx</span><br><span class="line">$ rm /usr/local/bin/nginx</span><br><span class="line">$ ln -s /usr/local/opt/nginx/bin/nginx /usr/local/bin/nginx</span><br></pre></td></tr></table></figure></p>
<p>现在，可以查看nginx版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -V</span><br></pre></td></tr></table></figure></p>
<p>强迫症患者可以像我这样在<code>Cellar</code>中建立一个新的版本目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r /usr/local/Cellar/nginx/1.8.0 /usr/local/Cellar/nginx/1.9.10</span><br><span class="line">#恢复1.8.0中的binary</span><br><span class="line">$ rm /usr/local/Cellar/nginx/1.8.0/bin/nginx</span><br><span class="line">$ mv /usr/local/Cellar/nginx/1.8.0/bin/nginx.bak /usr/local/Cellar/nginx/1.8.0/bin/nginx</span><br><span class="line">#更新/usr/local/opt/nginx</span><br><span class="line">$ rm /usr/local/opt/nginx</span><br><span class="line">$ ln -s /usr/local/Cellar/nginx/1.9.10 /usr/local/opt/nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="将nginx加入LaunchDaemons"><a href="#将nginx加入LaunchDaemons" class="headerlink" title="将nginx加入LaunchDaemons"></a>将nginx加入LaunchDaemons</h2><p>编辑<code>/Library/LaunchDaemons/homebrew.mxcl.nginx.plist</code>内容如下：（brew的nginx自带的版本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;homebrew.mxcl.nginx&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">    &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class="line">    &lt;false/&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;/usr/local/opt/nginx/bin/nginx&lt;/string&gt;</span><br><span class="line">        &lt;string&gt;-g&lt;/string&gt;</span><br><span class="line">        &lt;string&gt;daemon off;&lt;/string&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">    &lt;key&gt;WorkingDirectory&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/usr/local&lt;/string&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ launchctl load -F /Library/LaunchDaemons/homebrew.mxcl.nginx.plist</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/02/02/compile-nginx-on-osx/" data-id="cjf4w2oas00086t2hruzpvotm" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/02/02/compile-nginx-on-osx/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSX/">OSX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/backend/">backend</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-use-pf-on-osx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/01/use-pf-on-osx/" class="article-date">
  <time datetime="2016-01-31T17:16:55.000Z" itemprop="datePublished">2016-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OSX/">OSX</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/01/use-pf-on-osx/">OSX上pf的简单配置笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>水果的OSX上没有iptables，在10.10以后以pf取代ipfw。相比于iptables，pf一般使用配置文件保存防火墙规则，语法规范上更严谨，但是配置也更复杂、规则冗长。本文记录pf的简单配置方法。</p>
<p><code>cat /etc/pf.conf</code>，可看到以下已有内容：（忽略注释部分）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br></pre></td></tr></table></figure></p>
<p><code>anchor</code>可理解为一组规则的集合。默认情况下，这里的几行anchor都是苹果留的place holder，实际上没有active的规则。<br><code>/etc/pf.conf</code>在以后的OSX更新中可能会被覆盖，最好可以另外建立一个自定义的<code>pf.conf</code>。<br>配置文件必须按照<code>Macros</code>, <code>Tables</code>, <code>Options</code>, <code>Traffic Normalization</code>, <code>Queueing</code>, <code>Translation</code>, <code>Packet Filtering</code>的顺序。<br>更详细的说明参考<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/pf.conf.5.html" target="_blank" rel="noopener">pf.conf man page</a></p>
<ol>
<li><p>添加一个<code>anchor</code>。修改<code>/etc/pf.conf</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;custom&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;custom&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;custom&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br><span class="line">load anchor &quot;custom&quot; from &quot;/etc/pf.anchors/custom&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立<code>anchor</code>规则文件<code>/etc/pf.anchors/custom</code>，内容为具体规则。<br>常用的规则：</p>
<ul>
<li><p>屏蔽IP入站TCP连接并记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block in log proto tcp from 192.168.1.136 to any</span><br></pre></td></tr></table></figure>
</li>
<li><p>转发入站TCP连接到另一本地端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdr inet proto tcp from any to any port 8081 -&gt; 127.0.0.1 port 80</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>经测试，rdr无法转发到另一台外部主机上（man page的示例，只可以转发到internal network），内核开启<code>net.inet.ip.forwarding=1</code>也无效。如需转发到另一个外网IP，需要配合<a href="http://mitmproxy.org/doc/transparent/osx.html" target="_blank" rel="noopener">mitmproxy的透明代理</a></p>
<ul>
<li>NAT，路由vlan12接口上(192.168.168.0/24)的出口包，经由非vlan12的接口转换到外部地址(204.92.77.111)，并允许vlan12之间的互相访问:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nat on ! vlan12 from 192.168.168.0/24 to any -&gt; 204.92.77.111</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使配置文件生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfctl -evf /etc/pf.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/02/01/use-pf-on-osx/" data-id="cjf4w2oca001n6t2hk692udaq" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/02/01/use-pf-on-osx/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OSX/">OSX</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-github-pages-with-https" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/28/github-pages-with-https/" class="article-date">
  <time datetime="2016-01-27T16:49:18.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/运维/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/github-pages-with-https/">在GitHub Pages上使用CloudFlare https CDN</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本站就是使用<a href="https://hexo.io" target="_blank" rel="noopener">hexo</a>搭建的静态Web站点，托管在<a href="https://github.com/Chion82/Chion82.github.io" target="_blank" rel="noopener">GitHub repo</a>，并使用GitHub Pages。<br>另外，阿里云最近也提供https的CDN服务，更适合用在国内链路质量要求高的站点。</p>
<h2 id="GitHub-Pages应用自定义域名"><a href="#GitHub-Pages应用自定义域名" class="headerlink" title="GitHub Pages应用自定义域名"></a>GitHub Pages应用自定义域名</h2><p>默认情况下，访问GitHub Pages页面的域名为<code>username.github.io</code>，如果需要使用自己的域名（以下简称“你的域名”），可<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">参考官方的帮助文档</a>，其实非常简单：</p>
<ol>
<li>在repo根目录下创建<code>CNAME</code>文件，内容为你的域名。<a href="https://github.com/Chion82/Chion82.github.io/blob/master/CNAME" target="_blank" rel="noopener">本站的CNAME文件</a></li>
<li>在你的域名管理中心，添加一条<code>CNAME</code>记录，指向<code>username.github.io</code>。（将username替换为你的GitHub用户名）</li>
</ol>
<p>现在，访问<code>http://你的域名</code> ，已经可以访问到站点首页了。而如果访问<code>http://username.github.io</code> （即原来的地址），将被302跳转到<code>http://你的域名</code>。</p>
<h2 id="https的问题"><a href="#https的问题" class="headerlink" title="https的问题"></a>https的问题</h2><p>尝试直接访问<code>https://你的域名</code>，浏览器会报SSL_DOMAIN_NOT_MATCHED警告。因为GitHub Pages默认提供的SSL证书的根域名是<code>github.io</code>，和你的域名不相同。<br>而且，GitHub Pages不支持上传SSL证书。</p>
<h2 id="使用CloudFlare"><a href="#使用CloudFlare" class="headerlink" title="使用CloudFlare"></a>使用CloudFlare</h2><p><a href="https://www.cloudflare.com" target="_blank" rel="noopener">CloudFlare</a>（以下简称CF）是一家CDN提供商，它的free plan里面就提供https服务（免费计划不能上传SSL）。现在可以通过CF实现：从用户到CDN服务器的连接为https，而CDN服务器到GitHub Pages服务器的连接为http。<br>1.注册并登录到CF。按照提示，在你的域名的管理中心，将域名的name server改为CF的name server。CF提供的NS如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NS</td>
<td style="text-align:center">bob.ns.cloudflare.com</td>
</tr>
<tr>
<td style="text-align:center">NS</td>
<td style="text-align:center">jamie.ns.cloudflare.com</td>
</tr>
</tbody>
</table>
<p>2.在CF的DNS设置页中，检查对应的子域名记录。博主的DNS记录如下：<br>  <img src="/2016/01/28/github-pages-with-https/dns-config.png" title="blog.chionlab.moe的DNS记录"><br>  其中，右侧的橙色云图标代表该条记录将经过CF的CDN加速。<br>  在这里设置的DNS记录，如果是CNAME记录或者A记录，若右边的STATUS为连通状态，CF都会在name server中将其设置为A记录并指向CF的CDN服务器（并根据用户所在地选择最优CDN），当用户通过该域名访问CF的CDN时（仅限http或https），CDN再转发到刚才填写的真实目的主机（即username.github.io）<br>  <img src="/2016/01/28/github-pages-with-https/dig-result.png" title="博主的blog.chionlab.moe虽在CF中设置为CNAME到gh-pages，但dig结果是A指向CF的CDN"><br>  CF正是通过这种动态DNS的方式实现CDN加速的。</p>
<h2 id="设置https"><a href="#设置https" class="headerlink" title="设置https"></a>设置https</h2><ol>
<li>在CF的Crypto页中，SSL设置为Flexible。这将允许CDN到github pages之间的访问为http。</li>
<li>现在，通过<code>https://你的域名</code>已经可以访问站点首页了。</li>
</ol>
<h2 id="强制https"><a href="#强制https" class="headerlink" title="强制https"></a>强制https</h2><p>CF提供Page Rules功能，可设置路由规则。通过规则中的<code>Always use https</code>选项，可以将用户强制跳转到https。博主的设置如下：<br><img src="/2016/01/28/github-pages-with-https/page-rules.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/28/github-pages-with-https/" data-id="cjf4w2ob5000i6t2hbn5rpigt" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/28/github-pages-with-https/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-cc-defence-log" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/27/cc-defence-log/" class="article-date">
  <time datetime="2016-01-26T19:28:34.000Z" itemprop="datePublished">2016-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/运维/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/cc-defence-log/">运维纪录：遭遇CC攻击，防御与查水表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>博主之前完成了一个外包项目，最近两个月在负责这个项目的运维。这是一个web，主营不良资产催收O2O。由于可能存在竞争对手，有人试图攻击服务器。</p>
<h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>24日下午3点，博主正在去拜访亲戚家的路上，这时公司的菜鸟开发者突然从QQ上发消息过来，问我服务器是不是被黑了。我认为这个可能性不大。这个项目由我亲手带领团队开发，后端使用的是Python+Flask+PostgreSQL，前端使用nodejs+express实现的midway，服务器部署也是由博主亲手完成。这类技术栈，已公布的可直接利用的漏洞十分有限，再者，博主在领队开发时已多次强调安全的重要性，具体到每个API都对用户权限进行了严格认证，编码过程中也不存在可能被注入、被远程执行等低级的危险代码，于是博主认为服务器被web渗透的可能性非常小。当然，不排除黑客从web之外的服务渗透进入，但是服务器上除了web只有ssh服务（强密码+公钥认证），除非公司的开发者部署了其他服务，否则能渗进来的可能性不大。</p>
<p>博主于是立即用手机访问网站，网站返回了504，这说明nginx的上游没有响应了，node midway或者Python后端，肯定有一个处于freeze状态。</p>
<p>到达亲戚家后，经过简短的问候，我即问道有没有能用的电脑。朋友让我使用一台08年的笔记本，运行的XP系统，只有IE8和360安全浏览器，但是已经够用了。下载Putty后ssh连接上服务器，立即<code>killall supervisord &amp;&amp; supervisord</code>。因为node midway和Python后端都处于开发中状态，为了调试方便，所以直接是用supervisor作为daemon的。结果是，网站首页仍然返回504。</p>
<p>下意识地<code>tail /var/log/nginx/access.log -n 100</code>，出来的结果让我目瞪口呆.jpg<br><img src="/2016/01/27/cc-defence-log/cc_access_log_1.jpg" title="nginx access log:图中/api开头的URL全是短信API"><br>我立即就知道是怎么一回事了：黑客在flood发送短信的API。由于当时开发急促，没有对短信API加入图形验证码或者reCaptcha之类的验证，使得可以通过软件实现模拟请求，并且由于项目处于开发中，为方便调试没有使用wsgi容器调度请求和超时处理，再者，由于发送短信需要服务器向第三方短信平台请求，这个请求将比较费时，同时的大量请求使得Python后端完全被阻塞，难怪nginx报504。从log上看，flood来源自多个不同的IP，这是分布式的攻击，算得上是一场小型的CC攻击。后来发现参与这次CC的肉鸡大概有700～800台。</p>
<p><strong>出于保密原则，本文以下内容中，发送短信API的URI均由[SMS_API]代替</strong></p>
<h2 id="应急防御"><a href="#应急防御" class="headerlink" title="应急防御"></a>应急防御</h2><p>运行了一下<code>cat /var/log/nginx/access.log | grep &#39;[SMS_API]&#39; | wc -l</code>，返回的数字超过了30万，这时公司购买的短信平台套餐肯定已经用光了。但是现在首先要考虑恢复网站的正常访问。</p>
<p>对于这种小型的CC防御，除了ban ip之外我没有想到更好的解决方法。于是，我用ipset+iptables将当天访问过短信API的IP全部ban了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ipset create blacklist hash:net</span><br><span class="line"># cat /var/log/nginx/access.log | grep &apos;[SMS_API]&apos; | awk &apos;&#123;print $1&#125;&apos; | while read line;do ipset add blacklist $line;done  #将访问过短信API的IP全部加入ipset的blacklist集合</span><br><span class="line"># iptables -I INPUT -m set --match-set blacklist src -j DROP</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>笔记： iptables -m set –match-set [SET_NAME] [src|dst]</p>
</blockquote>
<p>执行后，再查看access log，flood马上就停下来了。但是现在遇到了新问题：后端跑不起来了。</p>
<h2 id="修复后端"><a href="#修复后端" class="headerlink" title="修复后端"></a>修复后端</h2><p>手动运行后端Python脚本，Peewee报不能连接上数据库。<br>跑了一下psql，发现正常读取数据，再查看PostgreSQL的log，没有发现异常。没有头绪，通知公司的后端开发者检查后端代码。<br>公司的开发者没有回应，我折腾了很久找不到问题所在，直到我想到会不会是刚才添加iptables过滤规则时把本机也过滤了。<br>试着运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset test blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 is in set blacklist.</span><br></pre></td></tr></table></figure></p>
<p>再次目瞪口呆.jpg。突然想起来，刚才我为了测试短信接口，在服务器上跑了一下<code>curl localhost/[SMS_API]</code>，于是nginx access log中就有了127.0.0.1，然后在跑脚本的时候就把127.0.0.1加入到blacklist中了。立即运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset del blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>再次重启后端，一切正常，网站也能够访问了。</p>
<h2 id="nginx中添加访问限制"><a href="#nginx中添加访问限制" class="headerlink" title="nginx中添加访问限制"></a>nginx中添加访问限制</h2><p>目前后端是从session判断唯一用户的，并限制每个用户每分钟只能调用短信API一次。但是如果黑客手动清空cookie，服务器将允许再次请求。在nginx的文档中快速查找了一下，发现nginx支持从IP上request limit。现在需要限制1 request/min per IP，为此修改nginx配置：</p>
<ol>
<li><p>添加limit_req_zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  limit_req_zone $binary_remote_addr zone=sms:10m rate=1r/m;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>location中应用limit_req_zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  location ~ ^([SMS_API]) &#123;</span><br><span class="line">      limit_req zone=sms nodelay;</span><br><span class="line">      proxy_pass http://127.0.0.1:5000;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>经过这样的配置，同一IP在一分钟内只能访问该URL一次，否则返回503 server unavailable。</p>
<h2 id="脚本实现自动Ban-IP"><a href="#脚本实现自动Ban-IP" class="headerlink" title="脚本实现自动Ban IP"></a>脚本实现自动Ban IP</h2><p>之后发现源源不断地还有更多IP试图发起CC，不可能人工一个一个的ban，于是写了一个简单shell脚本实现：当天access log中，访问短信API超过30次的IP，将被加入黑名单。当然，这只是临时的，生产环境中，对于同一内网中的多个真实用户可能会出现误ban的情况，因此攻击过后要将脚本关闭。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">while [ True ]</span><br><span class="line">do</span><br><span class="line">        cat /var/log/nginx/access.log | grep '[SMS_API]' | awk '&#123;print $1&#125;' | sort | uniq -c | awk '$1&gt;30&#123;print $2&#125;' | while read line;do echo 'Blocking IP:'$line &amp;&amp; ipset add blacklist $line;done</span><br><span class="line">        sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="找出攻击发起者"><a href="#找出攻击发起者" class="headerlink" title="找出攻击发起者"></a>找出攻击发起者</h2><p>由于CC分布式的特征，很难找出真正的攻击发起者。但是，往往可以找到第一个嫌疑者。通过翻看当天上午的access log，发现如下有趣的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:13 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;https://www.google.com/&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot; #使用Chrome进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:20 +0800] &quot;GET [SMS_API]?phone=1584059XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot;</span><br><span class="line">#在Chrome中点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p>
<p>正常的UA（Chrome 21.0.1180.89），并且有静态资源访问记录，基本可以确定是人工操作。<br>继续翻：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:27 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;-&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#注意，这个人在1分钟内使用了IE9重新进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:35 +0800] &quot;GET [SMS_API]?phone=1552442XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#这个人在1分钟内使用IE9再次点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p>
<p>普通用户是不会同时使用两款浏览器登录同一个网站并点击发送短信按钮的。除非——你想要验证这个网站是否根据session判断同一用户是否在一分钟内调用了多次发送短信API。再往后翻记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:51 +0800] &quot;GET [SMS_API]?phone=1504032XXXX HTTP/1.1&quot; 200 46 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure></p>
<p>果不其然，这个人用模拟请求调用了发送短信API（因为没有正常的UA）<br>在这的几分钟后，来自全国各地的肉鸡就开始flood服务器了。</p>
<h2 id="人肉攻击发起者"><a href="#人肉攻击发起者" class="headerlink" title="人肉攻击发起者"></a>人肉攻击发起者</h2><p>换位思考一下，如果我是黑客，在开始CC之前，是否需要测试一下这个API，然后再在肉鸡上配置随机手机号，最后再进行CC？<br>再次翻log，发现flood开始后，来自肉鸡的请求中，手机号码来自全国各地，但是都每个号码重复了很多次，并且每台肉鸡都有自己的手机号。据此可判断，肉鸡用的手机号码一定不是黑客本人或相关者的号码，而应该是随机生成的或者是通过非法渠道获取到的“受害者”的手机号。但是，113.232.156.* （即黑客嫌疑者）一开始在Chrome和IE9中用的号码在后面的记录中都没有找到，并且号码所属地和IP所属地吻合（都为辽宁沈阳），据此，怀疑黑客一开始在Chrome中会用真实的手机号先进行测试，然后再实施CC。<br>将黑客IP和他第一次在浏览器中提交的手机号码（1584059XXXX）告诉了公司，公司立即拨打了这个手机号码。<br>对方一开始不承认。后来对方打回来，问我们是什么网站做什么的，并且听到对面几个人在偷着乐。因此，对方很有可能就是这次攻击的发起者，并且可能是黑客团伙，专职外包。（其实博主认为，国内这种组织根本算不上真正意义上的黑客，只是非常低级的为了图利的非法技术组织，并且自身技术也是很菜…）<br>公司随后开始通过手机号码查询该人身份信息。由于公司本身性质的关系，有后台可以调查某些信息。<br>之后的事情我就没有多问了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/27/cc-defence-log/" data-id="cjf4w2oam00066t2hoj02a89b" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/27/cc-defence-log/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-tldr-man-page" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/23/tldr-man-page/" class="article-date">
  <time datetime="2016-01-23T07:48:33.000Z" itemprop="datePublished">2016-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/23/tldr-man-page/">tldr - 懒人的man page</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实我是十分不愿意在紧张开发时为了一个小工具翻看man page的，直到我从GitHub上找到这个工具。tldr即too long don’t read，提供简化版的man page，每页page只有非常简短的说明，十分适合懒人查询和情急时快速检索。当然，这个工具提供的page覆盖率还不够高，还有劳各位去发pull request。</p>
<p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p>
<h2 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h2><p>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm install -g tldr</span></span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tldr aria2c</span></span><br></pre></td></tr></table></figure></p>
<p>Done!</p>
<p>最后提一下，时间充裕时还是尽量去阅读完整版的man page！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/23/tldr-man-page/" data-id="cjf4w2obz001e6t2hhbgavcm7" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/23/tldr-man-page/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>





  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OSX/">OSX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/">开发笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/网络/">网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/逆向/">逆向</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSX/">OSX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/front-end/">front-end</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/OSX/" style="font-size: 12px;">OSX</a> <a href="/tags/React/" style="font-size: 16px;">React</a> <a href="/tags/android/" style="font-size: 14px;">android</a> <a href="/tags/backend/" style="font-size: 12px;">backend</a> <a href="/tags/crawler/" style="font-size: 12px;">crawler</a> <a href="/tags/front-end/" style="font-size: 18px;">front-end</a> <a href="/tags/hack/" style="font-size: 14px;">hack</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/maintenance/" style="font-size: 18px;">maintenance</a> <a href="/tags/network/" style="font-size: 16px;">network</a> <a href="/tags/nginx/" style="font-size: 12px;">nginx</a> <a href="/tags/openwrt/" style="font-size: 10px;">openwrt</a> <a href="/tags/python/" style="font-size: 12px;">python</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/wechat/" style="font-size: 12px;">wechat</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近发表</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/09/full-cone-nat-with-linux/">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a>
          </li>
        
          <li>
            <a href="/2017/04/06/kcptun-with-fake-tcp/">kcptun-raw：应对UDP QoS，重新实现kcptun的一次尝试</a>
          </li>
        
          <li>
            <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
          </li>
        
          <li>
            <a href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
          </li>
        
          <li>
            <a href="/2016/11/07/tcp-keepalive-on-chrome/">TCP keepalive的探究 (2) : 浏览器的Keepalive机制</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
  <h3 class="widget-title">友链</h3>
  <div class="widget">
    <a href="https://www.starduster.me" target="_blank">星尘独奏曲</a><br />
    <a href="http://www.zhouchao.me" target="_blank">chao's blog</a><br />
    <a href="http://ilazycat.com" target="_blank">小黑猫菊苣的猫窝</a><br />
    <a href="https://loli.be" target="_blank">Mashiro's Blog</a><br />
    <a href="https://bismarck.moe" target="_blank">雨宫千鹤的博客</a><br />
    <a href="https://blessing.studio" target="_blank">Blessing Studio</a><br />
    <a href="https://wwww.lvmoo.com" target="_blank">凯の秘密基地</a><br />
    <a href="https://apporz.com" target="_blank">Micooz's Personal Site</a><br />
    <a href="https://stefenson.github.io" target="_blank">Stefenson's Blog</a><br />
    <a href="https://sunskyxh.github.io" target="_blank">香香鸡的小窝</a>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chion Tang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, themed &amp; customized by Chion
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/Chion82" class="mobile-nav-link">GitHub</a>
  
    <a href="/about.html" class="mobile-nav-link">About Me</a>
  
</nav>
    
<script>
  var disqus_shortname = 'chionlab';
  if (/*window.location.hostname.indexOf('cn2') === -1*/true) {
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
  } else {
    var disqusElements = document.querySelectorAll('.disqus-comments-section, .disqus-comment-link');
    for (var i=0; i<disqusElements.length; i++) {
      disqusElements[i].style.display = 'none';
    }
  }
</script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>