<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ChionLab | 一个萌豚开发者的窝 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="ChionLab">
<meta property="og:url" content="https://blog.chionlab.moe/page/3/index.html">
<meta property="og:site_name" content="ChionLab">
<meta property="og:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChionLab">
<meta name="twitter:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="ChionLab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
  
  <link href="/stylesheets/googlefonts.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    .article-duoshuo-link {
      float: right;
      margin-left: 20px;
    }
    .article-duoshuo-link:before {
      content: "\f086";
      font-family: "FontAwesome";
      padding-right: 8px;
    }
    .jc-bs3-container {
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <link href="/stylesheets/jquery-confirm.min.css" rel="stylesheet" type="text/css">
  <script src="/scripts/jquery-2.2.0.min.js"></script>
  <script src="/scripts/jquery-confirm.min.js"></script>
  <!--
  
    <script>
      var yunModuleEnv = true;
    </script>
    <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
  
  -->

  
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script>
    var JS_COOKIES_DOMAIN = '.chionlab.moe';
    var JsCookies = {
      // this gets a cookie and returns the cookies value, if no cookies it returns blank ""
      get: function(c_name) {
        if (document.cookie.length > 0) {
          var c_start = document.cookie.indexOf(c_name + "=");
          if (c_start != -1) {
            c_start = c_start + c_name.length + 1;
            var c_end = document.cookie.indexOf(";", c_start);
            if (c_end == -1) {
              c_end = document.cookie.length;
            }
            return unescape(document.cookie.substring(c_start, c_end));
          }
        }
        return "";
      },

      // this sets a cookie with your given ("cookie name", "cookie value", "good for x days")
      set: function(c_name, value, expiredays) {
        var exdate = new Date();
        if (expiredays)
          exdate.setDate(exdate.getDate() + expiredays);
        document.cookie = c_name + "=" + escape(value) + "; path=/" + "; domain=" + JS_COOKIES_DOMAIN + ((expiredays == undefined) ? "" : "; expires=" + exdate.toUTCString());
      },

      // this checks to see if a cookie exists, then returns true or false
      check: function(c_name) {
        c_name = JsCookies.get(c_name);
        if (c_name != null && c_name != "") {
          return true;
        } else {
          return false;
        }
      }

    };
  </script>

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChionLab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎来到Chion82的未来道具研究所 ( ゜- ゜)つロ 乾杯~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="https://github.com/Chion82">GitHub</a>
        
          <a class="main-nav-link" href="/about.html">About Me</a>
        
        <!-- <a class="main-nav-link nav-link-switch-cdn" href="//cn2.chionlab.moe" data-domain="cn2">CN2加速</a>
        <a class="main-nav-link nav-link-switch-cdn" href="//blog.chionlab.moe" data-domain="blog">CF加速</a> -->

        
          <div style="clear: both;"></div>
          <style>
            .switch-theme-btn {
              opacity: 0.8 !important;
            }

            .switch-theme-btn:hover {
              opacity: 1.0 !important;
            }
          </style>
          <div>
            <!--
              
                <a class="main-nav-link switch-theme-btn"
                  title="uzume" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/css/style.css"
                  data-theme-name="uzume">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_uzume.png" />
                  </div>
                </a>
              
                <a class="main-nav-link switch-theme-btn"
                  title="miria" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/stylesheets/theme_miria.css"
                  data-theme-name="miria">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_miria.png" />
                  </div>
                </a>
              
            -->
          </div>
          <script>
            // (function(){
            //
            //   function switchThemeCSS(themeName, cssUrl) {
            //     document.querySelector('head').querySelectorAll('link[rel=stylesheet]')[1].href = cssUrl;
            //   }
            //
            //   var switchThemeBtns = document.querySelectorAll('.switch-theme-btn');
            //   for (var i=0; i<switchThemeBtns.length; i++) {
            //     var switchThemeBtn = switchThemeBtns[i];
            //     (function(switchThemeBtn) {
            //       switchThemeBtn.addEventListener('click', function(){
            //         switchThemeCSS(switchThemeBtn.dataset.themeName, switchThemeBtn.dataset.cssUrl);
            //         JsCookies.set('theme', switchThemeBtn.dataset.themeName, 30);
            //       });
            //     })(switchThemeBtn);
            //   }
            //
            //   var initTheme = JsCookies.get('theme');
            //   if (initTheme) {
            //     var cssUrl = document.querySelector(".switch-theme-btn[data-theme-name='" + initTheme + "']").dataset.cssUrl;
            //     switchThemeCSS(initTheme, cssUrl);
            //   }
            //
            // })();
          </script>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.chionlab.moe"></form>
      </div>
    </div>
  </div>
  <script>
    // function getGeolocation(geoInfo) {
    //   var rootDomain = 'chionlab.moe';
    //   if (geoInfo.country_code === 'CN') {
    //     if (window.location.hostname === 'cn2' + '.' + rootDomain) {
    //       JsCookies.set('domain', 'cn2', 30);
    //       return;
    //     }
    //     $.confirm({
    //       title: '线路优化建议',
    //       content: '检测到您是境内用户，为了提高您的访问体验，是否切换到CN2线路？',
    //       buttons: {
    //         '好的': function() {
    //           JsCookies.set('domain', 'cn2', 30);
    //           window.location.href = '//' + 'cn2' + '.' + rootDomain + window.location.pathname;
    //         },
    //         '不用了': function() {
    //           JsCookies.set('domain', 'blog', 30);
    //         }
    //       }
    //     })
    //   } else {
    //     JsCookies.set('domain', 'blog', 30);
    //     if ('blog' + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + 'blog' + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    // }
    // (function(){
    //   var rootDomain = 'chionlab.moe';
    //
    //   if (!JsCookies.check('domain')) {
    //     var geoLocationScript = document.createElement('script');
    //     geoLocationScript.setAttribute('src','//freegeoip.net/json/?callback=getGeolocation');
    //     document.head.appendChild(geoLocationScript);
    //   } else {
    //     if (JsCookies.get('domain') + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + JsCookies.get('domain') + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    //
    //   var switchBtns = document.querySelectorAll('.nav-link-switch-cdn');
    //   for (var i=0; i<switchBtns.length; i++) {
    //     (function(switchBtn){
    //       if (switchBtn.dataset.domain === JsCookies.get('domain')) {
    //         switchBtn.style.display = 'none';
    //       }
    //       switchBtn.addEventListener('click', function(ev) {
    //         JsCookies.set('domain', switchBtn.dataset.domain);
    //       });
    //     })(switchBtns[i]);
    //   }
    // })();
  </script>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-cc-defence-log" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/27/cc-defence-log/" class="article-date">
  <time datetime="2016-01-26T19:28:34.000Z" itemprop="datePublished">2016-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/运维/">运维</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/cc-defence-log/">运维纪录：遭遇CC攻击，防御与查水表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>博主之前完成了一个外包项目，最近两个月在负责这个项目的运维。这是一个web，主营不良资产催收O2O。由于可能存在竞争对手，有人试图攻击服务器。</p>
<h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>24日下午3点，博主正在去拜访亲戚家的路上，这时公司的菜鸟开发者突然从QQ上发消息过来，问我服务器是不是被黑了。我认为这个可能性不大。这个项目由我亲手带领团队开发，后端使用的是Python+Flask+PostgreSQL，前端使用nodejs+express实现的midway，服务器部署也是由博主亲手完成。这类技术栈，已公布的可直接利用的漏洞十分有限，再者，博主在领队开发时已多次强调安全的重要性，具体到每个API都对用户权限进行了严格认证，编码过程中也不存在可能被注入、被远程执行等低级的危险代码，于是博主认为服务器被web渗透的可能性非常小。当然，不排除黑客从web之外的服务渗透进入，但是服务器上除了web只有ssh服务（强密码+公钥认证），除非公司的开发者部署了其他服务，否则能渗进来的可能性不大。</p>
<p>博主于是立即用手机访问网站，网站返回了504，这说明nginx的上游没有响应了，node midway或者Python后端，肯定有一个处于freeze状态。</p>
<p>到达亲戚家后，经过简短的问候，我即问道有没有能用的电脑。朋友让我使用一台08年的笔记本，运行的XP系统，只有IE8和360安全浏览器，但是已经够用了。下载Putty后ssh连接上服务器，立即<code>killall supervisord &amp;&amp; supervisord</code>。因为node midway和Python后端都处于开发中状态，为了调试方便，所以直接是用supervisor作为daemon的。结果是，网站首页仍然返回504。</p>
<p>下意识地<code>tail /var/log/nginx/access.log -n 100</code>，出来的结果让我目瞪口呆.jpg<br><img src="/2016/01/27/cc-defence-log/cc_access_log_1.jpg" title="nginx access log:图中/api开头的URL全是短信API"><br>我立即就知道是怎么一回事了：黑客在flood发送短信的API。由于当时开发急促，没有对短信API加入图形验证码或者reCaptcha之类的验证，使得可以通过软件实现模拟请求，并且由于项目处于开发中，为方便调试没有使用wsgi容器调度请求和超时处理，再者，由于发送短信需要服务器向第三方短信平台请求，这个请求将比较费时，同时的大量请求使得Python后端完全被阻塞，难怪nginx报504。从log上看，flood来源自多个不同的IP，这是分布式的攻击，算得上是一场小型的CC攻击。后来发现参与这次CC的肉鸡大概有700～800台。</p>
<p><strong>出于保密原则，本文以下内容中，发送短信API的URI均由[SMS_API]代替</strong></p>
<h2 id="应急防御"><a href="#应急防御" class="headerlink" title="应急防御"></a>应急防御</h2><p>运行了一下<code>cat /var/log/nginx/access.log | grep &#39;[SMS_API]&#39; | wc -l</code>，返回的数字超过了30万，这时公司购买的短信平台套餐肯定已经用光了。但是现在首先要考虑恢复网站的正常访问。</p>
<p>对于这种小型的CC防御，除了ban ip之外我没有想到更好的解决方法。于是，我用ipset+iptables将当天访问过短信API的IP全部ban了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ipset create blacklist hash:net</span><br><span class="line"># cat /var/log/nginx/access.log | grep &apos;[SMS_API]&apos; | awk &apos;&#123;print $1&#125;&apos; | while read line;do ipset add blacklist $line;done  #将访问过短信API的IP全部加入ipset的blacklist集合</span><br><span class="line"># iptables -I INPUT -m set --match-set blacklist src -j DROP</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>笔记： iptables -m set –match-set [SET_NAME] [src|dst]</p>
</blockquote>
<p>执行后，再查看access log，flood马上就停下来了。但是现在遇到了新问题：后端跑不起来了。</p>
<h2 id="修复后端"><a href="#修复后端" class="headerlink" title="修复后端"></a>修复后端</h2><p>手动运行后端Python脚本，Peewee报不能连接上数据库。<br>跑了一下psql，发现正常读取数据，再查看PostgreSQL的log，没有发现异常。没有头绪，通知公司的后端开发者检查后端代码。<br>公司的开发者没有回应，我折腾了很久找不到问题所在，直到我想到会不会是刚才添加iptables过滤规则时把本机也过滤了。<br>试着运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset test blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 is in set blacklist.</span><br></pre></td></tr></table></figure></p>
<p>再次目瞪口呆.jpg。突然想起来，刚才我为了测试短信接口，在服务器上跑了一下<code>curl localhost/[SMS_API]</code>，于是nginx access log中就有了127.0.0.1，然后在跑脚本的时候就把127.0.0.1加入到blacklist中了。立即运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset del blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>再次重启后端，一切正常，网站也能够访问了。</p>
<h2 id="nginx中添加访问限制"><a href="#nginx中添加访问限制" class="headerlink" title="nginx中添加访问限制"></a>nginx中添加访问限制</h2><p>目前后端是从session判断唯一用户的，并限制每个用户每分钟只能调用短信API一次。但是如果黑客手动清空cookie，服务器将允许再次请求。在nginx的文档中快速查找了一下，发现nginx支持从IP上request limit。现在需要限制1 request/min per IP，为此修改nginx配置：</p>
<ol>
<li><p>添加limit_req_zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  limit_req_zone $binary_remote_addr zone=sms:10m rate=1r/m;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>location中应用limit_req_zone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  location ~ ^([SMS_API]) &#123;</span><br><span class="line">      limit_req zone=sms nodelay;</span><br><span class="line">      proxy_pass http://127.0.0.1:5000;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>经过这样的配置，同一IP在一分钟内只能访问该URL一次，否则返回503 server unavailable。</p>
<h2 id="脚本实现自动Ban-IP"><a href="#脚本实现自动Ban-IP" class="headerlink" title="脚本实现自动Ban IP"></a>脚本实现自动Ban IP</h2><p>之后发现源源不断地还有更多IP试图发起CC，不可能人工一个一个的ban，于是写了一个简单shell脚本实现：当天access log中，访问短信API超过30次的IP，将被加入黑名单。当然，这只是临时的，生产环境中，对于同一内网中的多个真实用户可能会出现误ban的情况，因此攻击过后要将脚本关闭。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">while [ True ]</span><br><span class="line">do</span><br><span class="line">        cat /var/log/nginx/access.log | grep '[SMS_API]' | awk '&#123;print $1&#125;' | sort | uniq -c | awk '$1&gt;30&#123;print $2&#125;' | while read line;do echo 'Blocking IP:'$line &amp;&amp; ipset add blacklist $line;done</span><br><span class="line">        sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="找出攻击发起者"><a href="#找出攻击发起者" class="headerlink" title="找出攻击发起者"></a>找出攻击发起者</h2><p>由于CC分布式的特征，很难找出真正的攻击发起者。但是，往往可以找到第一个嫌疑者。通过翻看当天上午的access log，发现如下有趣的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:13 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;https://www.google.com/&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot; #使用Chrome进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:20 +0800] &quot;GET [SMS_API]?phone=1584059XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot;</span><br><span class="line">#在Chrome中点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p>
<p>正常的UA（Chrome 21.0.1180.89），并且有静态资源访问记录，基本可以确定是人工操作。<br>继续翻：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:27 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;-&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#注意，这个人在1分钟内使用了IE9重新进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:35 +0800] &quot;GET [SMS_API]?phone=1552442XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#这个人在1分钟内使用IE9再次点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p>
<p>普通用户是不会同时使用两款浏览器登录同一个网站并点击发送短信按钮的。除非——你想要验证这个网站是否根据session判断同一用户是否在一分钟内调用了多次发送短信API。再往后翻记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:51 +0800] &quot;GET [SMS_API]?phone=1504032XXXX HTTP/1.1&quot; 200 46 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure></p>
<p>果不其然，这个人用模拟请求调用了发送短信API（因为没有正常的UA）<br>在这的几分钟后，来自全国各地的肉鸡就开始flood服务器了。</p>
<h2 id="人肉攻击发起者"><a href="#人肉攻击发起者" class="headerlink" title="人肉攻击发起者"></a>人肉攻击发起者</h2><p>换位思考一下，如果我是黑客，在开始CC之前，是否需要测试一下这个API，然后再在肉鸡上配置随机手机号，最后再进行CC？<br>再次翻log，发现flood开始后，来自肉鸡的请求中，手机号码来自全国各地，但是都每个号码重复了很多次，并且每台肉鸡都有自己的手机号。据此可判断，肉鸡用的手机号码一定不是黑客本人或相关者的号码，而应该是随机生成的或者是通过非法渠道获取到的“受害者”的手机号。但是，113.232.156.* （即黑客嫌疑者）一开始在Chrome和IE9中用的号码在后面的记录中都没有找到，并且号码所属地和IP所属地吻合（都为辽宁沈阳），据此，怀疑黑客一开始在Chrome中会用真实的手机号先进行测试，然后再实施CC。<br>将黑客IP和他第一次在浏览器中提交的手机号码（1584059XXXX）告诉了公司，公司立即拨打了这个手机号码。<br>对方一开始不承认。后来对方打回来，问我们是什么网站做什么的，并且听到对面几个人在偷着乐。因此，对方很有可能就是这次攻击的发起者，并且可能是黑客团伙，专职外包。（其实博主认为，国内这种组织根本算不上真正意义上的黑客，只是非常低级的为了图利的非法技术组织，并且自身技术也是很菜…）<br>公司随后开始通过手机号码查询该人身份信息。由于公司本身性质的关系，有后台可以调查某些信息。<br>之后的事情我就没有多问了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/27/cc-defence-log/" data-id="cjdiq02s200082c2hxna1ltpu" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/27/cc-defence-log/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-optimize-shadowsocks-on-openwrt" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/27/optimize-shadowsocks-on-openwrt/" class="article-date">
  <time datetime="2016-01-26T17:45:48.000Z" itemprop="datePublished">2016-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/optimize-shadowsocks-on-openwrt/">OpenWRT自动科学上网的问题及优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在<a href="/2016/01/23/openwrt-bypass-gfw-solution/">OpenWRT路由器配置ShadowSocks+ChinaDNS</a>虽然使用起来十分优雅和方便，但是因为ISP质量问题，可能随之会带来很多稳定性问题，包括但不限以下作者遇到过的问题：</p>
<ul>
<li>ISP封杀境外UDP流量，导致SS的UDP隧道非常不稳定，ChinaDNS查询失败（比如广州电信部分地区）</li>
<li>链路拥堵时，到ss服务器的多并发TCP连接无法建立成功，新建立的连接容易卡在<code>SYN_SENT</code>，最终导致超时</li>
<li>ChinaDNS长时间运行后可能出现的解析不正常的情况，表现为始终返回国外DNS结果，导致国内网站访问缓慢<br>针对以上问题，作者琢磨出一些优化方法。</li>
</ul>
<h2 id="优化UDP稳定性"><a href="#优化UDP稳定性" class="headerlink" title="优化UDP稳定性"></a>优化UDP稳定性</h2><p>由于ISP封杀境外UDP包，那么UDP只可以走境内。那么可以将一台境内服务器作为UDP跳板。TCP包直接发到境外的ss服务器，UDP包则经过境内的跳板服务器中转到ss服务器。跳板服务器可以选择阿里云、腾讯云等，带宽不需要太大，1M都完全够了，主要是用来中转DNS查询包。作者用的是腾讯云的1元／月的学生优惠。</p>
<p>一、在UDP跳板服务器上进行以下配置以实现中转。</p>
<ol>
<li><p>开启内核的ip_forward</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>
<p>将<code>net.ipv4.ip_forward=0</code>修改为<code>net.ipv4.ip_forward=1</code>。如果文件为空，则添加一行<code>net.ipv4.ip_forward=1</code>即可。<br>运行这条命令即时生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>用iptables实现TCP+UDP中转</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -t nat -A PREROUTING -p tcp --dport [PORT] -j DNAT --to-destination X.X.X.X:X</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -t nat -A PREROUTING -p ucp --dport [PORT] -j DNAT --to-destination X.X.X.X:X</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -t nat -A POSTROUTING -j MASQUERADE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service iptables save <span class="comment">#永久保存修改</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>X.X.X.X:X</code>为ss服务器IP和端口，<code>[PORT]</code>为跳板服务器上用于中转的监听端口（为了方便，可以和ss服务器的端口相同）。</p>
</li>
</ol>
<p>二、修改OpenWRT上的配置</p>
<ol>
<li><p>ssh连接上路由器，建立一个跳板服务器的ss配置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp /var/etc/shadowsocks.json /root/shadowsocks_udp.json <span class="comment">#复制当前的ss配置文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /root/shadowsocks_udp.json</span></span><br></pre></td></tr></table></figure>
<p>然后修改<code>/root/shadowsocks_udp.json</code>，将远程服务器IP改为跳板服务器的IP，远程端口改为跳板服务器的监听端口（即刚才的<code>[PORT]</code>）</p>
</li>
<li><p>然后需要修改shadowsocks的启动脚本，让ss隧道使用跳板服务器的配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/init.d/shadowsocks</span><br></pre></td></tr></table></figure>
<p>在<code>CONFIG_FILE=/var/etc/shadowsocks.json</code>下增加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP_CONFIG_FILE=/root/shadowsocks_udp.json</span><br></pre></td></tr></table></figure>
<p>找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ss-tunnel \       </span><br><span class="line">              -c $CONFIG_FILE \        </span><br><span class="line">              -l $tunnel_port \          </span><br><span class="line">              -L $tunnel_forward \</span><br><span class="line">              -f /var/run/ss-tunnel.pid \</span><br></pre></td></tr></table></figure>
<p>将其修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ss-tunnel \       </span><br><span class="line">              -c $UDP_CONFIG_FILE \        </span><br><span class="line">              -l $tunnel_port \          </span><br><span class="line">              -L $tunnel_forward \</span><br><span class="line">              -f /var/run/ss-tunnel.pid \</span><br></pre></td></tr></table></figure>
<p>保存后重启shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="优化TCP稳定性"><a href="#优化TCP稳定性" class="headerlink" title="优化TCP稳定性"></a>优化TCP稳定性</h2><ol>
<li>最好的方法是选择链路质量好的服务器作为ss服务器，比如香港的vps，将不容易出现多并发TCP连接无法建立的情况。</li>
<li>如果不能选择更换ss服务器，可在ss服务器上同时监听多个端口，同时在路由器上使用haproxy进行负载均衡，把ss服务器的多个端口加入到upstream列表中，由于haproxy超时自动更换upstream的特性，可大大降低连接失败的概率。详细操作方法作者将在下篇博文中介绍。</li>
</ol>
<h2 id="ChinaDNS偶然解析不正常的解决"><a href="#ChinaDNS偶然解析不正常的解决" class="headerlink" title="ChinaDNS偶然解析不正常的解决"></a>ChinaDNS偶然解析不正常的解决</h2><p>尚不明确为何ChinaDNS长时间运行后偶然地可能会始终返回国外DNS结果（重启ChinaDNS即恢复），作者之前尝试<a href="https://github.com/Chion82/ChinaDNS" target="_blank" rel="noopener">修改了一下ChinaDNS</a>，将判断某个IP是否为国内IP的逻辑修改为借助ipset来判断，但是作者没有测试过其稳定性。<br>本文介绍的解决方法很无脑，即定时重启ChinaDNS。使用cron，在每天的零时重启一次ChinaDNS。经作者测试，这招确实有效。<br>在路由器上运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># crontab -e</span><br></pre></td></tr></table></figure></p>
<p>添加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /etc/init.d/chinadns restart</span><br></pre></td></tr></table></figure></p>
<p>保存并重启路由器生效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/27/optimize-shadowsocks-on-openwrt/" data-id="cjdiq02tt00192c2h37yxje2t" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/27/optimize-shadowsocks-on-openwrt/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/router/">router</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-openwrt-bypass-gfw-solution" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/23/openwrt-bypass-gfw-solution/" class="article-date">
  <time datetime="2016-01-23T08:07:53.000Z" itemprop="datePublished">2016-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/23/openwrt-bypass-gfw-solution/">OpenWRT路由器上的ShadowSocks+ChinaDNS搭梯子方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在路由器上运行ShadowSocks科学上网是最为优雅的方案。本文将介绍其安装和配置步骤。<br>首先为智能路由器刷上OpenWRT，博主推荐<a href="http://downloads.openwrt.org.cn/PandoraBox/" target="_blank" rel="noopener">Pandorabox</a>修改版。本文将实现：连接上路由器的客户端当访问国内主机时，直接连接，而访问国外主机时，自动代理。</p>
<blockquote>
<p>2016.12.25更新：<br>openwrt shadowsocks作者已不在SourceForge上更新，大家可以直接到Github Release下载预编译包（感谢Blessing Studio博主提醒）：<br><a href="https://github.com/shadowsocks/openwrt-shadowsocks/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/openwrt-shadowsocks/releases</a><br>另外可以参考博主最新的 <a href="https://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/">tinc VPN策略路由</a> ，使用更优雅的方式科学上网</p>
</blockquote>
<h2 id="安装ShadowSocks"><a href="#安装ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><ol>
<li><p>因为本文讨论的是SS+ChinaDNS的翻墙方案，对于部分已集成SS+domain list的固件版本，需要先删除已安装的SS及相关工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ssh连接上路由器后运行</span><br><span class="line">$ opkg list_installed | grep shadowsocks #查询已安装的ss和相关工具</span><br><span class="line"># opkg remove shadowsocks-* #删除之</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载安装shadowsocks-libev-spec<br><a href="https://github.com/shadowsocks/openwrt-shadowsocks/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/openwrt-shadowsocks/releases</a><br>经作者测试，最新版在极贰最新OpenWRT固件上会出现iptables规则失效的情况，建议使用<code>shadowsocks-libev-spec_2.3.0-1_XXXX</code>版本。<br>以MT7620系列为例，在路由器上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># opkg update</span><br><span class="line"># cd /tmp</span><br><span class="line"># wget http://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/2.3.0-3ff06a6/ramips/shadowsocks-libev-spec_2.3.0-1_ramips_24kec.ipk  #如果不是ramips平台，请根据路由器ARCH选择对应ipk</span><br><span class="line"># opkg install shadowsocks-libev-spec_2.3.0-1_ramips_24kec.ipk</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载安装luci-app-shadowsocks-spec<br>luci-app提供ss的图形化配置界面。<br><a href="http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/</a><br>如果<code>shadowsocks-libev-spec</code>使用的版本是本文推荐的<code>2.3.0</code>，请下载<code>luci-app-shadowsocks-spec_1.3.2-1_all.ipk</code>。路由器上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/luci-app-shadowsocks-spec_1.3.2-1_all.ipk</span><br><span class="line"># opkg install luci-app-shadowsocks-spec_1.3.2-1_all.ipk</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安装ChinaDNS"><a href="#安装ChinaDNS" class="headerlink" title="安装ChinaDNS"></a>安装ChinaDNS</h2><p>ChinaDNS用于解决国内DNS污染问题，同时可加速国内网站的访问。其原理如下：<br>提供至少一个国内DNS服务器和一个国外DNS服务器，ChinaDNS收到来自用户的DNS请求后，同时向这两个服务器发DNS请求。如果从国内DNS服务器返回的解析结果为国外IP，则选择国外DNS服务器的解析结果，否则选择国内DNS的解析结果，最后返回给用户。<br><a href="http://sourceforge.net/projects/openwrt-dist/files/chinadns/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/chinadns/</a></p>
<ol>
<li><p>ChinaDNS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://sourceforge.net/projects/openwrt-dist/files/chinadns/1.3.2-d3e75dd/ChinaDNS_1.3.2-3_ramips_24kec.ipk</span><br><span class="line"># opkg install ChinaDNS_1.3.2-3_ramips_24kec.ipk</span><br></pre></td></tr></table></figure>
</li>
<li><p>luci-app-ChinaDNS<br><a href="http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/luci-app-chinadns_1.3.4-1_all.ipk</span><br><span class="line"># opkg install luci-app-chinadns_1.3.4-1_all.ipk</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置ShadowSocks"><a href="#配置ShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><ol>
<li><p>创建国内IP段列表，用于忽略国内目标主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /etc/shadowsocks</span><br><span class="line"># wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/shadowsocks/ignore.list</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用luci-app配置ss<br>进入路由器管理web页面，用root登录，进入服务(Services)-&gt;ShadowSocks。<br>勾选启用Shadowsocks，输入ss服务器信息（服务器IP、端口、密码、加密方式）。<br>代理方法(Proxy method)选择忽略列表(Ignore list)，并在–custom–中填入<code>/etc/shadowsocks/ignore.list</code>。代理协议(Proxy protocol)选择<code>TCP+UDP</code>。<br>开启UDP隧道，UDP本地端口5300，目的地址<code>8.8.8.8:53</code>。UDP隧道用于加密DNS查询包，稍后将会用到。<br><img src="/images/openwrt-ss-1.png" alt=""></p>
</li>
<li>保存并应用(Save and Apply)</li>
</ol>
<h2 id="配置ChinaDNS"><a href="#配置ChinaDNS" class="headerlink" title="配置ChinaDNS"></a>配置ChinaDNS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/chinadns_chnroute.txt</span><br></pre></td></tr></table></figure>
<p>在路由器web管理页面，进入服务(Services)-&gt;ChinaDNS。<br>勾选启用ChinaDNS，启用DNS压缩指针。<br>本地端口写5353，中国路由表(CHNRoute File)填<code>/etc/chinadns_chnroute.txt</code>。<br>上游DNS服务器填<code>114.114.114.114,127.0.0.1:5300</code>。（可将114.114.114.114改成当前ISP提供的DNS服务器IP）<br>这里将ss的UDP隧道作为ChinaDNS的国外DNS上游源。<br>保存并应用</p>
<h2 id="配置路由器DNS-Dnsmasq"><a href="#配置路由器DNS-Dnsmasq" class="headerlink" title="配置路由器DNS(Dnsmasq)"></a>配置路由器DNS(Dnsmasq)</h2><p>进入网络(Network)-&gt;DHCP and DNS。<br>将DNS转发(DNS forwardings)设置为<code>127.0.0.1#5353</code>。这将使得路由器将DNS请求经由dnsmasq全部转发至ChinaDNS处理。<br>这样设置后，从内网主机端发出的国外DNS请求将发送至：dnsmasq-&gt;ChinaDNS-&gt;ss-tunnel-&gt;ss服务器-&gt;8.8.8.8，<br>国内DNS请求则：dnsmasq-&gt;ChinaDNS-&gt;114.114.114.114<br>还要记得勾选“忽略解析文件”(ignore resolve file)。</p>
<p>至此，路由器上的梯子已经搭建完毕，如不出意外，你已经可以进youtube了。<br>但是，受路由器到ss服务器的链路质量影响，可能会出现不稳定的情况。例如某些ISP下会出现境外UDP流量丢包、多TCP并发连接容易建立失败等情况。博主将在下篇文章中介绍优化方案。</p>
<h2 id="关于shadowsocks-libev-spec的原理"><a href="#关于shadowsocks-libev-spec的原理" class="headerlink" title="关于shadowsocks-libev-spec的原理"></a>关于shadowsocks-libev-spec的原理</h2><p>通过分析ss的启动脚本，初步确定ss-libev-spec是以以下步骤实现自动翻墙的。</p>
<ol>
<li>运行<code>/usr/bin/ss-rules</code>，设置在ipset中建立一个列表<code>ss_spec_wan_ac</code>，列表中存放了<code>/etc/shadowsocks/ignore.list</code>中的IP段（即为需要忽略的国内IP段），然后设置iptables，在<code>nat</code>表的<code>OUTPUT</code>链中将目标地址<code>match-set ss_spec_wan_ac</code>的包采取<code>RETURN</code>处理。然后再在这条规则后增加一条，将全部包<code>REDIRECT</code>到<code>127.0.0.1:1080</code></li>
<li>运行<code>/usr/bin/ss-redir</code>，监听本地端口<code>1080</code>，负责将收到的包经由ss，加密socks代理至ss服务器。</li>
<li>运行<code>/usr/bin/ss-tunnel</code>，经由ss服务器建立加密的UDP隧道，隧道一端为本地监听端口<code>5300</code>，另一端为<code>8.8.8.8:53</code>。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/" data-id="cjdiq02tq00152c2h4zhvs9q8" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/router/">router</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-tldr-man-page" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/23/tldr-man-page/" class="article-date">
  <time datetime="2016-01-23T07:48:33.000Z" itemprop="datePublished">2016-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/23/tldr-man-page/">tldr - 懒人的man page</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>其实我是十分不愿意在紧张开发时为了一个小工具翻看man page的，直到我从GitHub上找到这个工具。tldr即too long don’t read，提供简化版的man page，每页page只有非常简短的说明，十分适合懒人查询和情急时快速检索。当然，这个工具提供的page覆盖率还不够高，还有劳各位去发pull request。</p>
<p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p>
<h2 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h2><p>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm install -g tldr</span></span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tldr aria2c</span></span><br></pre></td></tr></table></figure></p>
<p>Done!</p>
<p>最后提一下，时间充裕时还是尽量去阅读完整版的man page！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/23/tldr-man-page/" data-id="cjdiq02u2001j2c2hw9z1ym9r" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/23/tldr-man-page/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-use-xposed-to-crawl-wechat-moments" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/22/use-xposed-to-crawl-wechat-moments/" class="article-date">
  <time datetime="2016-01-22T15:38:02.000Z" itemprop="datePublished">2016-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/安卓/">安卓</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/22/use-xposed-to-crawl-wechat-moments/">用Xposed框架抓取微信朋友圈数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因微信朋友圈为私有协议，从抓包上分析朋友圈数据几乎不可能，目前也尚未找到开源的抓取朋友圈的脚本。博主于是尝试通过使用安卓下的Xposed框架实现从微信安卓版上抓取朋友圈数据。<br>本文针对微信版本6.3.8。<br><a href="https://github.com/Chion82/WeChatMomentExport" target="_blank" rel="noopener">GitHub仓库</a></p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>从UI获取文本信息是最为简单的方法，于是应该优先逆向UI代码部分。</p>
<h2 id="逆向微信apk"><a href="#逆向微信apk" class="headerlink" title="逆向微信apk"></a>逆向微信apk</h2><p>首先解包微信apk，用dex2jar反编译classes.dex，然后用JD-GUI查看jar源码。<br>当然，能看到的源码都是经过高度混淆的。但是，继承自安卓重要组件（如Activity、Service等）的类名无法被混淆，于是还是能从中看到点东西。</p>
<ol>
<li>首先定位到微信APP package。我们知道这个是<code>com.tencent.mm</code>。</li>
<li>在<code>com.tencent.mm</code>中，我们找到一个<code>ui</code>包，有点意思。</li>
<li>展开<code>com.tencent.mm.ui</code>，发现多个未被混淆的类，其中发现<code>MMBaseActivity</code>直接继承自<code>Activity</code>，<code>MMFragmentActivity</code>继承自<code>ActionBarActivity</code>，<code>MMActivity</code>继承自<code>MMFragmentActivity</code>，并且<code>MMActivity</code>是微信中大多数Activity的父类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMFragmentActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ActionBarActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SwipeBackLayout</span>.<span class="title">a</span>, <span class="title">b</span>.<span class="title">a</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MMActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MMFragmentActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMBaseActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在需要找出朋友圈的Activity，为此要用Xposed hook<code>MMActivity</code>。</p>
<h2 id="创建一个Xposed模块"><a href="#创建一个Xposed模块" class="headerlink" title="创建一个Xposed模块"></a>创建一个Xposed模块</h2><p>参考<a href="http://forum.xda-developers.com/showthread.php?t=2709324" target="_blank" rel="noopener">[TUTORIAL]Xposed module devlopment</a>，创建一个Xposed项目。<br>简单Xposed模块的基本思想是：hook某个APP中的某个方法，从而达到读写数据的目的。<br>小编尝试hook<code>com.tencent.mm.ui.MMActivity.setContentView</code>这个方法，并打印出这个Activity下的全部TextView内容。那么首先需要遍历这个Activity下的所有TextView，遍历ViewGroup的方法参考了SO的以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAllTextViews</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (v <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">       ViewGroup vg = (ViewGroup) v;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vg.getChildCount(); i++) &#123;</span><br><span class="line">           View child = vg.getChildAt(i);</span><br><span class="line">           getAllTextViews(child);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> TextView ) &#123;</span><br><span class="line">       dealWithTextView((TextView)v); <span class="comment">//dealWithTextView(TextView tv)方法：打印TextView中的显示文本</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Hook<code>MMActivity.setContentView</code>的关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(<span class="string">"com.tencent.mm.ui.MMActivity"</span>, lpparam.classLoader, <span class="string">"setContentView"</span>, View.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在findAndHookMethod方法中，第一个参数为完整类名，第三个参数为需要hook的方法名，其后若干个参数分别对应该方法的各形参类型。在这里，<code>Activity.setContentView(View view)</code>方法只有一个类型为<code>View</code>的形参，因此传入一个<code>View.class</code>。<br>现在，期望的结果是运行时可以从Log中读取到每个Activity中的所有的TextView的显示内容。<br><strong>但是，因为View中的数据并不一定在<code>setContentView()</code>时就加载完毕，因此小编的实验结果是，log中啥都没有。</strong></p>
<h2 id="意外的收获"><a href="#意外的收获" class="headerlink" title="意外的收获"></a>意外的收获</h2><p>当切换到朋友圈页面时，Xposed模块报了一个异常，异常源从<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI</code>这个类捕捉到。从类名上看，这个很有可能是朋友圈首页的UI类。展开这个类，发现更多有趣的东西：<br>这个类下有个子类<code>a</code>(被混淆过的类名)，该子类下有个名为<code>gyO</code>的<code>ListView</code>类的实例。我们知道，<code>ListView</code>是显示列表类的UI组件，有可能就是用来展示朋友圈的列表。</p>
<h2 id="顺藤摸瓜"><a href="#顺藤摸瓜" class="headerlink" title="顺藤摸瓜"></a>顺藤摸瓜</h2><p>那么，我们先要获得一个<code>SnsTimeLineUI.a.gyO</code>的实例。但是在这之前，要先获得一个<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI.a</code>的实例。继续搜索，发现<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI</code>有一个名为<code>gLZ</code>的<code>SnsTimeLineUI.a</code>实例，那么我们先取得这个实例。</p>
<p>经过测试，<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI.a(boolean, boolean, String, boolean)</code>这个方法在每次初始化微信界面的时候都会被调用。因此我们将hook这个方法，并从中取得<code>gLZ</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(<span class="string">"com.tencent.mm.plugin.sns.ui.SnsTimeLineUI"</span>, lpparam.classLoader, <span class="string">"a"</span>, <span class="keyword">boolean</span>.class, <span class="keyword">boolean</span>.class, String.class, <span class="keyword">boolean</span>.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"Hooked. "</span>);</span><br><span class="line">        Object currentObject = param.thisObject;</span><br><span class="line">        <span class="keyword">for</span> (Field field : currentObject.getClass().getDeclaredFields()) &#123; <span class="comment">//遍历类成员</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object value = field.get(currentObject);</span><br><span class="line">            <span class="keyword">if</span> (field.getName().equals(<span class="string">"gLZ"</span>)) &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">"Child A found."</span>);</span><br><span class="line">                childA = value;</span><br><span class="line">                <span class="comment">//这里获得了gLZ</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在取得了<code>SnsTimeLineUI.a</code>的一个实例<code>gLZ</code>，需要取得这个类下的<code>ListView</code>类型的<code>gyO</code>属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithA</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (childA == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Field field : childA.getClass().getDeclaredFields()) &#123; <span class="comment">//遍历属性</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object value = field.get(childA);</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">"gyO"</span>)) &#123;  <span class="comment">//取得了gyO</span></span><br><span class="line">            ViewGroup vg = (ListView)value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vg.getChildCount(); i++) &#123;  <span class="comment">//遍历这个ListView的每一个子View</span></span><br><span class="line">                ...</span><br><span class="line">                View child = vg.getChildAt(i);</span><br><span class="line">                getAllTextViews(child); <span class="comment">//这里调用上文的getAllTextViews()方法，每一个子View里的所有TextView的文本</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在已经可以将朋友圈页面中的全部文字信息打印出来了。我们需要根据TextView的子类名判断这些文字是朋友圈内容、好友昵称、点赞或评论等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithTextView</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">        String className = v.getClass().getName();</span><br><span class="line">        String text = ((TextView)v).getText().toString().trim().replaceAll(<span class="string">"\n"</span>, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (!v.isShown())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (text.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.AsyncTextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//好友昵称</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.SnsTextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//朋友圈文字内容</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.MaskTextView"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!text.contains(<span class="string">":"</span>)) &#123;</span><br><span class="line">                <span class="comment">//点赞</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//评论</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>自此，我们已经从微信APP里取得了朋友圈数据。当然，这部分抓取代码需要定时执行。因为从<code>ListView</code>中抓到的数据只有当前显示在屏幕上的可见部分，为此需要每隔很短一段时间再次执行，让用户在下滑加载的过程中抓取更多数据。<br>剩下的就是数据分类处理和格式化输出到文件，受本文篇幅所限不再赘述，详细实现可参考作者GitHub上的源码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/22/use-xposed-to-crawl-wechat-moments/" data-id="cjdiq02uj00252c2hydd0zdwn" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/22/use-xposed-to-crawl-wechat-moments/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hack/">hack</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-python2.7-on-centos6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/22/python2.7-on-centos6/" class="article-date">
  <time datetime="2016-01-21T18:11:53.000Z" itemprop="datePublished">2016-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/22/python2.7-on-centos6/">在CentOS6上编译安装Python2.7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考了友站的博文<a href="https://www.starduster.me/2016/01/04/py27-on-centos6/" target="_blank" rel="noopener">CentOS6上的Python2.7问题</a>，正如所言，在CentOS6上安装Python2.7是非常头疼的问题。友站的这篇博文阐述了如何了从源安装Python2.7，本站则讲述从源码编译安装要注意的问题。<br>编译依赖参考<a href="http://toomuchdata.com/2014/02/16/how-to-install-python-on-centos/" target="_blank" rel="noopener">How to install Python 2.7 and Python 3.3 on CentOS 6</a>。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><strong>十分重要:</strong> 编译Python2.7之前务必安装齐必须依赖。在configure过程中，若缺少依赖则不会报错，编译也可顺利通过，但编译出的Python将缺少几个必要模块，导致在运行<code>ez_setup.py</code>时出错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum groupinstall <span class="string">"Development tools"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span></span><br></pre></td></tr></table></figure>
<h2 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf Python-2.7.6.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Python-2.7.6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span> --<span class="built_in">enable</span>-unicode=ucs4 --<span class="built_in">enable</span>-shared LDFLAGS=<span class="string">"-Wl,-rpath /usr/local/lib"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make &amp;&amp; make altinstall</span></span><br></pre></td></tr></table></figure>
<p>这将会把Python2.7安装在<code>/usr/local/bin/python2.7</code></p>
<h2 id="将默认Python版本从2-6改为2-7"><a href="#将默认Python版本从2-6改为2-7" class="headerlink" title="将默认Python版本从2.6改为2.7"></a>将默认Python版本从2.6改为2.7</h2><p>首先将<code>/usr/bin/python</code>这个软链接指向刚刚安装的Python2.7<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm /usr/bin/python</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/bin/python2.7 /usr/bin/python</span></span><br></pre></td></tr></table></figure></p>
<p><strong>重要：</strong> 进行这步操作后，yum会失效，运行即报错。这是因为<code>/usr/bin/yum</code>其实是个python2.6脚本，刚刚安装的python2.7缺少yum的相关依赖。因此需要改动<code>/usr/bin/yum</code>的解释器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /usr/bin/yum</span></span><br></pre></td></tr></table></figure></p>
<p>将第一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2.6</span><br></pre></td></tr></table></figure></p>
<p>现在运行<code>yum --version</code>应该不会再报错</p>
<h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python ez_setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> easy_install-2.7 pip</span></span><br></pre></td></tr></table></figure>
<h2 id="替换默认pip为pip2-7"><a href="#替换默认pip为pip2-7" class="headerlink" title="替换默认pip为pip2.7"></a>替换默认pip为pip2.7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/bin/pip2.6 #第一行改为#!/usr/bin/python2.6</span><br><span class="line">$ which pip2.7  #应该返回/usr/local/bin/pip2.7</span><br><span class="line"># rm /usr/bin/pip</span><br><span class="line"># ln -s /usr/local/bin/pip2.7 /usr/bin/pip</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/22/python2.7-on-centos6/" data-id="cjdiq02u1001h2c2hsfbzstq7" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/22/python2.7-on-centos6/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-pixivhack-development-log" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/20/pixivhack-development-log/" class="article-date">
  <time datetime="2016-01-19T17:28:14.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/pixivhack-development-log/">PixivHack：记P站爬图脚本开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于7月学校考试，预习功课有点忙，最近又忙着做外包，一直都忘了维护博客，所以现在补上上个月本来应该写的技术博文。</p>
<h1 id="这是啥"><a href="#这是啥" class="headerlink" title="这是啥"></a>这是啥</h1><p>跟生活在2.5次元的老司机混久了便跟着入了ACG坑（看到本站首页LL大法时您应该意识到了，博主是个死宅<em>(:з」∠)</em> ）。P站找图是每一个ACG爱好者的必备技能，然而像我这种刚入坑不久的，收藏的画师才几个，再者没有钱买Premium，不能按人气选图，每次找图都要手动一页一页翻(╯‵□′)╯︵┻━┻ 于是我想用Py写个自动爬图脚本。这个脚本可以按你输入的关键词搜索作品，并根据Rating（评分次数，以此来判断作品人气）的最小值来筛选并自动下载，也可以手动指定画师ID列表，也是按照设定最小Rating的方法下载每个画师的图。目前支持下载插画、漫画和大图。</p>
<h1 id="你为什么还不用！"><a href="#你为什么还不用！" class="headerlink" title="你为什么还不用！"></a>你为什么还不用！</h1><p><a href="https://github.com/Chion82/PixivHack.git" target="_blank" rel="noopener">GitHub链接</a><br>使用方法详见README.md</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul>
<li>要从P站搜图首先要登录。我原来的设想是通过抓包直接用Py模拟登录，但是不出所料，P站的登录API参数都是经过加密的（貌似是基于RSA的），在不知加密算法的情况下无法实现。（虽然在另一个开源项目中我已经能够分析登录部分的JS加密逻辑，但在那之前我还是懒得审查JS）<br>于是目前的解决方案是要求用户在浏览器登录进P站一次，通过浏览器debugger获取Cookies中的PHPSESSID的值并输入到脚本中，脚本向P站发出的每次http请求都要带上该Cookie，目的是让P站服务器认为我们已经登录。<br>下面贴一行每次请求带上Cookie的代码  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_result = self.__session.get(<span class="string">'http://www.pixiv.net/search.php?word='</span> + urllib.quote(self.__keyword) + <span class="string">'&amp;p='</span> + str(page), cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>更好的方法：在requests的session中通过headers.update()方法在Header中设置Cookie，该session的每次请求都能自动带上该header，这样就不需要每次都在请求中加上cookies参数</strong></p>
<ul>
<li><p>从HTML源码中提取有用数据：虽然Python中可以使用HTMLParser更灵活地分析HTML，但是由于不想在这个小项目上浪费太多时间，我直接用正则从HTML中匹配。这里贴一行匹配作品搜索列表的代码：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_list = re.findall(<span class="string">r'&lt;a href="(/member_illust\.php\?mode=.*?&amp;amp;illust_id=.*?)"&gt;'</span>, search_result.text)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动脚本的流程是：获取作品搜索结果页面，从每个搜索结果分别进入作品首页，判断Rating是否高于设定的最小值（若低于则跳过该作品），判断作品类型（插画/漫画/大图）并根据不同的流程进入作品二级页面并获取原图的URL</p>
</li>
<li><p>绕过P站的防Bot机制：P站的原图不可直接下载。用户在浏览器中访问原图链接时，浏览器会自动加上Refer这个HTTP头，P站图片服务器会验证Refer是否合法。所以，脚本在访问原图链接并下载时，也需要在header中带上Refer。经过测试，Refer的值为作品首页或者作品二级页的URL。总之，在下载原图时带上当前页面（也就是HTML中能找到原图src的页面）的URL作为Refer就不会出问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download_result = self.__session.get(url, cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;, headers=&#123;<span class="string">'Referer'</span>:referer&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接失败处理：经过测试，在长时间连续爬图时很有可能会有一两次requests请求超时（不排除是天朝某墙的TCP RST所致，也有可能是requests2.0在同域下长时间保持单TCP连接使P站服务器拒绝所致），因此，requests每次发出http请求时，都应该用try…except捕获超时异常并重试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	page_result = self.__session.get(url, cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;, headers=&#123;<span class="string">'Referer'</span>:referer&#125;)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">	print(<span class="string">'Connection failure. Retrying...'</span>)</span><br><span class="line">	self.__enter_manga_big_page(url, referer, directory)</span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>统计画师总评分数：按关键词爬完一波图后，需要统计所爬的每个画师的ID、Rating等值，方便我们之后能收藏人气高的画师。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__increment_author_ratings</span><span class="params">(self, author_id, increment, pixiv_id)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> author <span class="keyword">in</span> self.__author_ratings:</span><br><span class="line">		<span class="keyword">if</span> (author[<span class="string">'author_id'</span>] == author_id):</span><br><span class="line">			<span class="keyword">if</span> (pixiv_id <span class="keyword">in</span> author[<span class="string">'illust_id'</span>]):</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			author[<span class="string">'total_ratings'</span>] = author[<span class="string">'total_ratings'</span>] + increment</span><br><span class="line">			author[<span class="string">'illust_id'</span>].append(pixiv_id)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">	self.__author_ratings.append(&#123;<span class="string">'author_id'</span>:author_id, <span class="string">'total_ratings'</span>:increment, <span class="string">'illust_id'</span>:[pixiv_id]&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户交互：用argparse实现CLI参数传入分析。在本脚本中，通过”-a”或”–authorlist”参数指定存储了画师ID列表的JSON文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, <span class="string">'--authorlist'</span>, help=<span class="string">'Crawl illustrations by author IDs. A JSON file containg the list of Pixiv member IDs is required.'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/20/pixivhack-development-log/" data-id="cjdiq02tz001c2c2hv0q8cyc7" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/20/pixivhack-development-log/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/crawler/">crawler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-Using-Gulp-to-Simplify-Front-end-Development-Workflow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/" class="article-date">
  <time datetime="2016-01-19T17:20:18.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/">Using Gulp to Simplify Front end Development Workflow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="What-is-Gulp"><a href="#What-is-Gulp" class="headerlink" title="What is Gulp"></a>What is Gulp</h1><p>Gulp is a streaming build system which is usually used to simplify front-end development workflow, such as automatically minifying JavaScript or compiling LESS. In this tutorial, you’ll learn the basic usage of Gulp.</p>
<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>To make sure you’ll have fun following my instructions, I assume you:</p>
<ul>
<li>have node.js &amp; npm installed</li>
<li>have basic knowledge of node.js scripting.</li>
</ul>
<h1 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h1><p>Let’s start with the installation of Gulp.<br>Run the following command in your shell terminal. The installation requires sudo or root previlege and you may be required to enter the password.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install --global gulp</span><br></pre></td></tr></table></figure></p>
<h1 id="Project-Setup"><a href="#Project-Setup" class="headerlink" title="Project Setup"></a>Project Setup</h1><p><code>cd</code> into the root directory of your project and run the following command, which will save the Gulp dependencies in your project directory.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>
<h1 id="Create-gulpfile-js"><a href="#Create-gulpfile-js" class="headerlink" title="Create gulpfile.js"></a>Create gulpfile.js</h1><p>At the root of your project, create a <code>gulpfile.js</code> containing the following code.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'mytask'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> 	<span class="comment">//All task code places here  </span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The code above defines a gulp task named “mytask” with the detailed commands defined in the callback function as the second parameter passed to the <code>gulp.task()</code> method. When running this task, <code>console.log(&#39;Hello World!&#39;);</code> will be executed.</p>
<h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>Now you should be able to run <code>mytask</code> using the following command:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp mytask</span><br></pre></td></tr></table></figure></p>
<p>Assume the root directory of your project is <code>~/project</code>, the output should be like:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  project  gulp mytask</span><br><span class="line">[21:14:25] Using gulpfile ~/project/gulpfile.js</span><br><span class="line">[21:14:25] Starting <span class="string">'mytask'</span>...</span><br><span class="line">Hello World!</span><br><span class="line">[21:14:25] Finished <span class="string">'mytask'</span> after 62 μs</span><br></pre></td></tr></table></figure></p>
<p>You can always run specific tasks by executing <code>gulp &lt;task&gt; &lt;other_task&gt;</code></p>
<h1 id="Basic-File-Streaming"><a href="#Basic-File-Streaming" class="headerlink" title="Basic File Streaming"></a>Basic File Streaming</h1><p>In this section we’ll use Gulp’s streaming system which is its primary function.<br>We will use <code>Gulp.src()</code>, <code>Gulp.dest()</code>, <code>readable.pipe()</code> to implement a basic JavaScript source file copying program using Gulp.<br>For detailed API doc of the methods above, please refer to <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">Gulp API doc</a> and <a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options" target="_blank" rel="noopener">Node.js:Stream</a>.  </p>
<ul>
<li>Create a directory named <code>js</code> at the root of your project (Assume you created this directory: <code>~/project/js</code>) and place some JavaScript files in it.  </li>
<li><p>Add the following code at the end of <code>gulpfile.js</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'copyjs'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">           .pipe(gulp.dest(<span class="string">'dest'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>At the root of the project which is <code>~/project</code>, run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp copyjs</span><br></pre></td></tr></table></figure>
</li>
<li><p>Check out <code>~/project/dest</code> to which you’ll find all js files in <code>~/project/js</code> are copied.</p>
</li>
</ul>
<h1 id="Using-Gulp-to-Minify-JS"><a href="#Using-Gulp-to-Minify-JS" class="headerlink" title="Using Gulp to Minify JS"></a>Using Gulp to Minify JS</h1><p>Next we’ll use Gulp to do some amazing tasks which bring great convenience for front-end development.<br>Let’s start with JavaScript minifying.<br>To make Gulp powerful enouth to do this job, we must install some plugins of Gulp. Here we’ll use <strong>gulp-uglify</strong>.(For more amazing gulp plugins, check out <a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">Gulp Plugins</a>)  </p>
<ul>
<li><p>Back to <code>~/project</code>, run the following command to install <strong>gulp-uglify</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp-uglify</span><br></pre></td></tr></table></figure>
</li>
<li><p>Replace <code>gulpfile.js</code> with the following code.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'minifyjs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.src(<span class="string">'js/*.js'</span>)	<span class="comment">//Get the stream of the source file</span></span><br><span class="line">                .pipe(uglify())<span class="comment">//Pass the stream to the uglify module to minify all JS files.</span></span><br><span class="line">                .pipe(gulp.dest(<span class="string">'build'</span>));<span class="comment">//Pass the stream to the destination directory which is ~/project/build</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Exucute the task by running:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp minifyjs</span><br></pre></td></tr></table></figure>
</li>
<li><p>Check out <code>~/project/build</code>. All minified JavaScript source files are placed here!</p>
</li>
</ul>
<h1 id="Using-Gulp-watch"><a href="#Using-Gulp-watch" class="headerlink" title="Using Gulp.watch()"></a>Using Gulp.watch()</h1><p>Sometimes we want the JS files to be automatically minified everytime we modify them and <code>Gulp.watch()</code> will do the trick.<br><code>Gulp.watch()</code> allows us to implement a daemon to monitor file modifications and automatically execute specific tasks every time the modifications are made.  </p>
<ul>
<li><p>Add the following code at the end of <code>gulpfile.js</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'watchjs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.watch(<span class="string">'js/*.js'</span>,[<span class="string">'minifyjs'</span>]);	<span class="comment">//Watch all *.js files under ~/project/js directory and run task "minifyjs" when files are modified</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Execute the daemon task by running:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp watchjs</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now, JS files will be automatically minified every time you modify them.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/" data-id="cjdiq02rk00032c2hd8upyv72" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-Project-Conclusion-of-m-21dianping-com" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/20/Project-Conclusion-of-m-21dianping-com/" class="article-date">
  <time datetime="2016-01-19T17:13:39.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/项目总结/">项目总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/Project-Conclusion-of-m-21dianping-com/">Project Conclusion of m.21dianping.com</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="About-This-Project"><a href="#About-This-Project" class="headerlink" title="About This Project"></a>About This Project</h1><p>The project is a commercial website where users share their experiences of renting houses.<br>I accepted this outsourced project in late April and finished in about 15 days.<br>The project required 2 developers including a front-end engineer and a back-end developer(me).</p>
<blockquote><p><strong>Tasks</strong>: development of the full site, deployment on server, maintainance for 3 months<br><strong>Profits</strong>: 4500 RMB in total, 3000 for back-end developer &amp; maintainer (me), 1500 for front-end engineer.</p>
</blockquote>
<h1 id="Technical-Info"><a href="#Technical-Info" class="headerlink" title="Technical Info"></a>Technical Info</h1><blockquote><p><strong>Back-end Language &amp; Framework</strong>: Python, Flask<br><strong>Database</strong>: MongoDB with mongoengine as ORM python engine<br><strong>Front-end Frameworks</strong>: Bootstrap(UI), Angular.JS(MVVM data-binding)<br><strong>Front-back Interaction Method</strong>: REST API<br><strong>Login Method</strong>: Only OAuth, logging in with Sina Weibo account or QQ account<br><strong>Production Environment</strong>: Nginx + uwsgi<br><strong>About Server</strong>: Ali Cloud, Ubuntu 14.04</p>
</blockquote>
<h1 id="What-I’ve-Done"><a href="#What-I’ve-Done" class="headerlink" title="What I’ve Done"></a>What I’ve Done</h1><ul>
<li>Back-end development</li>
<li>Significant modification of front-end code, including interaction with back-end using AJAX &amp; REST API calls (The front-end developer was really a rookie so I had to do much front-end stuff to fill his void. In fact he did nothing but wrote some static HTML &amp; CSS.)</li>
<li>Server-side production environment set-up</li>
</ul>
<h1 id="What-I’m-Doing"><a href="#What-I’m-Doing" class="headerlink" title="What I’m Doing"></a>What I’m Doing</h1><ul>
<li>Adding source code comments</li>
<li>Working on maintainance documentation</li>
<li>Website &amp; server maintainance</li>
</ul>
<h1 id="What-I’ve-learned"><a href="#What-I’ve-learned" class="headerlink" title="What I’ve learned"></a>What I’ve learned</h1><ul>
<li>Further understanding of Flask</li>
<li>Bootstrap</li>
<li>Front-end MVVM model using Angular.JS</li>
<li>Production environment setup with nginx+uwsgi</li>
</ul>
<h1 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h1><p>Search algorithm in back-end source needs to be improved. Current solution of house-info searching is to traverse all records in database and calculate match-weight for each row. However when the number of records grows there may be significant performance issues.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/01/20/Project-Conclusion-of-m-21dianping-com/" data-id="cjdiq02re00022c2hpvts1130" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/01/20/Project-Conclusion-of-m-21dianping-com/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/project/">project</a></li></ul>

    </footer>
  </div>
  
</article>





  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OSX/">OSX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/">开发笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/网络/">网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/逆向/">逆向</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSX/">OSX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/front-end/">front-end</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/OSX/" style="font-size: 11.67px;">OSX</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/android/" style="font-size: 13.33px;">android</a> <a href="/tags/backend/" style="font-size: 11.67px;">backend</a> <a href="/tags/crawler/" style="font-size: 11.67px;">crawler</a> <a href="/tags/front-end/" style="font-size: 18.33px;">front-end</a> <a href="/tags/hack/" style="font-size: 13.33px;">hack</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/maintenance/" style="font-size: 18.33px;">maintenance</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/nginx/" style="font-size: 11.67px;">nginx</a> <a href="/tags/openwrt/" style="font-size: 16.67px;">openwrt</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 11.67px;">python</a> <a href="/tags/router/" style="font-size: 15px;">router</a> <a href="/tags/wechat/" style="font-size: 11.67px;">wechat</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近发表</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/09/full-cone-nat-with-linux/">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a>
          </li>
        
          <li>
            <a href="/2017/04/06/kcptun-with-fake-tcp/">kcptun-raw：应对UDP QoS，重新实现kcptun的一次尝试</a>
          </li>
        
          <li>
            <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
          </li>
        
          <li>
            <a href="/2016/12/12/better-way-to-bypass-gfw-with-tinc/">tinc VPN+策略路由：Linux下更好的科学上网方式</a>
          </li>
        
          <li>
            <a href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
  <h3 class="widget-title">友链</h3>
  <div class="widget">
    <a href="https://www.starduster.me" target="_blank">星尘独奏曲</a><br />
    <a href="http://www.zhouchao.me" target="_blank">chao's blog</a><br />
    <a href="http://ilazycat.com" target="_blank">小黑猫菊苣的猫窝</a><br />
    <a href="https://loli.be" target="_blank">Mashiro's Blog</a><br />
    <a href="https://bismarck.moe" target="_blank">雨宫千鹤的博客</a><br />
    <a href="https://blessing.studio" target="_blank">Blessing Studio</a><br />
    <a href="https://wwww.lvmoo.com" target="_blank">凯の秘密基地</a><br />
    <a href="https://apporz.com" target="_blank">Micooz's Personal Site</a>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chion Tang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, themed &amp; customized by Chion
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/Chion82" class="mobile-nav-link">GitHub</a>
  
    <a href="/about.html" class="mobile-nav-link">About Me</a>
  
</nav>
    
<script>
  var disqus_shortname = 'chionlab';
  if (/*window.location.hostname.indexOf('cn2') === -1*/true) {
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
  } else {
    var disqusElements = document.querySelectorAll('.disqus-comments-section, .disqus-comment-link');
    for (var i=0; i<disqusElements.length; i++) {
      disqusElements[i].style.display = 'none';
    }
  }
</script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>