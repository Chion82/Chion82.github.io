<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ChionLab | 一个萌豚开发者的窝 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="ChionLab">
<meta property="og:url" content="https://blog.chionlab.moe/index.html">
<meta property="og:site_name" content="ChionLab">
<meta property="og:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChionLab">
<meta name="twitter:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="ChionLab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
  
  <link href="/stylesheets/googlefonts.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    .article-duoshuo-link {
      float: right;
      margin-left: 20px;
    }
    .article-duoshuo-link:before {
      content: "\f086";
      font-family: "FontAwesome";
      padding-right: 8px;
    }
    .jc-bs3-container {
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <link href="/stylesheets/jquery-confirm.min.css" rel="stylesheet" type="text/css">
  <script src="/scripts/jquery-2.2.0.min.js"></script>
  <script src="/scripts/jquery-confirm.min.js"></script>
  <!--
  
    <script>
      var yunModuleEnv = true;
    </script>
    <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
  
  -->

  
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script>
    var JS_COOKIES_DOMAIN = '.chionlab.moe';
    var JsCookies = {
      // this gets a cookie and returns the cookies value, if no cookies it returns blank ""
      get: function(c_name) {
        if (document.cookie.length > 0) {
          var c_start = document.cookie.indexOf(c_name + "=");
          if (c_start != -1) {
            c_start = c_start + c_name.length + 1;
            var c_end = document.cookie.indexOf(";", c_start);
            if (c_end == -1) {
              c_end = document.cookie.length;
            }
            return unescape(document.cookie.substring(c_start, c_end));
          }
        }
        return "";
      },

      // this sets a cookie with your given ("cookie name", "cookie value", "good for x days")
      set: function(c_name, value, expiredays) {
        var exdate = new Date();
        if (expiredays)
          exdate.setDate(exdate.getDate() + expiredays);
        document.cookie = c_name + "=" + escape(value) + "; path=/" + "; domain=" + JS_COOKIES_DOMAIN + ((expiredays == undefined) ? "" : "; expires=" + exdate.toUTCString());
      },

      // this checks to see if a cookie exists, then returns true or false
      check: function(c_name) {
        c_name = JsCookies.get(c_name);
        if (c_name != null && c_name != "") {
          return true;
        } else {
          return false;
        }
      }

    };
  </script>

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChionLab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎来到Chion82的未来道具研究所 ( ゜- ゜)つロ 乾杯~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="https://github.com/Chion82">GitHub</a>
        
          <a class="main-nav-link" href="/about.html">About Me</a>
        
        <!-- <a class="main-nav-link nav-link-switch-cdn" href="//cn2.chionlab.moe" data-domain="cn2">CN2加速</a>
        <a class="main-nav-link nav-link-switch-cdn" href="//blog.chionlab.moe" data-domain="blog">CF加速</a> -->

        
          <div style="clear: both;"></div>
          <style>
            .switch-theme-btn {
              opacity: 0.8 !important;
            }

            .switch-theme-btn:hover {
              opacity: 1.0 !important;
            }
          </style>
          <div>
            <!--
              
                <a class="main-nav-link switch-theme-btn"
                  title="uzume" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/css/style.css"
                  data-theme-name="uzume">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_uzume.png" />
                  </div>
                </a>
              
                <a class="main-nav-link switch-theme-btn"
                  title="miria" href="#" style="float: left;margin-right: -10px;"
                  data-css-url="/stylesheets/theme_miria.css"
                  data-theme-name="miria">
                  <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                    <img style="width: 100%; height: 100%;" src="/images/theme_miria.png" />
                  </div>
                </a>
              
            -->
          </div>
          <script>
            // (function(){
            //
            //   function switchThemeCSS(themeName, cssUrl) {
            //     document.querySelector('head').querySelectorAll('link[rel=stylesheet]')[1].href = cssUrl;
            //   }
            //
            //   var switchThemeBtns = document.querySelectorAll('.switch-theme-btn');
            //   for (var i=0; i<switchThemeBtns.length; i++) {
            //     var switchThemeBtn = switchThemeBtns[i];
            //     (function(switchThemeBtn) {
            //       switchThemeBtn.addEventListener('click', function(){
            //         switchThemeCSS(switchThemeBtn.dataset.themeName, switchThemeBtn.dataset.cssUrl);
            //         JsCookies.set('theme', switchThemeBtn.dataset.themeName, 30);
            //       });
            //     })(switchThemeBtn);
            //   }
            //
            //   var initTheme = JsCookies.get('theme');
            //   if (initTheme) {
            //     var cssUrl = document.querySelector(".switch-theme-btn[data-theme-name='" + initTheme + "']").dataset.cssUrl;
            //     switchThemeCSS(initTheme, cssUrl);
            //   }
            //
            // })();
          </script>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.chionlab.moe"></form>
      </div>
    </div>
  </div>
  <script>
    // function getGeolocation(geoInfo) {
    //   var rootDomain = 'chionlab.moe';
    //   if (geoInfo.country_code === 'CN') {
    //     if (window.location.hostname === 'cn2' + '.' + rootDomain) {
    //       JsCookies.set('domain', 'cn2', 30);
    //       return;
    //     }
    //     $.confirm({
    //       title: '线路优化建议',
    //       content: '检测到您是境内用户，为了提高您的访问体验，是否切换到CN2线路？',
    //       buttons: {
    //         '好的': function() {
    //           JsCookies.set('domain', 'cn2', 30);
    //           window.location.href = '//' + 'cn2' + '.' + rootDomain + window.location.pathname;
    //         },
    //         '不用了': function() {
    //           JsCookies.set('domain', 'blog', 30);
    //         }
    //       }
    //     })
    //   } else {
    //     JsCookies.set('domain', 'blog', 30);
    //     if ('blog' + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + 'blog' + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    // }
    // (function(){
    //   var rootDomain = 'chionlab.moe';
    //
    //   if (!JsCookies.check('domain')) {
    //     var geoLocationScript = document.createElement('script');
    //     geoLocationScript.setAttribute('src','//freegeoip.net/json/?callback=getGeolocation');
    //     document.head.appendChild(geoLocationScript);
    //   } else {
    //     if (JsCookies.get('domain') + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
    //       window.location.href = '//' + JsCookies.get('domain') + '.' + rootDomain + window.location.pathname;
    //     }
    //   }
    //
    //   var switchBtns = document.querySelectorAll('.nav-link-switch-cdn');
    //   for (var i=0; i<switchBtns.length; i++) {
    //     (function(switchBtn){
    //       if (switchBtn.dataset.domain === JsCookies.get('domain')) {
    //         switchBtn.style.display = 'none';
    //       }
    //       switchBtn.addEventListener('click', function(ev) {
    //         JsCookies.set('domain', switchBtn.dataset.domain);
    //       });
    //     })(switchBtns[i]);
    //   }
    // })();
  </script>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-full-cone-nat-with-linux-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/full-cone-nat-with-linux-2/" class="article-date">
  <time datetime="2018-03-31T07:44:29.000Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/full-cone-nat-with-linux-2/">Linux 内核态实现 Full Cone NAT（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>接上篇 <a href="/2018/02/09/full-cone-nat-with-linux/">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a> 。</p>
</blockquote>
<h2 id="Padavan固件的Cone-NAT实现"><a href="#Padavan固件的Cone-NAT实现" class="headerlink" title="Padavan固件的Cone NAT实现"></a>Padavan固件的Cone NAT实现</h2><p><a href="https://bitbucket.org/padavan/rt-n56u" target="_blank" rel="noopener">Padavan</a> 是基于华硕路由器固件的第三方家用路由器固件，这个固件通过给内核netfilter打patch的方式实现了Cone NAT。关于该固件实现Cone NAT的原理及问题，在 <a href="https://github.com/Chion82/netfilter-full-cone-nat/issues/1" target="_blank" rel="noopener">netfilter-full-cone-nat #1</a> 中有简短的讨论。</p>
<p>先来看代码。Padavan修改了netfilter下的 nf_conntrack_core.c 中的 <code>resolve_normal_ct()</code> 函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *</span></span><br><span class="line"><span class="class"><span class="title">resolve_normal_ct</span>(/* ... */)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">/* look for tuple match */</span></span><br><span class="line">  hash = hash_conntrack_raw(&amp;tuple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NAT_CONE)</span></span><br><span class="line">  <span class="keyword">if</span> (protonum == IPPROTO_UDP &amp;&amp; nf_conntrack_nat_mode &gt; <span class="number">0</span> &amp;&amp; skb-&gt;dev != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">  #<span class="keyword">if</span> IS_ENABLED(CONFIG_PPP)</span><br><span class="line">      (skb-&gt;dev-&gt;ifindex == cone_man_ifindex || skb-&gt;dev-&gt;ifindex == cone_ppp_ifindex)) &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      (skb-&gt;dev-&gt;ifindex == cone_man_ifindex)) &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* CASE III To Cone NAT */</span></span><br><span class="line">    h = __nf_cone_conntrack_find_get(net, &amp;tuple, hash);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* CASE I.II.IV To Linux NAT */</span></span><br><span class="line">    h = __nf_conntrack_find_get(net, &amp;tuple, hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，在配置项 <code>CONFIG_NAT_CONE</code> 打开时，调用了 <code>__nf_cone_conntrack_find_get()</code> 来取代原本的 <code>__nf_conntrack_find_get()</code>。来看看这个padavan新增的 <code>__nf_cone_conntrack_find_get()</code> 函数是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *</span></span><br><span class="line"><span class="class">__<span class="title">nf_cone_conntrack_find_get</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_tuple</span> *<span class="title">tuple</span>, <span class="title">u32</span> <span class="title">hash</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">begin:</span><br><span class="line">  h = __nf_cone_conntrack_find(net, tuple, hash);</span><br><span class="line">  <span class="keyword">if</span> (h) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (unlikely(!nf_ct_cone_tuple_equal(tuple, &amp;h-&gt;tuple))) &#123;</span><br><span class="line">          nf_ct_put(ct);</span><br><span class="line">          <span class="keyword">goto</span> begin;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这个函数的实现和 <code>__nf_conntrack_find_get()</code> 逻辑上完全一致，所以我省略了大部分的展示代码。其实特别的地方在于，这个函数通过调用新增的 <code>__nf_cone_conntrack_find()</code> 来根据tuple查找对应的conntrack，通过调用 <code>nf_ct_cone_tuple_equal()</code> 来判断两个tuple是否相等。这两个padavan添加的函数就暗藏了玄机。事实上，<code>__nf_cone_conntrack_find()</code>的实现与 <code>____nf_conntrack_find()</code> 逻辑上也没有多大不同，而区别就在于：在根据hash遍历索引到的bucket时，<code>____nf_conntrack_find()</code> 使用 <code>nf_ct_key_equal()</code> 来判断两个tuple是否完全相等，而 <code>__nf_cone_conntrack_find()</code> 则使用了 <code>nf_ct_cone_tuple_equal()</code> 来判断两个tuple是否“在锥形”上相等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">nf_ct_cone_tuple_equal(<span class="keyword">const</span> struct nf_conntrack_tuple *t1, <span class="keyword">const</span> struct nf_conntrack_tuple *t2) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nf_conntrack_nat_mode == NAT_MODE_FCONE)</span><br><span class="line">    <span class="keyword">return</span> __nf_ct_tuple_dst_equal(t1, t2);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nf_conntrack_nat_mode == NAT_MODE_RCONE)</span><br><span class="line">    <span class="keyword">return</span> (__nf_ct_tuple_dst_equal(t1, t2) &amp;&amp;</span><br><span class="line">      nf_inet_addr_cmp(&amp;t1-&gt;src.u3, &amp;t2-&gt;src.u3)  &amp;&amp;</span><br><span class="line">      t1-&gt;src.l3num == t2-&gt;src.l3num);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码就是padavan对Cone NAT实现的最关键之处。对于 Full Cone，<code>nf_ct_cone_tuple_equal()</code> 只判断两个tuple的“目标三元组”（目标IP、目标端口、协议号）是否相同；对于 IP Restricted Cone，除了判断“目标三元组”是否相同，还需要同时判断源IP是否相同。注意，此处的tuple是相对于远程主机端，即 conntrack.tuple_hash 中的 <code>TUPLE_REPLY</code> 而言的，“源”指的是远程主机（如UDP服务器），“目标”指的是本机（Linux NAT网关）的 WAN 出口。</p>
<p>相对应的，由于 <code>resolve_normal_ct()</code> 对 conntrack 的查找是基于对 tuple 进行 hash 的，padavan 对 <code>hash_conntrack_raw()</code> 函数也做了少量的调整，来确保在同一锥形中的两个tuple的hash相同：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">hash_conntrack_raw</span><span class="params">(<span class="keyword">const</span> struct nf_conntrack_tuple *tuple)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NAT_CONE)</span></span><br><span class="line">  u32 a, b;</span><br><span class="line">  <span class="keyword">if</span> (nf_conntrack_nat_mode == NAT_MODE_FCONE) &#123;</span><br><span class="line">    <span class="keyword">return</span> jhash2(tuple-&gt;dst.u3.all, <span class="keyword">sizeof</span>(tuple-&gt;dst.u3.all) / <span class="keyword">sizeof</span>(u32),</span><br><span class="line">            nf_conntrack_hash_rnd ^ (((__force __u16)tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum)); <span class="comment">// dst ip &amp; dst port &amp; dst proto</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nf_conntrack_nat_mode == NAT_MODE_RCONE) &#123;</span><br><span class="line">    a = jhash2(tuple-&gt;src.u3.all, <span class="keyword">sizeof</span>(tuple-&gt;src.u3.all) / <span class="keyword">sizeof</span>(u32), tuple-&gt;src.l3num); <span class="comment">//src ip &amp; l3 proto</span></span><br><span class="line">    b = jhash2(tuple-&gt;dst.u3.all, <span class="keyword">sizeof</span>(tuple-&gt;dst.u3.all) / <span class="keyword">sizeof</span>(u32), ((__force __u16)tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum); <span class="comment">// dst ip &amp; dst port &amp; dst proto</span></span><br><span class="line">    <span class="keyword">return</span> jhash_2words(a, b, nf_conntrack_hash_rnd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，padavan对Cone NAT的实现是这样的：（为简化过程，我们这里只讲Full Cone）<br>当入站包到达本机（Linux NAT网关）时，<code>resolve_normal_ct()</code> 被调用以用于查找该包所对应的conntrack，原版netfilter的逻辑是根据tuple的“全匹配”来查找对应conntrack，而padavan在启用Cone NAT功能后，只根据tuple的“半匹配”来找到对应的conntrack（“半匹配”即：只匹配单边的地址和端口信息，当Full Cone时，这个单边是tuple的dst）。</p>
<p>举个例子来说明这样实际运行的效果：</p>
<ul>
<li>内网主机 192.168.1.3:3000  –&gt; Linux网关 NAT后地址：223.0.0.1:3000 （标记为“conntrack 1”）  –&gt; 远程主机 123.0.0.1:5000</li>
<li>另一台远程主机 123.2.2.2:6000 –&gt; 223.0.0.1:3000 Linux网关查找到“conntrack 1”并进行restore NAT –&gt; 内网主机 192.168.1.3:3000</li>
</ul>
<h2 id="映射端口随机化及问题"><a href="#映射端口随机化及问题" class="headerlink" title="映射端口随机化及问题"></a>映射端口随机化及问题</h2><p>这里我们讨论SNAT的 <code>--random</code> 或 <code>--random-fully</code> 参数。在未使用该参数时，NAT后的源端口号会尽量保持不变，如果遇到冲突，则从端口范围的最小值（未显式指定时是1024）开始逐一往上寻找可用源端口号；当使用了随机化参数后，NAT后的源端口号是随机的，每次NAT映射产生的端口号都无特别确定的规律可循。</p>
<h3 id="Padavan-Cone-NAT和端口随机化"><a href="#Padavan-Cone-NAT和端口随机化" class="headerlink" title="Padavan Cone NAT和端口随机化"></a>Padavan Cone NAT和端口随机化</h3><p>从上文的源码分析可以看出，padavan对cone nat的实现是仅考虑了入站方向的，而出站方向则没有做改动。如果我们同时考虑出站方向，当 <code>--random</code> 或 <code>--random-fully</code> 都 <strong>未启用</strong> 时，出入站的流程是这样的：</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:3000) 【建立 “conntrack 1” 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:3000)【重用 “conntrack 1” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:3000) 【建立 “conntrack 2” 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
</ul>
<p>注意，当 内网主机A 向另一台 远端主机C 发送出站UDP包时，会建立一个新的 “conntrack 2”，同时进行一次端口分配。由于未启用端口随机化，linux会尽量保持源端口不变，即再次映射成3000端口，这样就保证了这个锥形NAT是双向完整的。</p>
<p>但是如果我们使用了 <code>--random</code> 或 <code>--random-fully</code>，这个过程就变得有趣了：</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【建立 “conntrack 1” 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:36000)【重用 “conntrack 1” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:47000) 【建立 “conntrack 2” 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
</ul>
<p>在建立 “conntrack 2” 的时候，端口随机化导致NAT分配了一个与 “conntrack 1” 截然不同的端口号，如果 远端主机C 对此变动不知情（比如C在Symmetric NAT后面），仍然向 223.0.0.1:36000 发送UDP包，那么导致的结果是：只有A可以收到C发送的包，而C则收不到A发送的包。</p>
<p>这个过程可以简单地通过 <code>netcat</code> 命令模拟，通过显式输入对方的IP:PORT，并使用 <code>-p</code> 参数指定本地的监听端口。</p>
<h3 id="netfilter-full-cone-nat-对端口随机化的改进"><a href="#netfilter-full-cone-nat-对端口随机化的改进" class="headerlink" title="netfilter-full-cone-nat 对端口随机化的改进"></a>netfilter-full-cone-nat 对端口随机化的改进</h3><p>以下称 <a href="https://github.com/Chion82/netfilter-full-cone-nat" target="_blank" rel="noopener">netfilter-full-cone-nat</a> 为 xt_FULLCONENAT ，即此项目的内核模块名称。</p>
<p>与padavan的netfilter patch实现不同，xt_FULLCONENAT是一个第三方内核模块，没有修改conntrack核心部分的代码。padavan的原理是将一个入站packet关联至一个先前建立的conntrack；而xt_FULLCONENAT的原理是通过主动DNAT来还原入站映射。</p>
<p>当未使用 <code>--random</code> 或 <code>--random-fully</code> 时，xt_FULLCONENAT的表现是这样的：</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:3000) 【SNAT，建立 “conntrack 1” 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:3000)【DNAT，建立 “conntrack 2” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:3000) 【复用 “conntrack 2” 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
</ul>
<p>当使用了 <code>--random</code> 或 <code>--random-fully</code> 时，会变成这样：</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【SNAT，建立 “conntrack 1” 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:36000)【DNAT，建立 “conntrack 2” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【复用 “conntrack 2” 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
</ul>
<p>这样看上去很正常。但是，如果我们交换一下第二步和第三步，就会变成这样的结果：</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【SNAT，建立 “conntrack 1” 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:47000) 【SNAT，建立 “conntrack 2” 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:36000)【DNAT，建立 “conntrack 3” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
</ul>
<p>可以见到，如果C在向A发包之前，A先向C发了包，那么NAT会映射成一个新的端口，这就破坏了Cone NAT，同样会造成单边不通的问题。</p>
<p>为此，xt_FULLCONENAT 在最近的commit中改造了NAT映射机制：</p>
<ul>
<li>除了自动DNAT，SNAT的映射端口也在模块内加以限制，以保证出站端口号的一致性。</li>
<li>因为使用了Cone NAT后，WAN接口上的一个UDP端口号只能关联唯一的内网IP:PORT，默认的linux端口分配机制（即 <code>unique_tuple</code> ）不能保证这个关联的唯一性，因此我们要在模块内完成端口分配。</li>
</ul>
<p>现在，xt_FULLCONENAT 对出站包的处理逻辑如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注：这里的“映射”指本模块内的 natmapping 结构 */</span></span><br><span class="line"><span class="comment">/* 根据内网IP:PORT搜索已经存在的映射 */</span></span><br><span class="line">src_mapping = get_mapping_by_int_src(ip, original_port);</span><br><span class="line"><span class="keyword">if</span> (src_mapping != <span class="literal">NULL</span> &amp;&amp; check_mapping(src_mapping, net, zone)) &#123;</span><br><span class="line">  <span class="comment">/* 如果这个映射已经存在，就复用这个映射：将NAT端口号限制为该条映射所记录的外网端口号 */</span></span><br><span class="line">  newrange.flags = NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED;</span><br><span class="line">  newrange.min_proto.udp.port = cpu_to_be16(src_mapping-&gt;port);</span><br><span class="line">  newrange.max_proto = newrange.min_proto;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 如果未找到已存在的映射，则在本模块内进行端口分配，并创建新的映射 */</span></span><br><span class="line">  want_port = find_appropriate_port(net, zone, original_port, ifindex, range);</span><br><span class="line">  newrange.flags = NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED;</span><br><span class="line">  newrange.min_proto.udp.port = cpu_to_be16(want_port);</span><br><span class="line">  newrange.max_proto = newrange.min_proto;</span><br><span class="line">  src_mapping = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过本次改造，xt_FULLCONENAT已经完全兼容了端口随机化下的Cone NAT：当内网IP:PORT不变时，无论出入站顺序和远端地址，都将映射为相同的外网端口号.</p>
<ul>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【SNAT，建立 “conntrack 1”，随机分配出站端口 】 –&gt; 远端主机B(123.0.0.1:5000)</li>
<li>内网主机A(192.168.1.3:3000) –&gt; NAT(223.0.0.1:36000) 【SNAT，建立 “conntrack 2”，并复用 “conntrack 1”的出站端口 】 –&gt; 远端主机C(123.2.2.2:6000)</li>
<li>远端主机C(123.2.2.2:6000) –&gt; NAT(223.0.0.1:36000)【复用 “conntrack 2” 】 –&gt; 内网主机A(192.168.1.3:3000)</li>
</ul>
<h2 id="xt-FULLCONENAT更新日志：映射表老化问题"><a href="#xt-FULLCONENAT更新日志：映射表老化问题" class="headerlink" title="xt_FULLCONENAT更新日志：映射表老化问题"></a>xt_FULLCONENAT更新日志：映射表老化问题</h2><p>下面我们来关注 xt_FULLCONENAT 遗留的问题和更新的解决方案。<br>注：<em>映射项</em> 即 xt_FULLCONENAT 中 <code>struct natmapping</code> 所对应的结构。</p>
<h3 id="主动式映射项老化检测：CONNTRACK-EVENTS"><a href="#主动式映射项老化检测：CONNTRACK-EVENTS" class="headerlink" title="主动式映射项老化检测：CONNTRACK_EVENTS"></a>主动式映射项老化检测：CONNTRACK_EVENTS</h3><p>在上篇博文中，我提到：xt_FULLCONENAT 目前暂未能主动判断映射项失效，只能在需要用到该映射项的时候进行一次 <code>check_mapping()</code>，如果失效了就用新的映射替换之，以此十分被动的方法来避免映射表无限增长。</p>
<p>现在，我在 conntrack 核心代码中发现了在其 conntrack 回收函数 <code>gc_worker()</code> 中，在杀死 conntrack 时会触发一次 conntrack event，这让我想到了可以通过注册conntrack event回调来实现主动的映射项老化。</p>
<p>conntrack 事件回调的注册非常简单，在 <code>struct nf_ct_event_notifier</code> 结构体中定义一个回调函数，再通过调用 <code>nf_conntrack_register_notifier()</code> 即可在当前网络命名空间（network namespace）上注册一个事件回调。<br>接下来我们要做的，就是在回调函数中过滤掉除 <code>IPCT_DESTROY</code> 外的事件，获得对应的 conntrack 和 tuple ，并根据tuple的地址信息找到对应的映射项（但这时并不能立即删除映射项，后文会提到）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ct_event_cb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> events, struct nf_ct_event *item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ct = item-&gt;ct;</span><br><span class="line">  <span class="comment">/* we handle only conntrack destroy events */</span></span><br><span class="line">  <span class="keyword">if</span> (ct == <span class="literal">NULL</span> || !(events &amp; (<span class="number">1</span> &lt;&lt; IPCT_DESTROY))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* 这里我们不知道这个是出站conntrack（SNAT），还是入站conntrack（DNAT） </span></span><br><span class="line"><span class="comment">   * 因此需要做尝试：如果不是出站conntrack，则认为是入站conntrack */</span></span><br><span class="line">  ip = (ct_tuple-&gt;src).u3.ip;</span><br><span class="line">  port = be16_to_cpu((ct_tuple-&gt;src).u.udp.port);</span><br><span class="line">  mapping = get_mapping_by_int_src(ip, port);</span><br><span class="line">  <span class="keyword">if</span> (mapping == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ct_tuple = &amp;(ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line">    ip = (ct_tuple-&gt;src).u3.ip;</span><br><span class="line">    port = be16_to_cpu((ct_tuple-&gt;src).u.udp.port);</span><br><span class="line">    mapping = get_mapping_by_int_src(ip, port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果都还是找不到，那么认为该conntrack与本模块无关，不作处理 */</span></span><br><span class="line">  <span class="comment">/* 如果找到了，就做相应的回收处理 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注册conntrack事件回调，我们可以在精准的时机老化对应的映射项了。</p>
<p>不过，CONNTRACK_EVENTS 并不是 netfilter 中常用的 feature。在内核树中，只有 nf_conntrack_netlink 模块使用了它。<br>可能正由于此，conntrack notifier被设计成 <strong>在同一个network namespace中，同时只能有一个回调被注册</strong> ，能够注册的唯一的事件回调会保存在 <code>net-&gt;ct.nf_conntrack_event_cb</code> 。因此这造成了 <a href="https://github.com/Chion82/netfilter-full-cone-nat/issues/5" target="_blank" rel="noopener">issue #5</a> 的BUG：该模块不能与其他占用 CONNTRACK_EVENTS 的模块同时共用。linux内核树中占用 CONNTRACK_EVENTS 的模块只有 nf_conntrack_netlink ，用户态的 <code>conntrack</code> 命令（在  conntrack-tools 包中 ）依赖这个内核模块，该命令通常用于在用户态查询和更新 conntrack table 。</p>
<p>万幸的是，就算不注册conntrack事件回调，我们仍可以通过老方法，被动地防止映射表无限增长。由于我对映射项建立了双边索引（LAN端和WAN端），过长的映射表虽然会浪费较多的内存，但对索引表项的性能影响很小。</p>
<h3 id="映射项的引用计数及-GC-时机"><a href="#映射项的引用计数及-GC-时机" class="headerlink" title="映射项的引用计数及 GC 时机"></a>映射项的引用计数及 GC 时机</h3><p>这里有个地方要注意。上面提到的 CONNTRACK_EVENTS 是针对conntrack而言的，当 <code>IPCT_DESTROY</code> 触发时，认为该conntrack已超时失效。由于本模块中映射项是对Cone NAT而言的，一个映射项会对应多个conntracks。</p>
<p>在 xt_FULLCONENAT 原来的设计中，并没有考虑后来DNAT或SNAT所产生的对应同一个映射项的多个conntracks，对一个映射是否超时的判断，是基于第一个conntrack所对应的tuple <code>mapping-&gt;original_tuple</code> 的，因此，可能会造成这样的场景：</p>
<ul>
<li>内网主机A -&gt; SNAT -&gt; 外网主机B 【保存 original_tuple 到 mapping1】</li>
<li>外网主机C -&gt; DNAT -&gt; 内网主机A 【通过 mapping1 进行DNAT】</li>
<li>A与B的通信停止，A与C持续通信，持续5分钟</li>
<li><code>original_tuple</code> 被 conntrack_core 的 gc_worker() 回收</li>
<li>外网主机D -&gt; DNAT -&gt; 丢弃【对 mapping1 进行检查，<code>original_tuple</code>失效，删除 mapping1】</li>
</ul>
<p>为了解决这个问题，我引入了 <em>映射项引用计数</em> 的概念：当有 N 个 conntrack 与一个映射项关联时，该映射项的引用计数为 N 。<br>现在一个映射项的结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_mapping</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port;     <span class="comment">/* external UDP port */</span></span><br><span class="line">  <span class="keyword">int</span> ifindex;       <span class="comment">/* external interface index*/</span></span><br><span class="line">  __be32 int_addr;   <span class="comment">/* internal source ip address */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> int_port; <span class="comment">/* internal source port */</span></span><br><span class="line">  <span class="keyword">int</span> refer_count;   <span class="comment">/* how many references linked to this mapping</span></span><br><span class="line"><span class="comment">                      * aka. length of original_tuple_list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">original_tuple_list</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_by_ext_port</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_by_int_src</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每当一次SNAT或DNAT时，我们将所对应conntrack的 <code>ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple</code> 追加至 <code>original_tuple_list</code> 列表，并累加引用计数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_original_tuple_to_mapping</span><span class="params">(struct nat_mapping *mapping, <span class="keyword">const</span> struct nf_conntrack_tuple* original_tuple)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nat_mapping_original_tuple</span> *<span class="title">item</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">nat_mapping_original_tuple</span>), <span class="title">GFP_ATOMIC</span>);</span></span><br><span class="line">  <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pr_debug(<span class="string">"xt_FULLCONENAT: ERROR: kmalloc() for nat_mapping_original_tuple failed.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;item-&gt;tuple, original_tuple, <span class="keyword">sizeof</span>(struct nf_conntrack_tuple));</span><br><span class="line">  list_add(&amp;item-&gt;node, &amp;mapping-&gt;original_tuple_list);</span><br><span class="line">  (mapping-&gt;refer_count)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 conntrack 的 <code>IPCT_DESTROY</code> 事件触发，或需要 <code>check_mapping()</code> 时，我们从该映射项的 <code>original_tuple_list</code> 列表中删除该失效的 tuple，并将引用计数递减；当且仅当一个映射项的引用计数为零时，我们才杀掉这个映射项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ct_event_cb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> events, struct nf_ct_event *item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 接上文的 ct_event_cb()，这里已从conntrack获取到对应的mapping</span></span><br><span class="line">  <span class="comment">/* 遍历original_tuple_list，查找并清理失效的tuple */</span></span><br><span class="line">  list_for_each_safe(iter, tmp, &amp;mapping-&gt;original_tuple_list) &#123;</span><br><span class="line">    original_tuple_item = list_entry(iter, struct nat_mapping_original_tuple, node);</span><br><span class="line">    <span class="keyword">if</span> (nf_ct_tuple_equal(&amp;original_tuple_item-&gt;tuple, ct_tuple_origin)) &#123;</span><br><span class="line">      list_del(&amp;original_tuple_item-&gt;node);</span><br><span class="line">      kfree(original_tuple_item);</span><br><span class="line">      (mapping-&gt;refer_count)--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 当引用计数减至零时，杀死这个映射项 */</span></span><br><span class="line">  <span class="keyword">if</span> (mapping-&gt;refer_count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    kill_mapping(mapping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，xt_FULLCONENAT 的更新进入了新的阶段。</p>
<p>这里感谢 xd5520026 提出了各种冲突case及修改建议。<br>And many thanks to 4t0m1k for hacking into the kernel source which helped me figure out the <em>CONNTRACK_EVENTS</em> bug.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2018/03/31/full-cone-nat-with-linux-2/" data-id="cjh4y6u46000hz42hiqb2kmz5" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2018/03/31/full-cone-nat-with-linux-2/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-full-cone-nat-with-linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/09/full-cone-nat-with-linux/" class="article-date">
  <time datetime="2018-02-09T12:51:54.000Z" itemprop="datePublished">2018-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/09/full-cone-nat-with-linux/">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>根据 <a href="https://www.ietf.org/rfc/rfc3489.txt" target="_blank" rel="noopener">RFC 3489</a> 中的定义，NAT类型被划分为以下四种： Full Cone, Restricted Cone, Port Restricted Cone, Symmetric. (RFC 5780 中对NAT类型定义有了更严格的拓展分类，但不是十分常用，本文暂不探讨。)</li>
<li>STUN过程( <a href="https://www.ietf.org/rfc/rfc3489.txt" target="_blank" rel="noopener">RFC 3489</a> 和 <a href="https://tools.ietf.org/html/rfc5389" target="_blank" rel="noopener">RFC 5389</a> )可以实现内网穿透，从而实现点到点通信。STUN技术被广泛应用于 VoIP、WebRTC、网络游戏、VPN等涉及低延迟点到点通讯的领域。</li>
<li>基于STUN的内网穿透成功率取决于通信双方的NAT类型，其中 Full Cone NAT 的成功率最高。</li>
<li>关于NAT type和STUN协议、STUN过程的详细知识请参考其他文章。本文仅探讨 RFC 3489 下定义的 Full Cone NAT 和 UDP hole punching 技术。</li>
<li>本文中的NAT特指NAPT。ALG等周边技术在部分厂商的linux网络设备上已有相应实现，暂不讨论。</li>
<li>你可以直接到 <a href="https://github.com/Chion82/netfilter-full-cone-nat" target="_blank" rel="noopener">https://github.com/Chion82/netfilter-full-cone-nat</a> 使用本文的解决方案。</li>
</ul>
<h2 id="关于NAT类型在Linux上实现的现状"><a href="#关于NAT类型在Linux上实现的现状" class="headerlink" title="关于NAT类型在Linux上实现的现状"></a>关于NAT类型在Linux上实现的现状</h2><p>TLDR: Linux内核树上未实现真正意义上的Full Cone NAT，Linux的 SNAT/MASQUERADE（以<code>iptables</code>的配置为例）均是Symmetric NAT。</p>
<p>2018.3 更新：<br>一个比较少众的华硕路由器第三方固件 padavan 通过netfilter patch的方式实现了 Cone NAT，但是其实现存在较多问题，如不支持端口随机化、内核升级不友好等，具体在下一篇博客中讨论。</p>
<h2 id="现有的在Linux上的Full-Cone-NAT-的实现"><a href="#现有的在Linux上的Full-Cone-NAT-的实现" class="headerlink" title="现有的在Linux上的Full Cone NAT(?)的实现"></a>现有的在Linux上的Full Cone NAT(?)的实现</h2><p>之所以“Linux上未真正实现Full Cone NAT”这个问题至今没有被重视，是因为总有那么个“看似能够代替的方案”。事实上，稍微谷歌一下不难找到这样来实现Full Cone NAT的方法（假设<code>eth0</code>是外网出口网卡，内网主机是<code>192.168.1.3</code>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE #普通的SNAT</span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -j DNAT --to-destination 192.168.1.3 #将入站流量DNAT转发到内网主机192.168.1.3</span><br></pre></td></tr></table></figure></p>
<p>类似的实现还有<code>NETMAP</code>。这种设置都有一个共同点：入站流量其实是 <strong>定向DNAT转发</strong> 到某一台内网主机中，从而对该台内网主机而言，它的NAT类型总是Full Cone的。事实上这种设置更像是DMZ host，是不分条件地转发所有入站流量到内网DMZ主机。然而，这种设置只能对该台内网主机有效，对于同一内网下的其他主机，它们的NAT类型仍然是Symmetric。</p>
<h3 id="UPnP技术"><a href="#UPnP技术" class="headerlink" title="UPnP技术"></a>UPnP技术</h3><p>为了解决这个问题，UPnP起到了很重要的作用。事实上，UPnP技术基本上解决了家庭用户的内网穿透需求。（鉴于现在大多数用户都使用基于Linux的智能路由器的光猫等）在Linux上，实现UPnP的应用程序通常是 <a href="https://github.com/miniupnp/miniupnp" target="_blank" rel="noopener">miniupnp</a>。<br>内网主机的应用程序在需要进行内网穿透前，对路由器进行一次UPnP请求，该请求映射一个外网端口（UDP或TCP）到内网主机的端口。miniupnp随后会执行若干条 <code>iptables</code> 命令，例如最重要的是这条：（为便于理解，该命令已简化，事实上miniupnpd会在 <code>nat</code> 表下另建一个链）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i eth0 -p udp --dport 5000 -j DNAT --to-destination 192.168.1.3:5000</span><br></pre></td></tr></table></figure></p>
<p>这条命令映射了外网的 <code>udp:5000</code> 端口到内网主机 <code>192.168.1.3</code> 的 <code>udp:5000</code>。只要外网端口号不重复，内网内的任何主机都能够再次发起UPnP请求来申请新的映射。映射成功后，该内网主机使用申请的内网端口进行通信时是Full Cone的。</p>
<p>然而，UPnP有较大的局限性：</p>
<ul>
<li>UPnP涉及SSDP组播发现过程，miniupnpd的默认配置更是会向客户端返回全局映射表，相对而言不太安全，不适合应用于复杂的企业级大型网络及ISP入户网络。</li>
<li>一次UPnP请求只能进行一级NAT的映射，当然你也可以转发UPnP请求到上级NAT设备，但是似乎至今没有一款家用智能路由器会这么做。这意味着如果你在家使用两台以上的智能路由器级联上网，仅通过UPnP是无法实现内网穿透的。</li>
</ul>
<p>综上所述，目前Linux下对于Full Cone NAT的实现均是基于主动的端口映射技术（添加DNAT规则），这种实现一定程度上能满足现今的大多数家用场景，但仍在很多场合下有较大的局限性：如网吧、ISP的NAT(LSN)网关等，这些组织对于Full Cone NAT的实现通常是使用非Linux内核的企业级路由设备，这些设备可能基于如思科的硬转发芯片、FPGA等。</p>
<h2 id="Mailing"><a href="#Mailing" class="headerlink" title="Mailing"></a>Mailing</h2><p>对于Full Cone NAT这个feature，可以从内核（具体是netfilter子系统）的mailing list上找到相关的问题：</p>
<blockquote>
<p><a href="http://lists.netfilter.org/pipermail/netfilter/2005-February/058428.html" target="_blank" rel="noopener">Configure to Full Cone</a> :<br>How can I configure IPtables to be Full Cone?<br>- You cannot. iptable_nat only implements the most sophisticated version<br>of NAT: fully symmetric.</p>
<p><a href="http://lists.netfilter.org/pipermail/netfilter/2007-February/067963.html" target="_blank" rel="noopener">IPTables and different types of NAT</a> :<br>“Full cone NAT” can be implemented with 1-to-1 bidirectional NAT using<br>SNAT+DNAT or NETMAP.</p>
</blockquote>
<p>由此可见，他们的回答基本和我们的讨论基本无二：netfilter只实现最成熟的symmetric NAT，如果要实现Full Cone NAT，需要使用一对一的定向DNAT/NETMAP转发。</p>
<h2 id="还有没有必要在Linux上实现真正意义上的Full-Cone-NAT？"><a href="#还有没有必要在Linux上实现真正意义上的Full-Cone-NAT？" class="headerlink" title="还有没有必要在Linux上实现真正意义上的Full Cone NAT？"></a>还有没有必要在Linux上实现真正意义上的Full Cone NAT？</h2><p>经过对DMZ host和UPnP的分析，我们重新定义何为“真正意义上的Full Cone NAT”：对于内网主机中的任意一台主机，在不借助“主动端口映射”申请（如UPnP）和“手动端口转发配置”（如DMZ host或DNAT规则）下，在路由器端口用完之前，都是Full Cone的；路由器的“入站端口映射规则”是根据“内网主机出站端口映射记录”动态生成的，无论内网主机数量是否改变，内网主机的IP地址是否变更，在不依赖人工改变配置时，内网主机的NAT类型始终为Full Cone。<br>当然，这个定义只是为了方便理解本文的内容而定下的。</p>
<p>Linux的NAT类型的影响范围：涉及了所有日渐普及的基于Linux的嵌入式网络设备，如家用光猫、家用智能路由器等。事实上，部分小区级别的ISP由于节约成本使用的也是基于Linux的NAT路由器，出于安全考虑这些路由器当然不会开启UPnP，因此这部分ISP的终端用户将不可能得到完整的Full Cone NAT。对于电信、移动等一级运营商，通过光纤入户的普通用户通常经过企业级LSN设备的NAT，至此入户部分的PPPoE拨号终端通常是Full Cone的，但是，由于一部分用户使用光猫拨号再由光猫NAT后路由至用户最终的计算机（这也是运营商推荐的方式），而光猫没有开启UPnP或DMZ（用户通常没有权限配置），这部分用户的终端设备也不可能得到Full Cone NAT而通常是Symmetric NAT。</p>
<p>因此作者认为，还是有必要在Linux上实现Full Cone NAT。Symmetric NAT意味着更高的安全性，而Cone NAT能兼容更多的应用程序。我们当然不会通过硬编码来实现这个feature，而应该是为用户提供一个新的选择。</p>
<h2 id="netfilter内核子系统和conntrack"><a href="#netfilter内核子系统和conntrack" class="headerlink" title="netfilter内核子系统和conntrack"></a>netfilter内核子系统和conntrack</h2><p>经过作者的各种尝试，要实现一个高效的原生Full Cone NAT，在应用层是无法实现的了（就算通过程序抓包后实时添加iptables规则，或从用户态刷新conntrack，也非常低效），因此，我们只能深入linux内核来进一步研究。</p>
<p><strong>HACK THE KERNEL!</strong></p>
<p>上文已有提到，在linux中负责处理nat的内核子系统是netfilter，而netfilter对应的前端有iptables和nftables。</p>
<p>为对nat的状态进行跟踪，netfilter引入了conntrack。conntrack用来记录每一个连接（TCP/UDP/ICMP/DCCP等会话）的双向地址和端口（或id, code等会话标识符）信息。netfilter对每一个conntrack定义了一个 <code>struct nf_conn</code> 结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> <span class="title">ct_general</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> status;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>tuplehash</code> 数组是我们需要关心的。该数组通常有2个成员：<code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 和 <code>tuplehash[IP_CT_DIR_REPLY]</code>。要了解它们分别代表什么，先来看一下 <code>struct nf_conntrack_tuple_hash</code> 里的 <code>struct nf_conntrack_tuple tuple</code> 成员。这个 <code>tuple</code> 结构定义如下（为便于理解，一些不在同一源文件定义的struct和union被整合进来）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>   <span class="comment">//tuple.src 指示了源地址和源会话标识符</span></span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr u3;    <span class="comment">//源IP地址（ipv4或ipv6）</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">      <span class="comment">// 这个union指示了源会话标识符，可以是一个TCP/UDP端口，或ICMP id，dccp port等。</span></span><br><span class="line">      <span class="comment">// 此处省略除TCP、UDP外的其它协议</span></span><br><span class="line">      __be16 all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; tcp;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; udp;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num;</span><br><span class="line">  &#125; src;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                  <span class="comment">//tuple.dst 指示了目的地址和目的会话标识符</span></span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr u3;  <span class="comment">//目的IP地址</span></span><br><span class="line">    <span class="keyword">union</span> &#123;                 <span class="comment">//和tuple.src一样，这个union指示了目的会话标识符</span></span><br><span class="line">      __be16 all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; tcp;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; udp;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">u_int8_t</span> protonum;      <span class="comment">//协议号</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> dir;</span><br><span class="line">  &#125; dst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不难看出，<code>struct nf_conntrack_tuple</code> 结构是一个五元组，其包括了：源地址/源端口/目的地址/目的端口/协议号。而在刚才的 <code>tuplehash</code> 数组中，<code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 和 <code>tuplehash[IP_CT_DIR_REPLY]</code> 分别代表 “源五元组” 和 “期望收到的应答五元组”。在这里，你可以分别把它们暂时简单的理解为出站和入站的五元组，一个conntrack由一对五元组组成。</p>
<p>在 <code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 中，<code>src</code> 指的是内网主机（或本机）的源地址，<code>dst</code> 指的是TCP/UDP流量的远端目的地址；而在 <code>tuplehash[IP_CT_DIR_REPLY]</code> 中，<code>src</code> 是TCP/UDP的远端主机的地址，<code>dst</code> 是本机的地址。</p>
<p>在内网主机经过NAT网关一次普通的SNAT后，一个conntrack存放的一对五元组tuple应包含如下信息：</p>
<ul>
<li><code>tuplehash[IP_CT_DIR_ORIGINAL].tuple</code> ： 相对于内网主机到远端主机的方向，如 <code>src</code>192.168.1.3:5000 -&gt; <code>dst</code>114.114.114.114:53</li>
<li><code>tuplehash[IP_CT_DIR_REPLY].tuple</code> ：相对于远端主机到本机的方向，如 <code>src</code>114.114.114.114:53 -&gt; <code>dst</code>120.239.65.166:38720 （其中120.239.65.166是本机即NAT网关的外网IP，38720是SNAT映射后得到的外网端口）</li>
</ul>
<p>参考nf_nat，我们可以概括出一次SNAT由如下步骤完成：</p>
<ol>
<li>来自内网主机的数据包流经nat表的POSTROUTING链并触发SNAT/MASQUERADE hook，nf_nat 进行源IP转换和端口映射，并调用 <code>nf_nat_setup_info()</code> 对当前conntrack（我们假设这个conntrack命名为conn1）的tuplehash信息进行修改，将转换后的源外网IP和映射后的外网端口写到 <code>tuplehash[IP_CT_DIR_REPLY].tuple.dst</code> 中。</li>
<li>当有新的数据包流入时，nf_conntrack_core 通过在 <code>resolve_normal_ct()</code> 中根据流入的数据包得到对应的一个tuple，因为这个tuple的信息与 conn1 的 <code>tuplehash[IP_CT_DIR_REPLY].tuple</code> 一致，调用 <code>nf_conntrack_find_get()</code> 即获取到先前的 conn1。</li>
<li>再根据 conn1 的 <code>tuplehash[IP_CT_DIR_ORIGINAL].tuple</code> 信息，将流入的数据包的目的IP和端口还原成内网主机的IP的端口。</li>
</ol>
<p>* 以上过程仅从代码层面推测，未经过严格debug验证，如实际过程有误欢迎提出。</p>
<h2 id="编写一个xt-FULLCONENAT内核模块"><a href="#编写一个xt-FULLCONENAT内核模块" class="headerlink" title="编写一个xt_FULLCONENAT内核模块"></a>编写一个xt_FULLCONENAT内核模块</h2><p>要实现一个原生的Full Cone NAT功能，至少需要编写一个netfilter内核模块，外加一个或多个前端模块（前端模块是在用户态的一个.so文件，不涉及内核态API）。</p>
<p>注意，我们现在只关注RFC3489，即只实现UDP的Full Cone。其它协议的内网穿透相对而言不太常用，我们暂且搁置。</p>
<p>在此列出以下两种实现方案：</p>
<ul>
<li>实现应用于mangle表的hook，对每个流出流入的包进行地址和端口信息修改。相当于手动实现一遍DNAT和SNAT。这种方案可以绕过conntrack对五元组的严格验证，但实现复杂，而且性能较差。</li>
<li>参考现有的NAT模块（如NETMAP），实现应用于nat表的hook。这种方案采用netfilter现有的nat方法来实现地址转换。但是受限于conntrack的五元组约束，除了需要依赖conntrack模块内置的映射规则来进行标准的nat，还需要另行在我们的模块中维护一张映射表。</li>
</ul>
<p>作者采用了第二种方案。大体的设想是：在nat表的POSTROUTING链和PREROUTING链各添加一个FULLCONENAT规则，对于POSTROUTING的操作，FULLCONENAT与MASQUERADE表现无异，但需要将“端口映射记录”暂存到本模块维护的映射表中；而在PREROUTING链，FULLCONENAT对于每一个未被conntrack记录的入站连接，根据本模块维护的端口映射表，<strong>按需DNAT</strong>至相应的内网主机。</p>
<p>在前端使用iptables时，应用本模块的规则应该是这样的（假设 <code>eth0</code> 是公网出口网卡）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j FULLCONENAT #same as MASQUERADE  </span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -j FULLCONENAT  #automatically restore NAT for inbound packets</span><br></pre></td></tr></table></figure></p>
<p>我们使用一个hashmap来维护这个端口映射表。作者定义了这样的一个hashmap节点：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">natmapping</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port;    <span class="comment">/* external port */</span></span><br><span class="line">  __be32 int_addr;  <span class="comment">/* internal ip address */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> int_port; <span class="comment">/* internal port */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">original_tuple</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当FULLCONENAT target应用在POSTROUTING链时，我们实现与MASQUERADE基本相同的SNAT：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__be32 new_ip = get_device_ip(skb-&gt;dev);  <span class="comment">// 获取interface的本地IP</span></span><br><span class="line">newrange.min_addr.ip = new_ip;            <span class="comment">// 将nat ip限制为interface的本地IP</span></span><br><span class="line">newrange.max_addr.ip = new_ip;</span><br><span class="line">ret = nf_nat_setup_info(ct, &amp;newrange, HOOK2MANIP(xt_hooknum(par)));  <span class="comment">// 调用nf_nat_setup_info()进行SNAT</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们将映射结果保存到端口映射表中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ct_tuple_origin = &amp;(ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple);</span><br><span class="line">ct_tuple = &amp;(ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line">ip = (ct_tuple_origin-&gt;src).u3.ip;  <span class="comment">//这里获取到内网主机的IP</span></span><br><span class="line">original_port = be16_to_cpu((ct_tuple_origin-&gt;src).u.udp.port); <span class="comment">//内网主机的端口号</span></span><br><span class="line">port = be16_to_cpu((ct_tuple-&gt;dst).u.udp.port); <span class="comment">//映射后的外网端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把映射存进映射表中</span></span><br><span class="line">mapping = get_mapping(port);  <span class="comment">//根据外网端口号从映射表中获取对应的映射记录，可能创建了新的hashmap节点</span></span><br><span class="line">mapping-&gt;int_addr = ip;   <span class="comment">//内网主机的IP</span></span><br><span class="line">mapping-&gt;int_port = original_port;  <span class="comment">//内网主机的端口号</span></span><br><span class="line"><span class="comment">//拷贝整个tuplehash[IP_CT_DIR_ORIGINAL].tuple，至于为什么这么做稍后会解释</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;mapping-&gt;original_tuple, ct_tuple_origin, <span class="keyword">sizeof</span>(struct nf_conntrack_tuple));</span><br></pre></td></tr></table></figure></p>
<p>当FULLCONENAT target应用在PREROUTING链时，我们需要实时查询映射表，并实现相应的DNAT：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ct_tuple = &amp;(ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple);</span><br><span class="line">ip = (ct_tuple-&gt;src).u3.ip;   <span class="comment">//外网IP</span></span><br><span class="line">port = be16_to_cpu((ct_tuple-&gt;dst).u.udp.port); <span class="comment">//外网端口号</span></span><br><span class="line">mapping = get_mapping(port); <span class="comment">//根据外网端口号从映射表中获取对应的映射记录</span></span><br><span class="line"><span class="keyword">if</span> (is_mapping_active(mapping, ct)) &#123;</span><br><span class="line">  <span class="comment">//如果映射记录有效，则继续根据该映射记录执行DNAT：</span></span><br><span class="line">  newrange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;</span><br><span class="line">  newrange.min_addr.ip = mapping-&gt;int_addr;   <span class="comment">//将nat ip限制为内网主机IP</span></span><br><span class="line">  newrange.max_addr.ip = mapping-&gt;int_addr;</span><br><span class="line">  newrange.min_proto.udp.port = cpu_to_be16(mapping-&gt;int_port);   <span class="comment">//将nat port限制为内网主机端口号</span></span><br><span class="line">  newrange.max_proto = newrange.min_proto;</span><br><span class="line">  ret = nf_nat_setup_info(ct, &amp;newrange, HOOK2MANIP(xt_hooknum(par)));  <span class="comment">// 调用nf_nat_setup_info()进行DNAT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于如何“在conntrack失效（超时）时，主动从映射表中删除对应的映射记录”，作者目前暂时未找到好的方法（尽量不改动nf_conntrack部分，是否能够注册ct失效回调？）。也就是说现在这个映射表“只能添加和替换记录，而不能删除记录”（映射表的长度不会超过映射端口的范围，暂时不会导致严重的内存泄漏问题）。</p>
<p>为了确保在DNAT之前，先前SNAT时注册的conntrack仍然有效，作者实现了一个 <code>is_mapping_active()</code> 函数，该函数调用 <code>nf_conntrack_find_get()</code> ，通过在映射记录中保存的 <code>original_tuple</code> 来查询对应的conntrack，如果查找结果为空，则认为该conntrack已失效，否则认为该conntrack仍然有效，并继续进行DNAT。当然，这并不是最好的方法，如果你有更好的建议，欢迎联系我。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_mapping_active</span><span class="params">(<span class="keyword">const</span> struct natmapping* mapping, <span class="keyword">const</span> struct nf_conn *ct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *<span class="title">original_tuple_hash</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (mapping-&gt;port == <span class="number">0</span> || mapping-&gt;int_addr == <span class="number">0</span> || mapping-&gt;int_port == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* get corresponding conntrack from the saved tuple */</span></span><br><span class="line">  net = nf_ct_net(ct);</span><br><span class="line">  zone = nf_ct_zone(ct);</span><br><span class="line">  <span class="keyword">if</span> (net == <span class="literal">NULL</span> || zone == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  original_tuple_hash = nf_conntrack_find_get(net, zone, &amp;mapping-&gt;original_tuple);</span><br><span class="line">  <span class="keyword">if</span> (original_tuple_hash) &#123;</span><br><span class="line">    <span class="comment">/* if the corresponding conntrack is found, consider the mapping is active */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们的xt_FULLCONENAT模块的核心部分已阐述完毕。除此之外，还需要编写对应的前端模块，作者参考了ipt_MASQUERADE，通过简单的关键字替换实现了ipt_FULLCONENAT，作为iptables extension可提供给iptables使用。</p>
<p>这个内核模块以及iptables extension的完整代码、编译和安装方法请参考GitHub仓库： <a href="https://github.com/Chion82/netfilter-full-cone-nat" target="_blank" rel="noopener">https://github.com/Chion82/netfilter-full-cone-nat</a></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li>使用了Linux设备作为NAT网关，内网主机运行STUN测试的测试结果是Port Restricted Cone NAT，而不是Symmetric NAT。<br>这是因为Stun和netfilter对映射要素的理解存在差异造成的，具体可参考 <a href="http://blog.csdn.net/u011245325/article/details/9294229" target="_blank" rel="noopener">这篇文章</a>。但不能因此就断定linux的SNAT不是Symmetric。实际上，这是因为linux NAT网关上存在这条iptables规则导致的（OpenWRT发行版的firewall默认存在这条规则，虽然是在INPUT的子链中）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -i eth0 -j REJECT #或者INPUT的policy为REJECT</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果删除了这条规则（在OpenWRT上则是在Firewall设置中，将wan zone的Input策略从reject改为accept），内网主机运行STUN测试的结果会始终是Symmetric NAT。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/" data-id="cjh4y6u49000iz42h45j9malj" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-kcptun-with-fake-tcp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/06/kcptun-with-fake-tcp/" class="article-date">
  <time datetime="2017-04-06T04:43:56.000Z" itemprop="datePublished">2017-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/网络/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/06/kcptun-with-fake-tcp/">kcptun-raw：应对UDP QoS，重新实现kcptun的一次尝试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>关于KCP ARQ协议和kcptun请见：<br><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a><br><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a><br>本文程序源码：<br><a href="https://github.com/Chion82/kcptun-raw" target="_blank" rel="noopener">https://github.com/Chion82/kcptun-raw</a></p>
</blockquote>
<h2 id="UDP断流问题"><a href="#UDP断流问题" class="headerlink" title="UDP断流问题"></a>UDP断流问题</h2><p>我们知道kcptun的底层协议是UDP，而很多ISP对大流量UDP会做QoS，这包括了大量issue反映的“断流”问题：在正常运行一段时间之后流量会中断，需要等待数分钟才能恢复，有时候除非更换端口，将一直保持0速度。<br>kcptun作者对此的解决方法是使用<code>--autoexpire</code>参数设置UDP连接超时并自动重连（补充：UDP虽无连接状态，但仍有会话保持机制），但此举治标不治本，对于QoS频繁的网络环境需要频繁更改UDP端口，而该过程可能会导致kcptun的上层连接（本地TCP连接）中断。<br>为了解决断流问题，各位网友各出奇招，比如 <a href="https://github.com/xtaci/kcptun/issues/228" target="_blank" rel="noopener">issue #228</a> 提到的端口随机化、上下行分不同端口等，都能一定程度缓解该问题，然而这仍然都是治标不治本的方法。<br>你可能理所当然的认为，“下层协议用TCP不就好了”（即kcp over tcp）。是的，ISP对TCP做的QoS要“宽容”很多（完全断流且不能恢复的几率不大），如果将kcptun的下层协议换成TCP，应该可以解决我们的问题？<br>答案是NO。UDP和TCP的一个重要区别是，UDP是不可靠的、基于message的实时性协议，而TCP是可靠的、基于stream的非实时性协议。而KCP作为可靠的ARQ算法，所依赖的下层协议必须保证实时性，而可靠性并不需要保证。如果我们直接将下层协议换成TCP，则流量会先经过操作系统内核进行拥塞控制和纠错处理，再递交kcp层，这样一来kcp的优化拥塞控制算法就完全没有发挥作用。</p>
<h2 id="伪装TCP流量的可行性"><a href="#伪装TCP流量的可行性" class="headerlink" title="伪装TCP流量的可行性"></a>伪装TCP流量的可行性</h2><p>要解决UDP断流问题，不更换下层协议是很难做到的。于是我想到，能不能直接使用网络层的IP packet作为kcp的下层协议。因为边缘路由器一般是在OSI网络层进行转发，所以在公网环境下是可行的。然而我们的客户端都是在ISP内网环境，这将不现实：因为NAT需要跟踪运输层头部数据，如双方的端口信息。后来我发现了 <a href="https://github.com/linhua55" target="_blank" rel="noopener">linhua55</a> 同学的 <a href="https://github.com/linhua55/some_kcptun_tools/tree/master/relayRawSocket" target="_blank" rel="noopener">some_kcptun_tools/relayRawSocket</a> 项目，这位同学写了个简单的python脚本实现了“fake TCP to UDP”的中继，通过raw socket来实现带静态TCP头部的IP packet收发，并转发到上层UDP。经测试，这个脚本能一定程度上解决断流问题，但存在带宽利用率不高、不稳定的问题。<br>受这个项目的启发，我想使用同样的原理重新实现一个简单的kcptun：下层协议更换为带TCP头的packet（通过raw socket或libpcap等实现），使ISP认为这是TCP流量。但这并不是严格的“kcp over tcp”，因为我们完全绕过系统内核的TCP/IP内核栈对流量的管控而直接交由kcp进行拥塞控制和纠错。这样一来，我们我们能够保证下层报文递交到kcp算法时的实时性。<br>换言之，我们需要 <strong>在用户态模拟从IP到TCP的协议栈</strong>。</p>
<p>在造轮子之前，需要验证这些带了伪TCP header的IP header是否能够在网络上正常收发。于是编写了这么的一个实验程序：<br><a href="https://gist.github.com/Chion82/699ae432a27507242ea788df324f4e47" target="_blank" rel="noopener">https://gist.github.com/Chion82/699ae432a27507242ea788df324f4e47</a></p>
<p>该程序修改自网上的一段SYN flood程序。<br>通过修改IP信息，编译出<code>client</code>和<code>server</code>两个bin，即可测试本地到服务端的双向连通性。若测试成功，双方都能收到对方的一条text消息。<br>这个程序使用raw socket实现packet收发，由程序直接拼装TCP和IP报头：在 <code>trans_packet.c</code> 中，借助 <code>struct iphdr</code> 和 <code>struct tcphdr</code> 两个结构来拼接，TCP头是静态的，置flag SYN=1。<br>在接收packet时，由于使用了 <code>ETH_P_ALL</code> 过滤器（为什么不使用 <code>IPPROTO_TCP</code> 后面会提到），经过全部网卡的所有packet都会被捕捉，因此要通过判断IP头协议以及TCP头目标端口进行过滤。</p>
<p>这个实验程序说明了伪装TCP流量实现双向通信是可行的。因为要使用raw socket来重写kcptun，我们就称这个项目为“kcptun-raw”吧。</p>
<h2 id="绕过内核TCP-IP协议栈"><a href="#绕过内核TCP-IP协议栈" class="headerlink" title="绕过内核TCP/IP协议栈"></a>绕过内核TCP/IP协议栈</h2><p>由于我们在用户态直接使用raw socket发送IP报文，双方的内核都对这个我们手动模拟的TCP连接不知情，因此当内核收到对方发送的IP报文时，内核根据报文中的TCP头信息（这些信息是我们手动拼接的）试图寻找TCP连接跟踪信息并且寻找失败，随即认为该报文是无效的，内核接着会试图“终止”我们模拟的TCP连接，并向对方发送一个RST包。该RST包会导致中间路由器认为连接已被重置，撤销打通的NAT pipe，使得接下来发送的报文都不能到达对方。</p>
<p>因此，我们需要使这些IP报文绕过内核的TCP/IP协议栈，以此来避免内核对我们模拟的TCP连接的干涉。这可以通过Linux的<code>iptables</code>的<code>DROP</code>命令实现。<br>假设服务端IP为<code>108.0.0.1</code>，模拟TCP连接的端口为<code>888</code>，在服务端的iptables命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 888 -j DROP</span><br></pre></td></tr></table></figure></p>
<p>对应的客户端命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -s 108.0.0.1 --sport 888 -j DROP</span><br></pre></td></tr></table></figure></p>
<p>在使用了<code>DROP</code>操作后，如果raw socket继续使用 <code>IPPROTO_TCP</code> 过滤器，将无法接收到该端口上的任何报文。因此，我们将使用 <code>ETH_P_ALL</code>，接收流经网卡的全部IP报文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> packet_recv_sd = socket(AF_PACKET , SOCK_DGRAM , htons(ETH_P_IP));</span><br></pre></td></tr></table></figure></p>
<p>linhua55同学在 <a href="https://github.com/Chion82/kcptun-raw/issues/2" target="_blank" rel="noopener">Issue #2</a> 中提到Windows下绕过内核协议栈的方法，即通过 <code>ipseccmd.exe</code> 或 <code>netsh</code> 命令。</p>
<h2 id="动态TCP-header和模拟三次握手"><a href="#动态TCP-header和模拟三次握手" class="headerlink" title="动态TCP header和模拟三次握手"></a>动态TCP header和模拟三次握手</h2><p>作者在几个ISP网络环境下进行了测试，发现部分环境下静态TCP报头无法传送到服务端，或是服务端返回的packet客户端收不到，这种情况下需要模拟TCP三次握手过程。另外，将TCP报头的seq/ack参数改为动态自增可以增强稳定性，而有的环境下则必须保持定值。<br>具体测试结果如下（<a href="https://github.com/linhua55/some_kcptun_tools/issues/2" target="_blank" rel="noopener">Issue #2</a>）：</p>
<ul>
<li>广东移动：<ul>
<li>服务端ack flag必须置为1，否则客户端将一直收不到服务端的packet。</li>
<li>seq/ack序列需要一直保持定值，如果一直自增会被QoS随后pipe被掐断；</li>
</ul>
</li>
<li>广电宽带（广东）和电信4G：<ul>
<li>必须模拟TCP三次握手过程，即 客户端SYN-&gt;服务端SYN+ACK-&gt;客户端ACK ，随后pipe才能打通。</li>
<li>seq/ack序列无要求，保持定值和一直自增都可以。</li>
</ul>
</li>
<li>服务器提供商（阿里云等）：<ul>
<li>vps之间通信基本无限制，在防火墙关闭的情况下，packet想怎么发都可以（因为没有经过NAT和ISP的QoS的缘故？）</li>
</ul>
</li>
</ul>
<h2 id="报文分层设计和流控"><a href="#报文分层设计和流控" class="headerlink" title="报文分层设计和流控"></a>报文分层设计和流控</h2><p>在确认了下层协议的实现可行性之后，作者即开始动手开发kcptun-raw。</p>
<h3 id="第一次报文分层"><a href="#第一次报文分层" class="headerlink" title="第一次报文分层"></a>第一次报文分层</h3><p>作为隧道，最上层协议当然是TCP，而KCP的下层协议是packet。一开始理所当然的想法是，一个上层的TCP连接对应一个KCP连接，而全部KCP连接共用同一个伪造的TCP连接并在其上传输带伪造TCP头的packet作为最下层传输协议。而最下层的packet封包除了传输多个kcp连接的片段数据（KCP segment），还用于传送命令，这些命令包括建立连接、关闭连接和保活命令等。<br>这样，一次上层TCP连接从建立到断开的分层流程大致如下：<br>客户端：</p>
<blockquote>
<table>
<thead>
<tr>
<th>→</th>
<th>→</th>
<th>→</th>
<th>→</th>
<th>→</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>↓ 新连接</td>
<td>↓ 接收数据</td>
<td>↑ 发送数据</td>
<td>↓ 断开连接</td>
</tr>
<tr>
<td>KCP</td>
<td>↓ 新连接</td>
<td>↓ 发送KCP片段</td>
<td>↑ 接收KCP片段</td>
<td>↓ 杀死</td>
</tr>
<tr>
<td>packet</td>
<td>↓ 推送新连接</td>
<td>↓ 推送数据段</td>
<td>↑ 接收数据段</td>
<td>↓ 推送关闭连接</td>
</tr>
</tbody>
</table>
</blockquote>
<p>服务端：</p>
<blockquote>
<table>
<thead>
<tr>
<th>→</th>
<th>→</th>
<th>→</th>
<th>→</th>
<th>→</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>↑ 新连接</td>
<td>↑ 发送数据</td>
<td>↓ 接收数据</td>
<td>↑ 断开连接</td>
</tr>
<tr>
<td>KCP</td>
<td>↑ 新连接</td>
<td>↑ 接收KCP片段</td>
<td>↓ 发送KCP片段</td>
<td>↑ 杀死</td>
</tr>
<tr>
<td>packet</td>
<td>↑ 对方推送新连接</td>
<td>↑ 接收数据段</td>
<td>↓ 发送数据段</td>
<td>↑ 对方推送关闭连接</td>
</tr>
</tbody>
</table>
</blockquote>
<p>这看起来没有什么问题。然而这忽略了一个很重要的东西：命令封包丢失。如果丢失的是KCP的数据段封包，这没有什么问题——KCP会自动处理好重发、拥塞和纠错策略，以保证上交到TCP层的数据是正确完整的；但是如果丢失的是建立连接或断开连接的命令封包，问题就很严重了，这会导致客户端的新TCP连接迟迟无法响应、或是其中一方的TCP连接变成“僵尸连接”（其中一方已关闭连接，而主动关闭命令未送达）。这正是为什么TCP需要三次握手和四次挥手的原因：为了处理在边界情况下的各种丢包情况。</p>
<h3 id="MUX层、共享KCP连接"><a href="#MUX层、共享KCP连接" class="headerlink" title="MUX层、共享KCP连接"></a>MUX层、共享KCP连接</h3><p>要解决这个问题，我们需要重新设计一次报文分层。因为KCP层以上的数据都是可靠的，因此我们可以共享kcp连接，并在此之上传送命令封包和数据封包。要实现这样的设计，我们要在TCP层之下引入MUX层。MUX即Stream Multiplexing，这样我们可以在唯一的KCP流上进行多路复用。为此我们重新设计在KCP流上传输的封包类型：标识了TCP流ID的数据帧、新连接命令、断开连接命令、保活命令。</p>
<p>其次，考虑到加密封包和checksum验证，最终设计的数据流分层以及对应的payload定义如下：<br><img src="https://raw.githubusercontent.com/Chion82/kcptun-raw/master/layers.png" alt=""></p>
<h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>为什么需要流控？考虑这样的一个情景：服务端的TCP连接在1s内接收了100MB的数据（如果是跑在服务器本机的服务，这个速度很正常），并一下子全部经由KCP传送给客户端，而受服务端到客户端的带宽所限，这100MB数据需要2min才能传输完成，此时服务端的KCP发送队列十分拥塞，如果这时服务端上有另一个TCP连接接收到了数据，这部分数据帧将追加到KCP发送队列的队尾，并迟迟发不出去，直至100MB的数据传输完毕。这样的直接表现是，正在全速下载大文件时，发出的新连接请求要等到文件下载完毕后才得到响应，并发性能极差。</p>
<p>为了避免这个问题，我们需要双向流控来实现双边连接的同步：当对方<code>kcp_recv()</code>速度远慢于己方<code>tcp_recv()</code>速度，导致己方KCP发送队列长时，及时暂停己方的<code>tcp_recv()</code>；当己方的TCP发送队列长（表现为非阻塞socket下、<code>send()</code> 后得到 <code>EAGAIN</code> ），暂停己方的<code>kcp_recv()</code>，以增加对方的KCP发送队列长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kcp_update_interval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//遍历活跃的TCP连接，并检测其发送队列长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector_total(&amp;open_connections_vector); i++) &#123;</span><br><span class="line">    connection = vector_get(&amp;open_connections_vector, i);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;in_use &amp;&amp; (connection-&gt;pending_send_buf_len) &gt; MAX_QUEUE_LENGTH * BUFFER_SIZE) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">//TCP发送队列过长，暂停KCP接收</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//KCP接收数据</span></span><br><span class="line">  <span class="keyword">int</span> recv_len = ikcp_recv(kcp, recv_buf, BUFFER_SIZE);</span><br><span class="line">  <span class="comment">//根据KCP发送队列长度判断是否暂停TCP recv()操作</span></span><br><span class="line">  <span class="keyword">int</span> stop_recv = (iqueue_get_len(&amp;(kcp-&gt;snd_queue)) &gt; MAX_QUEUE_LENGTH) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p>在确定了各项设计后，我们可以开始着手开发kcptun-raw了。程序使用非阻塞socket，借助 <a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">libev</a> 库实现高性能的事件并发模型，避免使用多线程/进程。</p>
<p>kcptun-raw的开发前后遇到了不少困难，不过最终还是做出来了。经过我的测试，效果还是不错的，单线程下载速度最高在15~20 Mbytes/s，最大并发连接数程序写死了8192（当然一般是到不了这么大的）。</p>
<h3 id="稳定性和保活"><a href="#稳定性和保活" class="headerlink" title="稳定性和保活"></a>稳定性和保活</h3><p>为了保证程序长期运行的稳定性，以应对各种不可避免的网络断流问题，我写了两层保活机制：</p>
<ul>
<li>模拟TCP层保活：packet层的心跳检测，超时则更换客户端端口、重新建立模拟TCP连接。</li>
<li>KCP层保活：在KCP流上的心跳检测，timeout时限比TCP层更长，一旦超时，将立即关闭所有上层TCP连接，重新初始化KCP流，并通知对方重新初始化KCP流。<br>一般情况下，模拟TCP层的保活可以解决绝大多数断流问题——这正是两层保活的优点：下层的自动重连不会影响到KCP流和TCP连接，而当迫不得已需要重启KCP流时，必须中断全部上层TCP连接，以保证双方数据帧的同步。</li>
</ul>
<p>经过我的测试和issue反馈，kcptun-raw目前的稳定性已经很不错了。我在软路由上运行kcptun-raw来加速VPN已经大半个月了，期间一直没有重启过。</p>
<h2 id="几个问题？"><a href="#几个问题？" class="headerlink" title="几个问题？"></a>几个问题？</h2><ul>
<li><p>kcptun-raw还有待改进的地方？<br>目前kcptun-raw的设计是简化的kcptun，特别是取消了FEC，现在发现取消了FEC后会存在延迟抖动、带宽利用率比不上原版kcptun的问题。日后如果发现有需要，会考虑引入FEC。</p>
</li>
<li><p>4.9内核后引入了BBR拥塞算法，为何还需要kcptun？或者说BBR能否为KCP提供一点改进思路？<br>首先，BBR和KCP是工作在两个不同层面的东西：BBR在内核态直接作为TCP/IP协议栈的模块，接管所有TCP连接的拥塞控制，其原理是抛弃老旧的基于丢包检测的窗口控制算法，改为主动探测水管大小，避免网络设备的缓冲区满；KCP则是通过牺牲一部分公平性原则、以大流量换取小延迟的算法，基本原理是激进重传，会消耗20%~30%额外的带宽。经过我的测试，大多时候BBR虽然传输速度比kcptun更快，但是BBR未能解决被QoS的问题：一个TCP连接一旦断流，速度将一直不能恢复，需要重新建立TCP连接方可恢复。这是当然的，因为BBR只是作为接管内核原来的TCP拥塞算法，它是针对per TCP connection而工作的，并没有改变协议栈的分层约定。而kcptun-raw作为上层TCP到下层自定义协议的隧道工具，TCP层以下的协议规则约定是可以自定义的，当下层连接断流了，该层可以自动重连，而这不会导致上层TCP连接的断开，这是解决QoS的关键所在。</p>
</li>
<li><p>另外，快乐膜法师同学基于原版kcptun，也写了一个基于raw socket和伪造TCP的改版，同时支持Linux、MacOS和Windows，并且还有伪装HTTP流量的功能，需要给运营商薅羊毛的同学可以参考：<br><a href="https://github.com/ccsexyz/kcpraw" target="_blank" rel="noopener">https://github.com/ccsexyz/kcpraw</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2017/04/06/kcptun-with-fake-tcp/" data-id="cjh4y6u5c000sz42hfyaqmzm3" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2017/04/06/kcptun-with-fake-tcp/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-universal-react-app-reuse-effects-on-server-side" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/" class="article-date">
  <time datetime="2016-12-21T10:07:32.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>同构 (universal/isomorphic) React应用旨在服务端（或者是网关层、中途岛层）和客户端（浏览器端）尽可能地复用UI组件的代码，以提高项目的可维护性。当同构应用引入以 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">Redux</a> 为首的数据流管理、以 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a> 为主的SPA前端路由后，同构应用将变得复杂：我们需要在服务端和客户端之间同步状态（store）和路由信息，并且尽可能地复用这些数据逻辑（如reducers）和路由配置。关于如何搭建这样的一个项目框架，你可以阅读 <a href="https://blog.tableflip.io/server-side-rendering-with-react-and-redux/" target="_blank" rel="noopener">Server Side Rendering with React and Redux</a>。</p>
<p>本文假设你已经熟悉如何搭建一个 React + Redux + react-router 的同构应用，我们来讨论Redux副作用（side effects，后面简称effects）在服务端复用的逐步尝试和实践。</p>
<h2 id="目前的典型场景"><a href="#目前的典型场景" class="headerlink" title="目前的典型场景"></a>目前的典型场景</h2><p>目前大多数React同构脚手架均不在服务端复用effects，而是通过直接调用Service模块的方式来加载数据，这使得我们可以直接获知异步任务何时完成，并在回调函数中直接执行我们的渲染逻辑。在渲染逻辑中，因为页面初始数据已经取得，从创建store到调用<code>store.getState()</code>来初始化渲染模板都是同步的，没有任何坑点，它看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">APIService.getTodos().then(<span class="function">(<span class="params">initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> store = configureStore(makeInitialState(initialData));</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</span><br><span class="line">  <span class="keyword">const</span> state = store.getState()</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="例：universal-react-starter-kit"><a href="#例：universal-react-starter-kit" class="headerlink" title="例：universal-react-starter-kit"></a>例：universal-react-starter-kit</h3><p>以国内比较流行的脚手架 <a href="https://github.com/bodyno/universal-react-starter-kit" target="_blank" rel="noopener">bodyno/universal-react-starter-kit</a> 为例，其渲染部分的关键代码是这样的：<br><em>server/main.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = <span class="keyword">await</span> router(ctx)</span><br><span class="line"><span class="keyword">const</span> store = createStore(initialState, memoryHistory)</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">match(&#123;history, routes, <span class="attr">location</span>: ctx.req.url&#125;, <span class="keyword">async</span> (err, redirect, props) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">let</span> layout = &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">      &#123;<span class="attr">type</span>: <span class="string">'text/javascript'</span>, <span class="attr">innerHTML</span>: <span class="string">`___INITIAL_STATE__ = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(store.getState())&#125;</span>`</span>&#125;,</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    ]&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  content = renderToString(</span><br><span class="line">    &lt;AppContainer layout=&#123;layout&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>await router(ctx)</code>的<code>router</code>部分代码如下：<br><em>server/router.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    axios.get(<span class="string">'https://api.github.com/zen'</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">zen</span>: &#123; <span class="attr">text</span>: [&#123;<span class="attr">text</span>: data&#125;]&#125; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>await router(ctx)</code>在此处就是一次Service API调用。先不论这个<code>router</code>是否名不符实（可能因为是脚手架的原因。router.js应该是给开发者填入代码来实现对应不同路由调用不同的Service），这个脚手架的渲染逻辑跟上文的示例大同小异——直接调用Service模块异步取得初始数据，在回调（await）中通过全同步的方式用初始数据产生store并<code>getState()</code>，然后调用<code>renderToString()</code>渲染。</p>
<p>在服务端通过“直捅Service”的方式来获取页面初始数据，是最直接、最简单的方法。当然我们在客户端绝对不会这么做，在客户端我们会设计好同步的actions和reducers，并通过触发effects来实现异步数据获取。为了使我们的服务端代码更优雅、维护性更强、代码复用度更高，我们希望在服务端能够复用这些actions、reducers和effects。</p>
<h2 id="使用redux-thunk的场景"><a href="#使用redux-thunk的场景" class="headerlink" title="使用redux-thunk的场景"></a>使用redux-thunk的场景</h2><p>在服务端执行一个effect是很简单的，我们只需要调用在服务端和客户端间共享的<code>configureStore()</code>函数来创建一个空的store（这时你将拥有effects所必须的middleware），然后调用<code>store.dispatch()</code>来触发一个绑定了effects的action即可。难点是：程序如何得知一个异步effects已经执行完成？这样我们才能在effects完成后调用<code>store.getState()</code>来取得带初始数据的state。<br>如果你的项目所使用的effects是 <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>，你可以很容易地在服务端复用它们：你只需要在thunk函数中返回一个promise即可——而这是官方建议的标准写法。这样，<code>store.dispatch()</code>可以直接返回这个promise。<br>你的async thunk action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> APIService.getTodos()</span><br><span class="line">      .then(<span class="function"><span class="params">payload</span> =&gt;</span> dispatch(&#123;</span><br><span class="line">        type: <span class="string">'todos/get/success'</span>,</span><br><span class="line">        payload,</span><br><span class="line">      &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>APIService看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APIService = &#123;</span><br><span class="line">  getTodos: <span class="function"><span class="params">()</span> =&gt;</span> fetch(<span class="string">'/api/todos'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在服务端的渲染逻辑，你可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</span><br><span class="line">    <span class="keyword">const</span> state = store.getState()</span><br><span class="line">    renderFullPage(html, state);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>另外，还有 <a href="https://github.com/acdlite/redux-promise" target="_blank" rel="noopener">redux-promise</a> 的effects解决方案。在服务端复用方面，redux-promise和redux-thunk极为相似，因为使用redux-promise同样可以通过<code>store.dispatch()</code>获得异步任务的promise。<br>唯一的不同之处是，当使用redux-promise时，async action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'todos/get'</span>,</span><br><span class="line">    payload: APIService.getTodos(), <span class="comment">//action.payload是一个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例：react-redux-universal-hot-example"><a href="#例：react-redux-universal-hot-example" class="headerlink" title="例：react-redux-universal-hot-example"></a>例：react-redux-universal-hot-example</h3><p>让我们来看看GitHub上stars最多的Universal React脚手架 <a href="https://github.com/erikras/react-redux-universal-hot-example" target="_blank" rel="noopener">erikras/react-redux-universal-hot-example</a> 是怎么解决的。<br>这个脚手架使用了 <a href="https://github.com/Rezonans/redux-async-connect" target="_blank" rel="noopener">redux-async-connect</a> middleware，这使得我们可以绑定一个promise给每一个container，并在服务端使用它提供的<code>loadOnServer()</code>方法获得待渲染的container的异步任务及其promise。<br><em>src/containers/App/App.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@asyncConnect([&#123;</span><br><span class="line">  promise: <span class="function">(<span class="params">&#123;store: &#123;dispatch, getState&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promises = [];</span><br><span class="line">    <span class="keyword">if</span> (!isInfoLoaded(getState())) &#123;</span><br><span class="line">      promises.push(dispatch(loadInfo()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isAuthLoaded(getState())) &#123;</span><br><span class="line">      promises.push(dispatch(loadAuth()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;])</span><br><span class="line">@connect(</span><br><span class="line">  state =&gt; (&#123;<span class="attr">user</span>: state.auth.user&#125;),</span><br><span class="line">  &#123;logout, <span class="attr">pushState</span>: push&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>src/server.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loadOnServer(&#123;...renderProps, store, <span class="attr">helpers</span>: &#123;client&#125;&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> component = (</span><br><span class="line">    &lt;Provider store=&#123;store&#125; key=<span class="string">"provider"</span>&gt;</span><br><span class="line">      &lt;ReduxAsyncConnect &#123;...renderProps&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  res.status(200);</span></span><br><span class="line"><span class="regexp">  global.navigator = &#123;userAgent: req.headers['user-agent']&#125;;</span></span><br><span class="line"><span class="regexp">  res.send('&lt;!doctype html&gt;\n' +</span></span><br><span class="line"><span class="regexp">    ReactDOM.renderToString(&lt;Html assets=&#123;webpackIsomorphicTools.assets()&#125; component=&#123;component&#125; store=&#123;store&#125;/</span>&gt;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们看到：</p>
<ul>
<li>作者使用redux-async-connect将container和一个promise绑定，这个promise执行多个<code>dispatch()</code>调用，当它们返回的promise都resolve时才resolve自身。</li>
<li>服务端通过调用已经绑定的<code>loadOnServer()</code>方法得到上述的这个promise，从而可以直接在<code>.then()</code>中填写该promise执行完成后的同步渲染逻辑。</li>
<li>之所以能够这么做，还是依赖于redux-thunk的<code>store.dispatch()</code>调用能够返回异步任务对应的promise。</li>
</ul>
<h2 id="使用redux-saga的场景"><a href="#使用redux-saga的场景" class="headerlink" title="使用redux-saga的场景"></a>使用redux-saga的场景</h2><p>然而，对于业务逻辑逐渐复杂的Web APP，redux-thunk或许不能满足复杂的数据流场景。现在国内最流行的Effects方案莫过于  <a href="https://github.com/yelouafi/redux-saga" target="_blank" rel="noopener">redux-saga</a> 了。</p>
<p>redux-saga使得异步effects完全脱离于原生Redux数据流，没有Async Action creator（你甚至不需要多余的Action Creator）。Saga effects更像是运行于另一个线程的一组任务（除了Web Worker外目前客户端JavaScript还没有真正意义上的多线程），这些任务可以监听特定的action，并在不直接影响Redux数据流的前提下执行异步操作。</p>
<p>因为redux-saga的这些优点，使得它可以实现更复杂的异步数据流，保留更纯净的原生Redux流，这非常优雅。而正因如此，它不会对<code>store.dispatch()</code>的返回值做任何更改——这意味着，在服务端我们不能指望仅仅通过<code>store.dispatch()</code>就能获知我们的初始数据何时到达。</p>
<p>这时我想到了参考已有的、使用redux-saga的同构脚手架。</p>
<h3 id="dva提供的同构脚手架"><a href="#dva提供的同构脚手架" class="headerlink" title="dva提供的同构脚手架"></a>dva提供的同构脚手架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> ——蚂蚁金服推出的一个轻量级框架，基于redux、redux-saga和react-router，让你能够使用类似 <a href="http://elm-lang.org" target="_blank" rel="noopener">elm-lang</a> 的声明性风格来组织你的代码。</p>
<p>dva官方提供的同构脚手架是 <a href="https://github.com/sorrycc/dva-boilerplate-isomorphic" target="_blank" rel="noopener">sorrycc/dva-boilerplate-isomorphic</a> 。让我们来看看它是怎么解决saga在服务端下的渲染的。<br><em>server/ssrMiddleware.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchList &#125; <span class="keyword">from</span> <span class="string">'../common/services/user'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fetchList()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; err, data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = &#123; <span class="attr">user</span>: data &#125;;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">      history: createMemoryHistory(),</span><br><span class="line">      initialState,</span><br><span class="line">    &#125;, <span class="comment">/* isServer */</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> html = renderToString(app.start()(&#123; renderProps &#125;));</span><br><span class="line">    res.end(renderFullPage(html, initialState));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>common/services/user.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'../utils/request'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">'/api/users'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里，相信大家都明白了。dva在这里的服务端逻辑是“直捅Service”的。dva的官方脚手架并没有解决我们的问题。</p>
<h3 id="官方建议的runSaga"><a href="#官方建议的runSaga" class="headerlink" title="官方建议的runSaga()"></a>官方建议的runSaga()</h3><p>事实上，对于redux-saga的服务端渲染问题，早就有关于这个的讨论，参考 <a href="https://github.com/yelouafi/redux-saga/issues/13" target="_blank" rel="noopener">issue #13</a> 。而redux-saga已添加了 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#runsagaiterator-options" target="_blank" rel="noopener">runSaga()</a> 方法来实现在服务端复用saga effects。</p>
<p><code>runSaga()</code>接收一个<code>saga</code>对象和必须的store输入输出方法（<code>subscribe()</code>和<code>dispatch()</code>等），允许在store上下文之外执行一个saga任务，并返回一个<code>Task</code>实例对象。返回的<code>Task</code>对象中的<code>done</code>属性是一个promise对象的引用，该promise在传入的saga任务执行完成后resolve。</p>
<p>假设我们有这样的一个saga effect：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.getTodos);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get/success'</span>, payload &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于我们可以获得store上下文和<code>sagaMiddleware</code>，在这里我们可以直接使用<code>sagaMiddleware.run()</code>来代替<code>runSaga()</code>。<code>sagaMiddleware.run()</code>同样返回对应这个saga任务的<code>Task</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState, compose(applyMiddleware(sagaMiddleware)));</span><br><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>至此，我们貌似已经能够比较完美地在服务端复用saga effects了。</p>
<h3 id="更为复杂的saga"><a href="#更为复杂的saga" class="headerlink" title="更为复杂的saga"></a>更为复杂的saga</h3><p>如果我们的saga比较复杂呢？比如像这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loginFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> take(<span class="string">'user/login'</span>);</span><br><span class="line">    <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.login);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/login/success'</span>, payload &#125;);</span><br><span class="line">    <span class="keyword">yield</span> take(<span class="string">'user/logout'</span>);</span><br><span class="line">    <span class="keyword">yield</span> call(APIService.logout);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/logout/success'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个task是一个典型的infinite saga flow，也是redux-saga相对于其他effects所独有的特性：我们可以随心所欲地定义“看起来是阻塞”的数据流任务，来解决复杂的业务场景，而无需担心阻塞任务会对UI线程造成影响。<br>这样的死循环saga数据流在客户端用起来是很高效优雅的，但到了服务端，这将造成严重的问题——这个saga永远不会结束，因此<code>task.done.then()</code>永远不会被回调，我们无法知道我们所需的数据什么时候加载完成。</p>
<p>对于更为普遍的情况，我们是这样定义saga任务的，比如使用蚂蚁的 <a href="https://github.com/ant-design/antd-init" target="_blank" rel="noopener">ant-design/antd-init</a> 脚手架：<br><em>src/sagas/todos.js</em> 中定义了todos的saga：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; jsonResult &#125; = <span class="keyword">yield</span> call(getAll);</span><br><span class="line">  <span class="keyword">if</span> (jsonResult.data) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">'todos/get/success'</span>,</span><br><span class="line">      payload: jsonResult.data,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchTodosGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeLatest(<span class="string">'todos/get'</span>, getTodos)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fork(watchTodosGet);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span>, &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>src/sagas/index.js</em> 负责组合全部model的saga（通过<code>fork()</code>调用），并导出一个<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>.context(<span class="string">'./'</span>, <span class="literal">false</span>, /\.js$/);</span><br><span class="line"><span class="keyword">const</span> keys = context.keys().filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="string">'./index.js'</span> &amp;&amp; item !== <span class="string">'./SagaManager.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">root</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> fork(context(keys[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意这里的<code>takeLatest()</code>调用。<code>takeLatest()</code>是redux-saga的一个helper方法，而不是effect方法。参考 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#takelatestpattern-saga-args" target="_blank" rel="noopener">redux-saga API文档中的takeLatest</a>，我们可以看到<code>takeLatest()</code>是这样实现的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">takeLatest</span>(<span class="params">pattern, saga, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTask</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="keyword">yield</span> take(pattern)</span><br><span class="line">      <span class="keyword">if</span> (lastTask)</span><br><span class="line">        <span class="keyword">yield</span> cancel(lastTask)</span><br><span class="line">      lastTask = <span class="keyword">yield</span> fork(saga, ...args.concat(action))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，当我们在saga中进行了一次<code>yield takeLatest()</code>之后，实际上是<code>fork()</code>出了一个带死循环数据流的另一个saga，而这个死循环的saga当然是永远不会结束的，除非它被我们人为<code>cancel()</code>。<br>还有一个问题是关于redux-saga的fork模型：被<code>fork()</code>出来的子saga与其父saga有怎样的生命周期关联？<a href="http://yelouafi.github.io/redux-saga/docs/advanced/ForkModel.html" target="_blank" rel="noopener">redux-saga的官方文档</a> 给了我们最好的回答：</p>
<blockquote>
<p>In fact, attached forks shares the same semantics with the parallel Effect:</p>
<ul>
<li>We’re executing tasks in parallel</li>
<li>The parent will terminate after all launched tasks terminate</li>
</ul>
</blockquote>
<p>意思是，父saga只有当其所有<code>fork()</code>出来的子saga都结束后才会结束（这和操作系统的fork模型是类似的）。这意味着，因为其子saga中带有死循环流，我们的<code>rootSaga</code>也是永远不会自发结束的。这样的话，我们就 <strong>不能</strong> 这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(rootSaga);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码不会被执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们只能够直接<code>run()</code>不带死循环流的saga来获得初始数据，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这跟我们刚才提到的官方建议的方法没有任何区别。在服务端我们需要规避那些包含死循环流的saga，如<code>watchTodosGet</code>。</p>
<p>这将导致客户端和服务端出现大量的 <strong>异构</strong> ：在客户端，我们直接执行<code>rootSaga</code>，通过<code>dispatch()</code>特定的action来获取数据并同步到state；而在服务端，我们需要找到并执行可以获取到数据并且不带死循环的saga，如<code>getTodos</code>。</p>
<h3 id="使用redux-wait-for-action来搭救"><a href="#使用redux-wait-for-action来搭救" class="headerlink" title="使用redux-wait-for-action来搭救"></a>使用redux-wait-for-action来搭救</h3><p>为了将 <strong>同构</strong> 进行到底，博主写了一个Redux middleware来解决这个问题： <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="noopener">redux-wait-for-action</a> 。这个代码不到80行的middleware主要实现了：在dispatch一个action时，同时指定另外一个我们期望收到的action，<code>store.dispatch()</code>返回一个promise，当这个我们期望的action到达时，该promise将resolve。<br>这样，我们可以在服务端复用<code>rootSaga</code>而不需要关心这个<code>rootSaga</code>何时结束。同时，在服务端创建的<code>store</code>，其生命周期将在http响应完成后结束，我们甚至不需要手动<code>cancel()</code>这个看似不会自发结束的<code>rootSaga</code>——交给GC来杀死它们就行了。<br>我们不妨写一个在客户端和服务端通用的<code>configureStore()</code>方法来创建我们的<code>store</code>，并且执行我们的<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> configureStore = <span class="function">(<span class="params">initialState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">  <span class="keyword">let</span> enhancer = compose(</span><br><span class="line">    applyMiddleware(sagaMiddleware),</span><br><span class="line">    applyMiddleware(createReduxWaitForMiddleware()),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState, enhancer);</span><br><span class="line">  sagaMiddleware.run(rootSaga);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在服务端渲染逻辑中，我们只需要直接<code>dispatch()</code>这个action即可——这和在客户端获取数据的方式完全相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'todos/get'</span>,</span><br><span class="line">  [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在上面的示例代码中，我们在<code>dispatch()</code>一个action时，在这个action中增加了一个属性<code>WAIT_FOR_ACTION</code>（<code>WAIT_FOR_ACTION</code>是一个从<code>redux-wait-for-action</code>导入的ES6 Symbol对象，因此你不需担心这会污染你的action），该属性指定了另一个我们所期望的action <code>todos/get/success</code>。这个<code>store.dispatch()</code>调用返回一个promise，当action <code>todos/get/success</code>到达时，这个promise将resolve，因此我们可以在它的<code>.then()</code>中填写我们的渲染逻辑——因为这时我们所需的数据已经准备好。</p>
<p>由于redux-wait-for-action是基于等待action的，它将适用于近乎全部的effects方案（当然，对于redux-thunk和redux-promise则没有这个必要），当以后有更为流行的effects方案时，我们仍然可以使用这个middleware。<br>关于更具体的使用方法，大家可以参考 <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="noopener">README for redux-wait-for-action</a> 。</p>
<h2 id="更优雅地组织同构应用"><a href="#更优雅地组织同构应用" class="headerlink" title="更优雅地组织同构应用"></a>更优雅地组织同构应用</h2><p>以上示例都是基于在服务端进行路由判断并决策执行哪个effects的，当我们的数据模型变得多时，服务端代码将变得复杂。比如：该dispatch <code>todos/get</code>还是<code>profile/get</code>？我们需要对<code>req.url</code>进行一一判断。</p>
<p>借助react-router的<code>match()</code>方法，我们能够得到对应路由下的container组件，如果我们能在每个路由下的container组件中定义一个<code>fetchData()</code>方法来dispatch合适的action，我们就可以大大简化服务端的代码，并且可以同时在服务端和客户端都使用它来加载页面数据。</p>
<p>在每个路由节点对应的container的代码中，添加一个<code>fetchData()</code> <strong>静态</strong> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodosContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> fetchData(dispatch) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">      type: <span class="string">'todos/get'</span>,</span><br><span class="line">      [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 这个钩子方法仅会在客户端被调用</span></span><br><span class="line">    TodosContainer.fetchData(<span class="keyword">this</span>.props.dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在服务端渲染代码中，我们定义一个<code>getReduxPromise()</code>函数，这个函数抽出当前路由下对应的container组件，并调用其中的<code>fetchData()</code>方法，从而得到一个promise。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">match(&#123;history, routes, <span class="attr">location</span>: req.url&#125;, (error, redirectLocation, renderProps) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* 前面这里需要处理redirectLocation、error和renderProps为null的情况 */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">const</span> getReduxPromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> component = renderProps.components[renderProps.components.length - <span class="number">1</span>].WrappedComponent;</span><br><span class="line">    <span class="keyword">const</span> promise = component.fetchData ?</span><br><span class="line">      component.fetchData(store.dispatch) :</span><br><span class="line">      <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  getReduxPromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initStateString = <span class="built_in">JSON</span>.stringify(store.getState());</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &#123; &lt;RouterContext &#123;...renderProps&#125;/&gt; &#125;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">    res.status(200).send(renderFullPage(html, initStateString));</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p>
<p>遇到需要传递cookie或参数的情况，我们可以稍微修改一下<code>fetchData()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> fetchData(dispatch, query, cookies) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">    type: <span class="string">'todos/get'</span>,</span><br><span class="line">    [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">    query, cookies,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在服务端调用<code>fetchData()</code>时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.fetchData(store.dispatch, req.query, req.cookies);</span><br></pre></td></tr></table></figure></p>
<p>由于客户端一般不需要在XHR中显式加cookie，因此我们在客户端调用<code>fetchData()</code>时忽略<code>cookies</code>参数即可，并在<code>APIService</code>模块中做适当的判断。</p>
<p>另外，为了节省篇幅和便于理解，以上各处示例代码中均没有异常处理部分（或被去除）。在实际项目中，请务必在effects中添加<code>try-catch</code>逻辑，并在promise的处理部分添加<code>.catch()</code>异常处理方法。</p>
<h2 id="博主的脚手架"><a href="#博主的脚手架" class="headerlink" title="博主的脚手架"></a>博主的脚手架</h2><p>为了在实践中更好地理解以上所提到的最优化方案，博主写了这个脚手架，同时便于大家快速搭建同构React应用：<br><a href="https://github.com/Chion82/react-redux-universal-minimal" target="_blank" rel="noopener">react-redux-universal-minimal</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/" data-id="cjh4y6u6c001zz42hm2wsb5q9" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-chionlab-updates-dec-2016" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/chionlab-updates-dec-2016/" class="article-date">
  <time datetime="2016-12-12T03:05:29.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>早上好。本站从建立至今已将近一年，博主最近对小站进行了若干修改和调整，具体包括：</p>
<ol>
<li>新的样式主题 <em>Uzume</em> ，并保留原主题 <em>Miria</em> ，在站点顶部banner可切换主题。<ul>
<li>新主题 <em>Uzume</em> 角色是 <em>天王星うずめ</em> （天王星涡芽），出自游戏 <em>新次元ゲイム　ネプテューヌVII</em> （新次元游戏 海王星VII，PSN港区译作 <em>新次元遊戲 戰機少女VII</em> ）。Banner题图为博主亲自合成所得。</li>
<li>原主题 <em>Miria</em> 角色是 <em>赤城みりあ</em> （赤城米莉亚），出自游戏、动画和漫画 <em>アイドルマスター　シンデレラガールス</em> （偶像大师 灰姑娘女孩）系列。</li>
</ul>
</li>
<li>针对境内访问用户，对网站作了以下调整优化：<ul>
<li>新增CDN加速节点CN2( <a href="https://cn2.chionlab.moe" target="_blank" rel="noopener">https://cn2.chionlab.moe</a> )，保留原加速节点CloudFlare( <a href="https://blog.chionlab.moe">https://blog.chionlab.moe</a> )。对于境内和境外（或科学上网）用户，在访问本站时会自动切换。当然，你也可以在本站顶部手动切换CDN加速线路。</li>
<li>针对境内用户无法访问Disqus的问题，新增多说评论模块。CN2节点默认屏蔽Disqus评论模块，只保留多说评论模块；原CloudFlare节点则同时保留Disqus和多说两个评论模块。问题：多说模块请求了第三方http资源，因此在访问本站文章时浏览器可能会报安全策略warning，但不影响体验。</li>
<li>将Google Fonts的 <em>Source Code Pro</em> font face本地化，提高字体资源加载速度。</li>
</ul>
</li>
</ol>
<p>以上调整各处，除了CDN节点部署，均通过修改hexo和hexo主题源码完成，若有必要，以后将发表博文以提供修改思路和指点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/" data-id="cjh4y6u3t0008z42his66d9gv" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-tcp-keepalive-on-chrome" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/07/tcp-keepalive-on-chrome/" class="article-date">
  <time datetime="2016-11-07T11:40:07.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/tcp-keepalive-on-chrome/">TCP keepalive的探究 (2) : 浏览器的Keepalive机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上文介绍了TCP Keepalive机制以及其在linux中的编程实现，本文将继续介绍这种机制在浏览器中的运用，并以Chrome为例。</p>
<h2 id="HTTP1-1中的Connection-Keep-Alive"><a href="#HTTP1-1中的Connection-Keep-Alive" class="headerlink" title="HTTP1.1中的Connection: Keep-Alive"></a>HTTP1.1中的Connection: Keep-Alive</h2><p>在介绍Chrome对TCP Keepalive的实现之前，我们先来了解一下第七层协议HTTP1.1中的Connection字段。注意，本章节讨论的Keepalive为七层协议(HTTP1.1)中的Keep-Alive机制。</p>
<p>HTTP1.1协议头(header)中的<code>Connection</code>字段可取这两个值的其中之一：<code>keep-alive</code>, <code>close</code>。<br>该字段在请求头(request header)和响应头(response header)中都可以存在，这说明，客户端可以申请开启Keep-Alive，而服务端可以接受Keep-Alive请求，或者拒绝并在响应头中告知客户端。</p>
<h3 id="作用机理"><a href="#作用机理" class="headerlink" title="作用机理"></a>作用机理</h3><p>这里以一次完整的HTTP1.1网站访问来说明。</p>
<ol>
<li>客户端浏览器向 <code>www.bilibili.com:80</code> 建立TCP连接，并在此TCP连接上传输七层报文，请求<code>GET /index.html</code>资源，在请求头中，<code>Connection</code>置为<code>keep-alive</code>。</li>
<li>服务端向浏览器返回<code>index.html</code>的文件内容，响应报头中<code>Connection</code>置为<code>keep-alive</code>，随后，<strong>不关闭和客户端的TCP连接</strong>。</li>
<li>客户端复用该TCP连接，并请求<code>GET /style.css</code>资源，请求头置<code>Connection</code>为<code>keep-alive</code>。</li>
<li>服务器向浏览器返回<code>index.css</code>文件内容，仍然不关闭该TCP连接。</li>
<li>客户端继续复用该TCP连接请求多个同域资源。</li>
<li>客户端所需的各种资源都请求完毕，但是因为客户端的最后一次资源请求头中仍置<code>Connection</code>为<code>keep-alive</code>，该TCP连接仍未被关闭。</li>
<li>如果在一段时间（通常是3分钟左右）内客户端没有使用该TCP连接请求资源，服务器可能会关闭该连接。连接被关闭后，客户端需要重新向该域建立TCP连接才能继续请求数据。</li>
</ol>
<img src="/2016/11/07/tcp-keepalive-on-chrome/http1.1.png" title="HTTP1.1的请求示意图">
<img src="/2016/11/07/tcp-keepalive-on-chrome/10.png" title="一次HTTP1.1的请求和响应报头">
<h3 id="几点细节"><a href="#几点细节" class="headerlink" title="几点细节"></a>几点细节</h3><ul>
<li><p>HTTP1.1的Keep-Alive机制仅对同域下的网络请求有效。比如，对于<code>http://www.bilibili.com/index.html</code>和<code>http://www.bilibili.com/style.css</code>这两个资源请求，浏览器能够复用其TCP连接，而对于非同域下的<code>http://space.bilibili.com/index.html</code>，则需要重新建立一次TCP连接。</p>
</li>
<li><p>服务器有权拒绝客户端的Keep-Alive请求，在响应头中置<code>Connection</code>为<code>close</code>，并在传输一次完整的响应报文后主动关闭TCP连接，在这之后，客户端如需向该域请求资源，则需重新建立TCP连接。而事实上，即使客户端和服务端都开启了Keep-Alive，服务端一般会主动关闭非活动的连接，否则会造成资源浪费。</p>
</li>
<li><p>Keep-Alive虽然可以在一定程度上通过复用TCP连接来提高页面资源加载性能，但是受HTTP1.1的max-connection限制，提高的性能很有限。很多时候，为了加快更多资源的加载，通常会使用多个不同域名的CDN。而在HTTP2中，通过二进制数据帧的方式来传输同域下多资源，可以解决这个问题。关于HTTP2的传输机制，可以参考<a href="https://segmentfault.com/a/1190000006923359" target="_blank" rel="noopener">这篇文章</a>。</p>
</li>
</ul>
<h2 id="Chrome对TCP连接的保活机制"><a href="#Chrome对TCP连接的保活机制" class="headerlink" title="Chrome对TCP连接的保活机制"></a>Chrome对TCP连接的保活机制</h2><p>上篇章节中我们熟悉了七层协议中HTTP1.1的Keep-Alive机制，本章节我们介绍Chrome对四层协议的TCP Keepalive的实现。</p>
<p><strong>Chrome何时需要启用TCP Keepalive？</strong><br>假定服务器启用了HTTP1.1 Keep-Alive，浏览器与服务器建立TCP连接，并在该TCP连接上有序地传输多个HTTP1.1七层报文，以此来请求多个资源。对于同域下，在浏览器完成一次请求并获得对应资源后，若一段时间内暂时未有新的资源请求（资源请求可能由页面JavaScript发出，如Ajax），直至下次请求发出前，该TCP连接保持空闲状态。而在这段空闲时间内，浏览器需要对该TCP连接进行保活。</p>
<p>下面我们将通过Wireshark抓包来验证。</p>
<img src="/2016/11/07/tcp-keepalive-on-chrome/9.png" title="Wireshark抓到的Chrome发出的TCP keepalive探测包">
<p>从上面的抓包结果中看到，在服务器返回完整HTTP 200报文的45秒后（Time=72），本地发出了第一个TCP Keepalive探测包并收到来自服务器的ACK。</p>
<p>这说明，Chrome对于可复用的TCP连接，采用的保活机制是TCP层（传输层）自带的Keepalive机制，通过TCP Keepalive探测包的方式实现，而不是在七层报文上自成协议来传输其它数据。</p>
<p>而实际上，由于HTTP1.1对时序和报文的约定，浏览器也不可在七层实现保活。假设，客户端在通过HTTP1.1获取一次资源后，若在这个TCP连接上发送一个<code>0x70</code>（无意义的数据，在七层实现保活的方式大多如此），服务器会在应用层接收到并缓存该数据，一段时间后客户端发送有效的HTTP请求报头，则服务端CGI应用程序收到的数据是<code>0x70</code>再接上一段HTTP请求头，这被认为是无效的HTTP报文，服务器则会返回400响应头，告知客户端这是坏的请求（Bad Request）。</p>
<p>所以，浏览器在处理HTTP1.1请求所对应的TCP连接的保活时，通过使用TCP Keepalive机制，来避免污染七层（应用层）的传输数据。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>本篇主要介绍浏览器对TCP Keepalive的运用，内容简单。结合本篇内容，作者将在下篇文章中详细说明作者在使用shadowsocks浏览web时遇到的问题、解决方案以及一点思考。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/" data-id="cjh4y6u5t001hz42hcoaky83g" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-linux-tcp-keepalive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/linux-tcp-keepalive/" class="article-date">
  <time datetime="2016-09-23T16:46:52.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/linux-tcp-keepalive/">TCP keepalive的探究 (1) : NAT和保活机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于应用层的TCP连接保活（Keepalive）机制，相信大家都听说过。对于长连接TCP保活，典型的方法是发送应用层的心跳包，但这将增加开发人员的工作量：需要专门为心跳包制定协议。而在Linux的socket通信API中，自带了TCP_KEEPALIVE的相关参数设定，通过这种方式实现TCP长连接保活，无需修改原程序的逻辑，开发人员不需要关心心跳包的实现。本系列文章将从路由器NAT原理、keepalive基本的代码实现、浏览器保活机制、存在的问题几个方面逐步深入探究。</p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>为什么要使用TCP keepalive？这得从NAT（地址转换）原理开始讲起。狭义上，NAT分为SNAT（原地址转换）和DNAT（目标地址转换），关于DNAT，有兴趣的同学可以自行查阅，本文只讨论SNAT。</p>
<p>我们都知道，路由器的最基本功能是对第三层（网络层）上的IP报文进行转发。实际上，路由器还有很关键的一个功能，这便是NAT。特别是对于ISP对普通用户链路上的路由器，NAT功能尤为重要。</p>
<p>为什么要使用NAT？原因很简单：IPv4地址非常稀缺。上网需求庞大，这使得ISP不可能为每一个入网用户都提供一个独立的公网IP，因此通常情况下，ISP会把用户接入局域网，使得多个用户共享同一个公网IP，而每一个用户各分得一个局域网内网IP。而连接公网和局域网的这台路由器，称之为网关（gateway），NAT的过程就发生在这台网关路由器上。</p>
<h3 id="三层地址转换"><a href="#三层地址转换" class="headerlink" title="三层地址转换"></a>三层地址转换</h3><p>局域网内的主机向公网发出的网络层IP报文，将经由网关被转发至公网，而在该转发过程中发生了地址转换。网关将该IP报文中的 <strong>源IP地址</strong> 从”该主机的内网IP”修改为”网关的公网IP”。</p>
<p>比如，局域网主机获得的内网IP为<code>192.168.1.100</code>，网关的公网IP为<code>210.177.63.2</code>，局域网主机向公网目标主机发出的IP报文中，源IP字段数据为<code>192.168.1.100</code>，在经过网关时，该字段数据将被修改为<code>210.177.63.2</code>。</p>
<p>为什么要这么做，相信大家已经猜到了。公网上的目标主机在收到这个IP报文后，需要知道这个IP报文的来源地址，并向该来源地址发送响应报文，但如果不经过NAT，目标主机拿到的来源地址是<code>192.168.1.100</code>，这显然是一个公网上不可访问到的私有地址，目标主机无法将响应报文发送到正确的来源主机上。开启了NAT之后，IP报文的来源地址被网关修改为<code>210.177.63.2</code>，这是一个公网地址，目标主机将向这个地址（即网关路由器的公网地址）发送响应报文。</p>
<p>但是请注意，如果这个IP报文的数据段不含传输层协议报文，而是一个pure的网络层packet，来自目标主机的响应报文是不能被网关准确转发到多台局域网主机中的其中一台的。（ICMP报文除外，其报头中有Identifier字段用于标识不同的主机或进程，网关在处理Identifier时类似于下面提到的运输层端口）</p>
<h3 id="传输层端口转换表"><a href="#传输层端口转换表" class="headerlink" title="传输层端口转换表"></a>传输层端口转换表</h3><p>在三层地址转换中，我们可以保证局域网内主机向公网发出的IP报文能顺利到达目的主机，但是从目的主机返回的IP报文却不能准确送至指定局域网主机（我们不能让网关把IP报文广播至全部局域网主机，因为这样必然会带来安全和性能问题）。为了解决这个问题，网关路由器需要借助传输层端口，通常情况下是TCP或UDP端口，由此来生成一张端口转换表。</p>
<p>让我们通过一个实例来说明端口转换表如何运作。<br>假设局域网主机A<code>192.168.1.100</code>需要与公网上的目标主机B<code>210.199.38.2:80</code>进行一次TCP通信。其中A所在局域网的网关C的公网IP地址为<code>210.177.63.2</code>。步骤如下：</p>
<p>1. 局域网主机A<code>192.168.1.100</code>发出TCP连接请求，A上的TCP端口为系统分配的<code>53600</code>。该TCP握手包中，包含源地址和端口<code>192.168.1.100:53600</code>，目的地址和端口<code>210.199.38.2:80</code>。<br>2. 网关C将该包的原地址和端口修改为<code>210.177.63.2:63000</code>，其中<code>63000</code>是网关分配的临时端口。<br>3. 网关C在端口转换表中增加一条记录：</p>
<table>
<thead>
<tr>
<th>内网主机IP</th>
<th>内网主机端口</th>
<th>网关端口</th>
<th>目的主机IP</th>
<th>目的主机端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.1.100</td>
<td>53600</td>
<td>63000</td>
<td>210.199.38.2</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>4. 网关C将修改后的TCP包发送至目的主机B。<br>5. 目的主机B收到后，发送响应TCP包。该响应TCP包含有以下信息：源地址和端口<code>210.199.38.2:80</code>，目的地址和端口<code>210.177.63.2:63000</code>。<br>6. 网关C收到这个来自B的响应包后，随即在端口转换表中查找记录。该记录须符合以下条件：目的主机IP==<code>210.199.38.2</code>，目的主机端口==<code>80</code>，网关端口==<code>63000</code>。<br>7. 网关C搜索到这条记录，记录显示内网主机IP为<code>192.168.1.100</code>，内网主机端口为<code>53600</code>。<br>8. 网关C将该包的目的地址和端口修改为<code>192.168.1.100:53600</code>。<br>9. 网关C随即将该修改后的TCP包转发至<code>192.168.1.100:53600</code>，即局域网主机A。此时运输层数据的一次交换已完成。</p>
<h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>在网关C上，由于端口数量有限（0~65535），端口转换表的维护占用系统资源，因此不能无休止地向端口转换表中增加记录。对于过期的记录，网关需要将其删除。如何判断哪些是过期记录？网关认为，一段时间内无活动的连接是过期的，应定时检测转换表中的非活动连接，并将之丢弃。<strong>而这个丢弃的过程，网关不会以任何的方式通告该连接的任何一端。</strong></p>
<p>那么问题就来了：如果一个客户端应用程序由于业务需要，需要与服务端维持长连接（如TCP聊天程序），而如果在特别长的时间内（在博主的ISP环境下，该时间在3分钟左右），这个连接没有任何的数据交换，网关会认为这个连接过期并将这个连接从端口转换表中丢弃。该连接被丢弃时，客户端和服务端对此是完全无感知的。在连接被丢弃后，客户端将收不到服务端的数据推送，客户端发送的数据包也不能到达服务端。</p>
<h2 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h2><p>让我们使用TCP测试工具netcat来实际实验一下。</p>
<ul>
<li>在公网服务器上，使用<code>nc -l 9999</code>命令监听TCP端口<code>9999</code>。</li>
<li>在局域网主机上，使用<code>nc XX.XX.XX.XX 9999</code>命令连接到这台公网服务器的<code>9999</code>端口。</li>
<li>进行基本的双向发包测试。</li>
<li>不关闭连接，在空闲5分钟后再进行双向发包测试。</li>
</ul>
<p>在我的例子中，在双方建立TCP连接后，客户端（局域网主机）发送一行<code>hello from client</code>，服务端发送一行<code>hello from server</code>。<br>等待5分钟，然后客户端发送一行<code>test from client</code>。</p>
<p>通过wireshark在客户端主机上抓包，跟踪这个TCP连接得出如下结果：<br><img src="/2016/09/24/linux-tcp-keepalive/1.png"></p>
<p>从上图可得出：</p>
<ul>
<li>在第144秒时，通过TCP三次握手，双方建立连接。</li>
<li>随后双方各发一行hello信息，并都成功接收到ACK响应包，证明发送成功。</li>
<li>在第500秒时，客户端发送<code>test from client</code>，但是没有收到对方响应ACK，导致客户端多次重发（TCP Retransmission），但是仍然收不到ACK。</li>
</ul>
<p>在服务端上，仅能收到客户端一开始发送的<code>hello from client</code>，5分钟后客户端发送的<code>test from client</code>并不能收到：<br><img src="/2016/09/24/linux-tcp-keepalive/2.png"></p>
<p>而在服务端尝试发送<code>test from server</code>，客户端也收不到了。</p>
<p>这表明，在这空闲的5分钟内，网关路由器已经“掐断”了这个TCP连接，导致5分钟后该连接不可再用。但无论是客户端还是服务端，都不知道这个连接已经作废了，因此客户端在发包没有收到ACK后仍在尝试重发，双方的netcat进程仍然没有退出，说明了网关在掐断连接时并没有通知双方。</p>
<h2 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h2><p>如果我们的业务需要我们维持长连接，这就要避免网关“干掉”我们的长连接。解决方法就是，让网关认为我们的TCP连接是活动的。在应用层，我们可以通过定时发送心跳包的方式实现。而如果使用Linux提供的TCP_KEEPALIVE，在应用层我们可完全不关心心跳包何时发送、发送什么内容，这一切由操作系统自动管理：操作系统会在该TCP连接上定时发送探测包，探测包既能像心跳包一样起到连接保活的作用，也能自动检测连接的有效性，并自动关闭无效连接。</p>
<p>在Linux全局内核设置中，有以下三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">7200</span><br><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">75</span><br><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>tcp_keepalive_time</code>: 如果在该时间内没有数据往来，则发送探测包。</li>
<li><code>tcp_keepalive_intvl</code>: 探测包发送间隔时间。</li>
<li><code>tcp_keepalive_probes</code>: 尝试探测的次数。如果发送的探测包次数超过该值仍然没有收到对方响应，则认为连接已失效并关闭连接。</li>
</ul>
<p>TCP Keepalive默认是关闭的。要启用这个特性，需要在程序中如下设置（代码实例来自<a href="https://my.oschina.net/lvsin/blog/382904" target="_blank" rel="noopener">Linux下TCP keepalive属性的表现</a>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> keepAlive = <span class="number">1</span>; <span class="comment">// 开启keepalive属性</span></span><br><span class="line"><span class="keyword">int</span> keepIdle = <span class="number">60</span>; <span class="comment">// 如该连接在60秒内没有任何数据往来,则进行探测</span></span><br><span class="line"><span class="keyword">int</span> keepInterval = <span class="number">5</span>; <span class="comment">// 探测时发包的时间间隔为5 秒</span></span><br><span class="line"><span class="keyword">int</span> keepCount = <span class="number">3</span>; <span class="comment">// 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.</span></span><br><span class="line"></span><br><span class="line">setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span>*)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle)); <span class="comment">//对应tcp_keepalive_time</span></span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)); <span class="comment">//对应tcp_keepalive_intvl</span></span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount)); <span class="comment">//对应tcp_keepalive_probes</span></span><br></pre></td></tr></table></figure>
<p>如果省略<code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code>、<code>TCP_KEEPCNT</code>三个属性的设置，将使用上文的三个系统全局默认值。</p>
<h2 id="第二次实验"><a href="#第二次实验" class="headerlink" title="第二次实验"></a>第二次实验</h2><p>这次我们使用 <a href="https://github.com/cyberelf/netcat-keepalive" target="_blank" rel="noopener">netcat-keepalive</a> 来测试。这个Github上的开源项目在netcat的基础上加入了上述的代码。参数说明请参照README。</p>
<p>测试方法基本不变。唯一的不同之处是，客户端使用netcat-keepalive，并开启TCP Keepalive特性。</p>
<p>客户端上的测试结果和wireshark抓包记录如下：<br><img src="/2016/09/24/linux-tcp-keepalive/4.png"></p>
<p>抓包记录显示，在空闲的5分钟内，客户端每隔30秒发送一个TCP探测包（TCP Keep-Alive），并收到服务端ACK（TCP Keep-Alive ACK）。在5分钟后客户端发送<code>test from client</code>，服务端发送<code>test from server</code>，均发送成功。</p>
<p>服务端上的截图：<br><img src="/2016/09/24/linux-tcp-keepalive/6.png" title="服务端收到了来自客户端的“test from client”"></p>
<p>这证明，我们通过TCP Keepalive，成功地阻止了网关路由器丢弃我们的TCP长连接，所以我们在5分钟后仍能够使用这个长连接进行通信。</p>
<p>让我们来看看这个TCP Keep-Alive探测包是个什么东西：<br><img src="/2016/09/24/linux-tcp-keepalive/5.png"></p>
<p>由上图可看出，探测包是一个特殊的TCP包：它的长度为零，Flags位ACK置1，Options置为两个NOP，而它的端口信息和普通的TCP数据包是一样的。</p>
<p>对于服务端响应的TCP Keep-Alive ACK探测包，是由服务器操作系统发送的。实际上，在使用应用层TCP编程时，并不能收到这个探测包，所以服务端应用程序对该探测包是无感知的。</p>
<h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p>本文从NAT基本原理介绍了TCP Keepalive的原理和基本实现，在下篇文章中，我们将探究Chrome浏览器对于TCP保活的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/" data-id="cjh4y6u5j0010z42hj0qmfmwj" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-mixins-considered-harmful-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/28/mixins-considered-harmful-2/" class="article-date">
  <time datetime="2016-08-28T08:32:22.000Z" itemprop="datePublished">2016-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/28/mixins-considered-harmful-2/">mixins是有害的（Mixins Considered Harmful）［下篇］</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/2016/07/23/mixins-considered-harmful/">上篇</a></p>
<p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Facebook React: Mixins Considered Harmful</a></p>
<blockquote>
<p>Migrating from Mixins<br>Let’s make it clear that mixins are not technically deprecated. If you use React.createClass(), you may keep using them. We only say that they didn’t work well for us, and so we won’t recommend using them in the future.<br>Every section below corresponds to a mixin usage pattern that we found in the Facebook codebase. For each of them, we describe the problem and a solution that we think works better than mixins. The examples are written in ES5 but once you don’t need mixins, you can switch to ES6 classes if you’d like.<br>We hope that you find this list helpful. Please let us know if we missed important use cases so we can either amend the list or be proven wrong!</p>
</blockquote>
<h2 id="从Mixins迁移"><a href="#从Mixins迁移" class="headerlink" title="从Mixins迁移"></a>从Mixins迁移</h2><p>有一点需要说明的是，从技术上来讲，mixins不是被弃用的。如果你在使用<code>React.createClass()</code>，你可以继续使用它们。我们只是说它们对我们而言不能很好地运用，并且我们不推荐在未来中继续使用它们。下面的每一章节对应了我们在Facebook代码库中发现的mixin的使用场景。对于每种情况，我们会说明问题所在，并展示我们认为比使用mixins更好的解决方案。示例都使用ES5编写，但当你不再需要mixins时，你可以随心所欲地切换到ES6 classes。<br>我们希望你能从这个列表中得到帮助。如果我们缺漏了一些比较重要的应用场景，请告知我们，因此我们能拓展这个列表，或者证明其中的部分是错误的。</p>
<blockquote>
<p>Performance Optimizations<br>One of the most commonly used mixins is PureRenderMixin. You might be using it in some components to prevent unnecessary re-renders when the props and state are shallowly equal to the previous props and state:</p>
</blockquote>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>使用率最高的mixins之一是 <a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank" rel="noopener">PureRenderMixin</a> 。你可能正在一些组件中使用它，当props和state跟上次的值是浅层相等时，可<a href="https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">避免不必要的重渲染</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>To express the same without mixins, you can use the shallowCompare function directly instead:</p>
</blockquote>
<p>为了达到相同的效果而不使用mixins，你可以直接使用<a href="https://facebook.github.io/react/docs/shallow-compare.html" target="_blank" rel="noopener">shallowCompare</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCompare = <span class="built_in">require</span>(<span class="string">'react-addons-shallow-compare'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you use a custom mixin implementing a shouldComponentUpdate function with different algorithm, we suggest exporting just that single function from a module and calling it directly from your components.</p>
<p>We understand that more typing can be annoying. For the most common case, we plan to introduce a new base class called React.PureComponent in the next minor release. It uses the same shallow comparison as PureRenderMixin does today.</p>
</blockquote>
<p>如果你使用一个自定义的mixin，以不同的算法实现 <code>shouldComponentUpdate</code> 方法，我们建议从模块中导出该单一的方法，并在你的组件中直接调用它。<br>我们理解频繁的编码是令人不快的。对于更普遍的情况，我们计划在下一个小版本发布中引入一个新的基类<code>React.PureComponent</code>。它将使用浅层对比算法，正如今天的<code>PureRenderMixin</code>。</p>
<blockquote>
<p>Subscriptions and Side Effects<br>The second most common type of mixins that we encountered are mixins that subscribe a React component to a third-party data source. Whether this data source is a Flux Store, an Rx Observable, or something else, the pattern is very similar: the subscription is created in componentDidMount, destroyed in componentWillUnmount, and the change handler calls this.setState().</p>
</blockquote>
<h2 id="订阅和副作用"><a href="#订阅和副作用" class="headerlink" title="订阅和副作用"></a>订阅和副作用</h2><p>我们遇到的第二种最常见的mixins类型是那些用来订阅React组件到第三方数据源的mixins。无论这些数据源是一个Flux Store，还是一个Rx Observable，抑或是其他的，该模式都是相似的：订阅在<code>componentDidMount</code>中产生，在<code>componentWillUnmount</code>中被销毁，而变更处理函数将调用 <code>this.setState()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SubscriptionMixin = &#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  mixins: [SubscriptionMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Reading comments from state managed by mixin.</span></span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.state.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CommentList;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Solution</p>
<p>If there is just one component subscribed to this data source, it is fine to embed the subscription logic right into the component. Avoid premature abstractions.</p>
<p>If several components used this mixin to subscribe to a data source, a nice way to avoid repetition is to use a pattern called “higher-order components”. It can sound intimidating so we will take a closer look at how this pattern naturally emerges from the component model.</p>
</blockquote>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果只有一个组件被订阅到这个数据源，直接将订阅逻辑内嵌到该组件中不失为一个良策。避免草率的抽象。</p>
<p>如果多个组件都使用这个mixin来订阅到一个数据源，一个好的避免重复冗余的方法是使用一种被称为“<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" target="_blank" rel="noopener">高阶组件(higher-order components，又称HOC)</a>”的模式。这听起来让人生畏，所以我们将仔细分析这个模式如何自然地套用到组件模型上。</p>
<blockquote>
<p>Higher-Order Components Explained<br>Let’s forget about React for a second. Consider these two functions that add and multiply numbers, logging the results as they do that:</p>
</blockquote>
<h3 id="高阶组件的解释"><a href="#高阶组件的解释" class="headerlink" title="高阶组件的解释"></a>高阶组件的解释</h3><p>让我们暂时忘记React。想想这两个实现相加和相乘的函数，通过这样来实现记录计算结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAndLog</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = x + y;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAndLog</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = x * y;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>These two functions are not very useful but they help us demonstrate a pattern that we can later apply to components.</p>
<p>Let’s say that we want to extract the logging logic out of these functions without changing their signatures. How can we do this? An elegant solution is to write a higher-order function, that is, a function that takes a function as an argument and returns a function.</p>
<p>Again, it sounds more intimidating than it really is:</p>
</blockquote>
<p>这两个函数并不是十分有用，但它们可以帮助我们描述一个典型的模式，这个模式我们之后将把它应用到组件上。</p>
<p>假设我们想从这些函数中抽离记录逻辑而不修改它们的签名。如何做到这点？一个优雅的方案是，写一个更高阶的函数，这个更高阶的函数实际上是一个将函数作为其参数，并返回一个新函数的函数。</p>
<p>又一次，它听起来让人生畏，但实际上它是更简单的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Return a function with the same API...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... that calls the original function</span></span><br><span class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</span><br><span class="line">    <span class="comment">// ... but also logs its result!</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The withLogging higher-order function lets us write add and multiply without the logging statements, and later wrap them to get addAndLog and multiplyAndLog with exactly the same signatures as before:</p>
</blockquote>
<p>这个 <code>withLogging</code> 高阶函数让我们在实现相加和相乘逻辑时不需考虑记录逻辑，在这之后我们通过嵌套的方式来得到与之前签名一致的 <code>addAndLog</code> 和 <code>multiplyAndLog</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to writing addAndLog by hand:</span></span><br><span class="line"><span class="keyword">var</span> addAndLog = withLogging(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to writing multiplyAndLog by hand:</span></span><br><span class="line"><span class="keyword">var</span> multiplyAndLog = withLogging(multiply);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Higher-order components are a very similar pattern, but applied to components in React. We will apply this transformation from mixins in two steps.</p>
<p>As a first step, we will split our CommentList component in two, a child and a parent. The child will be only concerned with rendering the comments. The parent will set up the subscription and pass the up-to-date data to the child via props.</p>
</blockquote>
<p>高阶组件是一种非常相似的模式，只不过它是应用在React组件上的而已。我们将这种转换应用到mixins上，只需要两步即可。</p>
<p>第一步，我们将<code>CommentList</code>组件分为子和父两部分。子组件只关心渲染评论，而父组件将设置订阅，并将最新的数据通过props传递到子组件上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a child component.</span></span><br><span class="line"><span class="comment">// It only renders the comments it receives as props.</span></span><br><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Note: now reading from props rather than state.</span></span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a parent component.</span></span><br><span class="line"><span class="comment">// It subscribes to the data source and renders &lt;CommentList /&gt;.</span></span><br><span class="line"><span class="keyword">var</span> CommentListWithSubscription = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// We pass the current state as props to CommentList.</span></span><br><span class="line">    <span class="keyword">return</span> &lt;CommentList comments=&#123;this.state.comments&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = CommentListWithSubscription;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>There is just one final step left to do.</p>
<p>Remember how we made withLogging() take a function and return another function wrapping it? We can apply a similar pattern to React components.</p>
<p>We will write a new function called withSubscription(WrappedComponent). Its argument could be any React component. We will pass CommentList as WrappedComponent, but we could also apply withSubscription() to any other component in our codebase.</p>
<p>This function would return another component. The returned component would manage the subscription and render <wrappedcomponent> with the current data.</wrappedcomponent></p>
<p>We call this pattern a “higher-order component”.</p>
<p>The composition happens at React rendering level rather than with a direct function call. This is why it doesn’t matter whether the wrapped component is defined with createClass(), as an ES6 class or a function. If WrappedComponent is a React component, the component created by withSubscription() can render it.</p>
</blockquote>
<p>只剩下最后一步了。</p>
<p>还记得我们如何使得<code>withLogging()</code>传入一个函数并返回另一个嵌套它的函数吗？我们可以将相似的模式应用到React组件上来。</p>
<p>我们将编写一个新的函数，叫做<code>withSubscription(WrappedComponent)</code>。它的参数可以是任意的React组件。我们将传递<code>CommentList</code>作为<code>WrappedComponent</code>，但我们也可以在我们的代码基中将<code>withSubscription()</code>应用到任意其他的组件上。</p>
<p>这个函数会返回另一个组件。返回的组件将会管理好订阅，并渲染包含数据的<code>&lt;WrappedComponent /&gt;</code>。</p>
<p>我们把这种模式称为一个“高阶组件”。</p>
<p>这种合成发生在React的渲染层，而不是通过一个直接的函数调用。这就是为什么无论内嵌的组件是由<code>createClass()</code>创建的，还是由ES6 class生成的，抑或是一个函数，都无关紧要了。如果<code>WrappedComponent</code>是一个React组件，通过<code>withSubscription()</code>创建的组件都能渲染它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes a component...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...and returns another component...</span></span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ... that takes care of the subscription...</span></span><br><span class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ... and renders the wrapped component with the fresh data!</span></span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent comments=&#123;this.state.comments&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we can declare CommentListWithSubscription by applying withSubscription to CommentList:</p>
</blockquote>
<p>现在我们可以通过应用<code>withSubscription</code>到<code>CommentList</code>上来声明<code>CommentListWithSubscription</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// withSubscription() returns a new component that</span></span><br><span class="line"><span class="comment">// is subscribed to the data source and renders</span></span><br><span class="line"><span class="comment">// &lt;CommentList /&gt; with up-to-date data.</span></span><br><span class="line"><span class="keyword">var</span> CommentListWithSubscription = withSubscription(CommentList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The rest of the app is interested in the subscribed component</span></span><br><span class="line"><span class="comment">// so we export it instead of the original unwrapped CommentList.</span></span><br><span class="line"><span class="built_in">module</span>.exports = CommentListWithSubscription;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Solution, Revisited<br>Now that we understand higher-order components better, let’s take another look at the complete solution that doesn’t involve mixins. There are a few minor changes that are annotated with inline comments:</p>
</blockquote>
<h3 id="解决方案，重现"><a href="#解决方案，重现" class="headerlink" title="解决方案，重现"></a>解决方案，重现</h3><p>现在我们能更好的理解高阶组件了，让我们来再看一次完整的、无需涉及mixins的解决方案。内联的注释有少量修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Use JSX spread syntax to pass all props and state down automatically.</span></span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Optional change: convert CommentList to a functional component</span><br><span class="line">// because it doesn't use lifecycle hooks or state.</span><br><span class="line">function CommentList(props) &#123;</span><br><span class="line">  var comments = props.comments;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;comments.map(function(comment) &#123;</span><br><span class="line">        return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Instead of declaring CommentListWithSubscription,</span><br><span class="line">// we export the wrapped component right away.</span><br><span class="line">module.exports = withSubscription(CommentList);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Higher-order components are a powerful pattern. You can pass additional arguments to them if you want to further customize their behavior. After all, they are not even a feature of React. They are just functions that receive components and return components that wrap them.</p>
<p>Like any solution, higher-order components have their own pitfalls. For example, if you heavily use refs, you might notice that wrapping something into a higher-order component changes the ref to point to the wrapping component. In practice we discourage using refs for component communication so we don’t think it’s a big issue. In the future, we might consider adding ref forwarding to React to solve this annoyance.</p>
</blockquote>
<p>高阶组件是一个强大的模式。你可以给它们传递更多的参数，如果你想要进一步高度定制它们的行为。毕境，它们甚至不是React的特性之一。它们只是接受传入组件，并返回嵌套了传入组件的新组件的函数而已。</p>
<p>就像其它解决方案，高阶函数同样有他们的潜在风险。比如，如果你大量地使用refs（组件引用），你可能会发现，将任意组件嵌套进高阶组件里面时，内层组件的ref会被改变。在实践中我们不建议使用refs来实现组件间通信，所以我们不认为这是个大问题。在未来，我们将考虑引入ref重定向到React中来解决这个问题。</p>
<blockquote>
<p>Rendering Logic<br>The next most common use case for mixins that we discovered in our codebase is sharing rendering logic between components.</p>
<p>Here is a typical example of this pattern:</p>
</blockquote>
<h2 id="渲染逻辑"><a href="#渲染逻辑" class="headerlink" title="渲染逻辑"></a>渲染逻辑</h2><p>在我们的代码库中，我们发现的下一个常见的mixins用例是组件间渲染逻辑的共享。</p>
<p>以下是这个模式的典型例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RowMixin = &#123;</span><br><span class="line">  <span class="comment">// Called by components from render()</span></span><br><span class="line">  renderHeader: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'row-header'</span>&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.getHeaderText() <span class="comment">/* Defined by components */</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UserRow = React.createClass(&#123;</span><br><span class="line">  mixins: [RowMixin],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called by RowMixin.renderHeader()</span></span><br><span class="line">  getHeaderText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.user.fullName;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderHeader() <span class="comment">/* Defined by RowMixin */</span>&#125;</span><br><span class="line">        &lt;h2&gt;&#123;<span class="keyword">this</span>.props.user.biography&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Multiple components may be sharing RowMixin to render the header, and each of them would need to define getHeaderText().</p>
</blockquote>
<p>多个组件可能共享了<code>RowMixin</code>来渲染行头，而每个这些组件都需要定义一个<code>getHeaderText()</code>方法。</p>
<blockquote>
<p>Solution</p>
<p>If you see rendering logic inside a mixin, it’s time to extract a component!</p>
<p>Instead of RowMixin, we will define a <row> component. We will also replace the convention of defining a getHeaderText() method with the standard mechanism of top-data flow in React: passing props.</row></p>
<p>Finally, since neither of those components currently need lifecycle hooks or state, we can declare them as simple functions:</p>
</blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你看见了一个mixin里面含有渲染逻辑，那么是时候把它们抽离到组件中了！</p>
<p>我们将定义一个<code>&lt;Row&gt;</code>组件来取代<code>RowMixin</code>。我们也将会把借由定义一个<code>getHeaderText()</code>方法来实现转换的方式替换成React中标准的自顶向下数据流机制：传递props。</p>
<p>最后，因为这些组件现在都不再需要生命周期钩子和状态了，我们会把他们定义为简单的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RowHeader</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'row-header'</span>&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.text&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserRow</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;RowHeader text=&#123;props.user.fullName&#125; /&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.user.biography&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Props keep component dependencies explicit, easy to replace, and enforceable with tools like Flow and TypeScript.</p>
</blockquote>
<p>Props使得组件依赖保持显式、易于替换、对诸如Flow和TypeScript一类的工具更易执行。</p>
<blockquote>
<p>Note:</p>
<p>Defining components as functions is not required. There is also nothing wrong with using lifecycle hooks and state—they are first-class React features. We use functional components in this example because they are easier to read and we didn’t need those extra features, but classes would work just as fine.</p>
</blockquote>
<p>备注：<br>将组件定义为函数不是必需的。使用React的头等特性：生命周期钩子和状态也是没有任何错误的。我们在这个示例中使用函数式组件，因为它们可以更易于阅读，并且我们不需要那些另外的特性，但使用classes也是一样的效果。</p>
<blockquote>
<p>Context<br>Another group of mixins we discovered were helpers for providing and consuming React context. Context is an experimental unstable feature, has certain issues, and will likely change its API in the future. We don’t recommend using it unless you’re confident there is no other way of solving your problem.</p>
<p>Nevertheless, if you already use context today, you might have been hiding its usage with mixins like this:</p>
</blockquote>
<h2 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h2><p>我们发现的另外一系列mixins是提供和消费React Context的辅助器。Context是一个实验性的不稳定特性，存在确定的缺陷，而且它的API在未来可能会被改变。我们不推荐使用它，除非你十分确定没有其他方法来解决你的问题。</p>
<p>尽管如此，如果你已经使用了context，你可能把它的使用隐藏在了mixins里，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RouterMixin = &#123;</span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object.isRequired</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The mixin provides a method so that components</span></span><br><span class="line">  <span class="comment">// don't have to use the context API directly.</span></span><br><span class="line">  push: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context.router.push(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Link = React.createClass(&#123;</span><br><span class="line">  mixins: [RouterMixin],</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is defined in RouterMixin.</span></span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.props.to);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = Link;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Solution<br>We agree that hiding context usage from consuming components is a good idea until the context API stabilizes. However, we recommend using higher-order components instead of mixins for this.</p>
<p>Let the wrapping component grab something from the context, and pass it down with props to the wrapped component:</p>
</blockquote>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>在context的API稳定之前，我们认为，将context的调用在组件中隐藏起来是个好主意。不过，我们推荐使用高阶组件来取代mixins来实现这点。</p>
<p>让外层组件从context中获取数据，并通过props传递到内层组件中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    contextTypes: &#123;</span><br><span class="line">      router: React.PropTypes.object.isRequired</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// The wrapper component reads something from the context</span></span><br><span class="line">      <span class="comment">// and passes it down as a prop to the wrapped component.</span></span><br><span class="line">      <span class="keyword">var</span> router = <span class="keyword">this</span>.context.router;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; router=&#123;router&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Link = React.createClass(&#123;</span><br><span class="line">  handleClick: function(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line"></span><br><span class="line">    // The wrapped component uses props instead of context.</span><br><span class="line">    this.props.router.push(this.props.to);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;a onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Don't forget to wrap the component!</span><br><span class="line">module.exports = withRouter(Link);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>If you’re using a third party library that only provides a mixin, we encourage you to file an issue with them linking to this post so that they can provide a higher-order component instead. In the meantime, you can create a higher-order component around it yourself in exactly the same way.</p>
</blockquote>
<p>如果你在使用一个只提供mixin的第三方库，我们建议你去提交一个issue，引用本文链接，让他们去做成高阶组件。在这期间，通过完全一样的方式，你可以自己动手围绕它做一个高阶组件。</p>
<blockquote>
<p>Utility Methods<br>Sometimes, mixins are used solely to share utility functions between components:</p>
</blockquote>
<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>有时候，mixins仅仅是用作在组件间共享的通用工具函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ColorMixin = &#123;</span><br><span class="line">  getLuminance(color) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">parseInt</span>(color, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">var</span> r = (c &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> g = (c &amp; <span class="number">0x00FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> b = (c &amp; <span class="number">0x0000FF</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [ColorMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theme = <span class="keyword">this</span>.getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;theme&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Solution<br>Put utility functions into regular JavaScript modules and import them. This also makes it easier to test them or use them outside of your components:</p>
</blockquote>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>将通用的工具方法放入常规的JavaScript模块中，并引入它们。这同样使得测试和组件外调用变得简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLuminance = <span class="built_in">require</span>(<span class="string">'../utils/getLuminance'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theme = getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;theme&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Other Use Cases<br>Sometimes people use mixins to selectively add logging to lifecycle hooks in some components. In the future, we intend to provide an official DevTools API that would let you implement something similar without touching the components. However it’s still very much a work in progress. If you heavily depend on logging mixins for debugging, you might want to keep using those mixins for a little longer.</p>
<p>If you can’t accomplish something with a component, a higher-order component, or a utility module, it could be mean that React should provide this out of the box. File an issue to tell us about your use case for mixins, and we’ll help you consider alternatives or perhaps implement your feature request.</p>
<p>Mixins are not deprecated in the traditional sense. You can keep using them with React.createClass(), as we won’t be changing it further. Eventually, as ES6 classes gain more adoption and their usability problems in React are solved, we might split React.createClass() into a separate package because most people wouldn’t need it. Even in that case, your old mixins would keep working.</p>
<p>We believe that the alternatives above are better for the vast majority of cases, and we invite you to try writing React apps without using mixins.</p>
</blockquote>
<h2 id="其他用例"><a href="#其他用例" class="headerlink" title="其他用例"></a>其他用例</h2><p>有时候，人们使用mixins来向一些组件添加选择性的生命周期钩子日志记录。在未来，我们计划提供一个官方的开发工具API来实现相似功能，而无需触碰组件代码。虽然这仍有大量正在进度中的工作需要完成。如果你十分依赖日志记录mixins来调试，你可能还要继续保持使用它们一段时间。</p>
<p>如果你借助一个组件、一个高阶组件、或者一个通用模块，仍然不能完成一些事情，这意味着React应该是难以完成这样的事情的。向我们提交一个issue，告诉我们你的mixins使用场景，我们会帮助你考虑可选的方案，或者是在未来实现你的新特性请求。</p>
<p>Mixins在传统感官中不是完全抛弃的。你可以通过<code>React.createClass()</code>继续使用它们，因为我们不会在未来修改它。最终，当ES6 classes得到更广泛的采用，并且它们在React中使用上的问题得到解决时，我们也许会将<code>React.createClass()</code>分离到独立的包之中，因为大多数人不再需要它。即使是在那样的情况下，你的老mixins仍然能够继续工作。</p>
<p>我们相信，以上所提到的可选方案对于绝大多数的场景是更好的选择，我们邀请你来尝试在不使用mixins的情况下编写React应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/" data-id="cjh4y6u59000qz42hklyswd52" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-mixins-considered-harmful" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/23/mixins-considered-harmful/" class="article-date">
  <time datetime="2016-07-23T12:12:22.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/mixins-considered-harmful/">mixins是有害的（Mixins Considered Harmful）［上篇］</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Facebook React: Mixins Considered Harmful</a></p>
<blockquote>
<p>“How do I share the code between several components?” is one of the first questions that people ask when they learn React. Our answer has always been to use component composition for code reuse. You can define a component and use it in several other components.</p>
</blockquote>
<p>“我如何在多个组件（components）之间共享代码？”，这是React初学者的问题之一。我们的答案一直都是，通过组件组合的方法来实现代码复用。你可以定义一个组件，并在其它的组件中使用它。</p>
<blockquote>
<p>It is not always obvious how a certain pattern can be solved with composition. React is influenced by functional programming but it came into the field that was dominated by object-oriented libraries. It was hard for engineers both inside and outside of Facebook to give up on the patterns they were used to.</p>
</blockquote>
<p>通过组件组合的方式来解决某一种情况不总是显而易见的。React受函数式编程影响，但结果它成为了由面向对象库组成的存在。无伦是Facebook内部员工，还是非Facebook的程序员，抛弃以往的开发方式都是困难的。</p>
<blockquote>
<p>To ease the initial adoption and learning, we included certain escape hatches into React. The mixin system was one of those escape hatches, and its goal was to give you a way to reuse code between components when you aren’t sure how to solve the same problem with composition.</p>
</blockquote>
<p>为了让入门学习变得简单，我们引入了一些解决方案（原文“escape hatches”即逃生舱，此处语义为解决问题的一些trick）。Mixin系统是其中的一个方法，它的目的是，当你不知道如何通过组件组合来解决问题时，来给你一个方法来实现组件间的代码复用。</p>
<blockquote>
<p>Three years passed since React was released. The landscape has changed. Multiple view libraries now adopt a component model similar to React. Using composition over inheritance to build declarative user interfaces is no longer a novelty. We are also more confident in the React component model, and we have seen many creative uses of it both internally and in the community.<br>In this post, we will consider the problems commonly caused by mixins. Then we will suggest several alternative patterns for the same use cases. We have found those patterns to scale better with the complexity of the codebase than mixins.</p>
</blockquote>
<p>React发布后三年过去了，大环境发生了改变。大多数视图库现在都采用类似React的组件模型。通过多个组件在继承关系之上的组合来构建用户界面不再是一个新奇的方式。我们也对React的组件模型更加自信，并且在内部和社区中，都看到了许多具有创新性的使用方式。<br>在这篇文章中，我们会讨论由mixins造成的普遍问题。然后我们会提出一些同等情况下的可选替代方案。这些新的方案，在同等的代码复杂度下，比用mixins的可扩展性更好。</p>
<h2 id="为什么说Mixins不好？"><a href="#为什么说Mixins不好？" class="headerlink" title="为什么说Mixins不好？"></a>为什么说Mixins不好？</h2><blockquote>
<p>At Facebook, React usage has grown from a few components to thousands of them. This gives us a window into how people use React. Thanks to declarative rendering and top-down data flow, many teams were able to fix a bunch of bugs while shipping new features as they adopted React.</p>
</blockquote>
<p>在Facebook，React的使用从少量的组件演变成上千的组件数量。这给我们看见了人们是如何使用React的。多亏于声明性的渲染和自上而下的数据流，很多团队能够在迁移项目到React的时候修复一些bug。</p>
<blockquote>
<p>However it’s inevitable that some of our code using React gradually became incomprehensible. Occasionally, the React team would see groups of components in different projects that people were afraid to touch. These components were too easy to break accidentally, were confusing to new developers, and eventually became just as confusing to the people who wrote them in the first place. Much of this confusion was caused by mixins. At the time, I wasn’t working at Facebook but I came to the same conclusions after writing my fair share of terrible mixins.</p>
</blockquote>
<p>但是，一个很难避免的情况是，一些代码在使用了React了之后逐渐降低了可读性。有时，使用React的开发团队中会出现一些人们不太愿意去触碰的组件，而这些组件在不同的项目中被使用了。这些组件太容易意外损坏，这不但困扰了新加入的开发者，最终也困扰了一开始编写这些组件的人。这些麻烦的问题大多是由mixins造成的。在那时，我还未在Facebook工作，但在使用了一系列糟糕的mixins之后，我也能得出跟现在一样的结论。</p>
<blockquote>
<p>This doesn’t mean that mixins themselves are bad. People successfully employ them in different languages and paradigms, including some functional languages. At Facebook, we extensively use traits in Hack which are fairly similar to mixins. Nevertheless, we think that mixins are unnecessary and problematic in React codebases. Here’s why.</p>
</blockquote>
<p>这并不代表mixins都是不好的。人们成功地在不同的语言和范例中应用了mixins，其中包括了一些函数式语言。在Facebook，我们大量使用了类似mixins的一些比较hack的实现方式。我们认为mixins在React中是不再必要的，而且是非常容易出问题的。接下来讨论这是为什么。</p>
<h2 id="Mixins引入了隐性的依赖"><a href="#Mixins引入了隐性的依赖" class="headerlink" title="Mixins引入了隐性的依赖"></a>Mixins引入了隐性的依赖</h2><blockquote>
<p>Sometimes a component relies on a certain method defined in the mixin, such as getClassName(). Sometimes it’s the other way around, and mixin calls a method like renderHeader() on the component. JavaScript is a dynamic language so it’s hard to enforce or document these dependencies.<br>Mixins break the common and usually safe assumption that you can rename a state key or a method by searching for its occurrences in the component file. You might write a stateful component and then your coworker might add a mixin that reads this state. In a few months, you might want to move that state up to the parent component so it can be shared with a sibling. Will you remember to update the mixin to read a prop instead? What if, by now, other components also use this mixin?</p>
</blockquote>
<p>有时候一个组件依赖一个在mixin中定义的确定的方法，比如<code>getClassName()</code>。有时候在另一个场景下，mixin在组件上调用了一个方法，比如<code>renderHeader()</code>。JavaScript是一种动态语言，所以去强制定义或者记录这些依赖是很困难的。<br>Mixins打破了一个通用的、通常是安全的假设：你可以通过在组件源码文件中搜索的方式来重命名一个方法或者一个状态的key。你写了一个具有状态的组件，然后你的组员加入了一个mixin来读取它的状态。过了一两个月，你想把这个状态挪到父组件上，来实现跟相邻组件共享。你会记得同时更新这个mixin的代码，把它改为读取prop吗？再如果，现在还有其它组件也使用了这个mixin？</p>
<blockquote>
<p>These implicit dependencies make it hard for new team members to contribute to a codebase. A component’s render() method might reference some method that isn’t defined on the class. Is it safe to remove? Perhaps it’s defined in one of the mixins. But which one of them? You need to scroll up to the mixin list, open each of those files, and look for this method. Worse, mixins can specify their own mixins, so the search can be deep.<br>Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace.</p>
</blockquote>
<p>这些隐形的依赖使得新成员在现有代码基础上继续开发变得困难。一个组件的<code>render()</code>方法也许引用了一些不在本类中定义的方法，删除它们是否安全？也许它们定义在mixins中，但是在哪个里面呢？你需要滚动到mixin列表，打开每个mixin的源码，来找这些方法。更坏的是，mixins可以定义它们自己的mixins，所以这次查找是一次深度查找。<br>经常地，mixins还依赖其它的mixins，如果你删除其中之一，可能会波及到另外的。在这种情况下，说明数据如何在mixins流入流出就变得很棘手了，更别说画出它们之间的依赖关系图。不像组件，mixins不会构成继承链：它们是扁平化的，并在同一个命名空间中起作用。</p>
<h2 id="Mixins造成命名冲突"><a href="#Mixins造成命名冲突" class="headerlink" title="Mixins造成命名冲突"></a>Mixins造成命名冲突</h2><blockquote>
<p>There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.<br>It’s not a big deal if you control the mixin code. When you have a conflict, you can rename that method on one of the mixins. However it’s tricky because some components or other mixins may already be calling this method directly, and you need to find and fix those calls as well.</p>
</blockquote>
<p>从没有保证说任意两个mixins可以在一起使用。比如，如果<code>FluxListenerMixin</code>定义了<code>handleChange()</code>，<code>WindowSizeMixin</code>也定义了<code>handleChange()</code>，你就不能把它们拿在一块用。你也不能在你的组件中用这个名字来命名方法。<br>如果你能控制mixin的代码，那问题是不大的。当你遇到了命名冲突，你可以在其中的mixin中修改那个方法的名字。但是，如果有另外的mixins或是组件已经直接调用了这个方法，这就变得很棘手了，你需要同时找到和修复这些调用。</p>
<blockquote>
<p>If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.<br>The situation is no better for mixin authors. Even adding a new method to a mixin is always a potentially breaking change because a method with the same name might already exist on some of the components using it, either directly or through another mixin. Once written, mixins are hard to remove or change. Bad ideas don’t get refactored away because refactoring is too risky.</p>
</blockquote>
<p>如果你在使用一个第三方包的mixin时遇到了命名冲突，你就不能改它的方法名了。取而代之，你需要在你的组件中使用很蹩脚的方法名来避免冲突。<br>这样的情况对于mixin作者来说并没有好多少。加入一个新方法到mixin中总是一个潜在的风险，因为在已经使用了这个mixin的组件中，可能早就存在同名的方法了，无伦是直接调用还是通过其它mixin来调用。一旦mixins写好，就很困难去修改或者移除其中的东西。一些欠佳的实现方式得不到重构，因为重构的风险太大。</p>
<h2 id="Mixins造成滚雪球式的复杂性"><a href="#Mixins造成滚雪球式的复杂性" class="headerlink" title="Mixins造成滚雪球式的复杂性"></a>Mixins造成滚雪球式的复杂性</h2><blockquote>
<p>Even when mixins start out simple, they tend to become complex over time. The example below is based on a real scenario I’ve seen play out in a codebase.<br>A component needs some state to track mouse hover. To keep this logic reusable, you might extract handleMouseEnter(), handleMouseLeave() and isHovering() into a HoverMixin. Next, somebody needs to implement a tooltip. They don’t want to duplicate the logic in HoverMixin so they create a TooltipMixin that uses HoverMixin. TooltipMixin reads isHovering() provided by HoverMixin in its componentDidUpdate() and either shows or hides the tooltip.</p>
</blockquote>
<p>虽然mixins是从简单开始的，但它们会随着时间变得越来越复杂。下面的例子是基于一个真实的情况。<br>一个组件需要一些状态来跟踪鼠标的悬浮（hover）。为了使这个逻辑可复用，你抽取了<code>handleMouseEnter()</code>、<code>handleMouseLeave()</code>、<code>isHovering()</code>方法到一个<code>HoverMixin</code>里。接下来，有人需要实现一个悬浮提示框（tooltip）。他们不想拷贝<code>HoverMixin</code>里的逻辑代码，因此创建了一个<code>TooltipMixin</code>，这个<code>TooltipMixin</code>引用了<code>HoverMixin</code>，<code>TooltipMixin</code>在它的<code>componentDidUpdate()</code>中读取由<code>HoverMixin</code>提供的<code>isHovering()</code>来显示或者隐藏提示框。</p>
<blockquote>
<p>A few months later, somebody wants to make the tooltip direction configurable. In an effort to avoid code duplication, they add support for a new optional method called getTooltipOptions() to TooltipMixin. By this time, components that show popovers also use HoverMixin. However popovers need a different hover delay. To solve this, somebody adds support for an optional getHoverOptions() method and implements it in TooltipMixin. Those mixins are now tightly coupled.<br>This is fine while there are no new requirements. However this solution doesn’t scale well. What if you want to support displaying multiple tooltips in a single component? You can’t define the same mixin twice in a component. What if the tooltips need to be displayed automatically in a guided tour instead of on hover? Good luck decoupling TooltipMixin from HoverMixin. What if you need to support the case where the hover area and the tooltip anchor are located in different components? You can’t easily hoist the state used by mixin up into the parent component. Unlike components, mixins don’t lend themselves naturally to such changes.</p>
</blockquote>
<p>几个月后，有人想让这个提示框的弹出方向变得可配置。为了避免代码重复，他们添加了一个新的配置方法<code>getTooltipOptions()</code>到<code>TooltipMixin</code>。在这时，需要弹出浮层的组件也使用了<code>HoverMixin</code>。但是浮层需要不同的鼠标悬浮延时。为了解决这个问题，有人添加并实现了一个配置方法<code>getHoverOptions()</code>到<code>TooltipMixin</code>中。这两个mixins现在紧紧耦合在一起了。<br>如果没有新的需求，这样是没有问题的。但是这个方法的可扩展性并不强。如果你想在同一个组件里面支持显示多个提示框呢？你不能在一个组件里面定义两次同一个mixin。如果提示框需要在用户引导里自动弹出，而不是在鼠标悬浮时弹出呢？你想解耦<code>TooltipMixin</code>和<code>HoverMixin</code>？祝你好运。如果你想让鼠标悬浮点和提示框锚点在不同的组件中呢？你不能轻易地将mixin使用的状态抬升到父组件中。不像组件，mixins在遇到这些改变时并不能很自然地交付。</p>
<blockquote>
<p>Every new requirement makes the mixins harder to understand. Components using the same mixin become increasingly coupled with time. Any new capability gets added to all of the components using that mixin. There is no way to split a “simpler” part of the mixin without either duplicating the code or introducing more dependencies and indirection between mixins. Gradually, the encapsulation boundaries erode, and since it’s hard to change or remove the existing mixins, they keep getting more abstract until nobody understands how they work.<br>These are the same problems we faced building apps before React. We found that they are solved by declarative rendering, top-down data flow, and encapsulated components. At Facebook, we have been migrating our code to use alternative patterns to mixins, and we are generally happy with the results. You can read about those patterns below.</p>
</blockquote>
<p>每个新需求让mixins变得越来越难以理解。随着时间，使用同一个mixin的组件之间的耦合度变得越来越高。任何新的功能都会同时被附加到所有使用了这个mixin的组件。没有方法去分离这个mixin的“更简单”的部分，除非去拷贝其中的代码，或者在mixins之间引入更多的依赖和奇技淫巧。逐渐地，原来的封装会瓦解，并且因为更改或者移除已经存在的mixins是困难的，它们会变得更抽象，直到没人理解它们是怎么工作的。<br>这些问题跟我们在React出来之前构建应用程序时遇到的问题是一样的。我们认为这些问题可以通过声明性的渲染、自上而下的数据流和组件封装来解决。在Facebook，我们已经将代码的实现方式从mixins迁移到了取而代之的模式，并且我们对结果很乐观。你可以继续阅读来了解我们的新模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/" data-id="cjh4y6u5e000vz42h0o7tbbrf" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-openwrt-multiwan-configuration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/13/openwrt-multiwan-configuration/" class="article-date">
  <time datetime="2016-07-13T14:24:37.000Z" itemprop="datePublished">2016-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/13/openwrt-multiwan-configuration/">OpenWRT下双WAN配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>晚上好。博主前段时间因沉迷CGSS和PS4游戏，长时间未更新博客，实在不好。现在正值暑假，博主在公司实习，今晚趁未加班，写一篇早就想写的openwrt路由器干货。</p>
<p>本文讲述如何在openwrt家用智能路由器上配置双WAN带宽叠加。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>两条或更多的宽带，或者是支持单线多拨的宽带。</li>
<li>已经安装MWAN3及luci图形化配置界面（Pandorabox固件默认已安装）。</li>
</ul>
<h2 id="VLAN配置"><a href="#VLAN配置" class="headerlink" title="VLAN配置"></a>VLAN配置</h2><blockquote>
<p>什么是VLAN？VLAN是在同一物理局域网内用于划分若干个不同广播域（子网）的技术，子网内的主机可以互相通信，不同子网的主机之间不可互相通信。<br>什么是VLAN ID？用于标识每个VLAN子网的ID。<br>为什么要划分VLAN？在OpenWRT下，接口是根据VLAN划分的，每个逻辑接口（interface）可对应一个VLAN ID作为物理接口，这将在后面的步骤中体现出来。</p>
</blockquote>
<p>在openwrt的web配置页面上，进入 网络-&gt;交换机 (Network-&gt;Switch)。<br>默认情况下，已经分配的VLAN应该有1个或者2个。<br>通过插拔网线的方法，将配置页上的端口和路由器的物理RJ45接口对应上来。<br>在小米路由器mini上，默认分配如下两个vlan：<br><img src="/images/openwrt-switch-1.png" alt=""><br>其中，VLAN1用作LAN，连接了除端口4以外的所有物理端口；VLAN2是默认的WAN，只连接端口4。（此处端口4即为小米路由器mini上的蓝色WAN RJ45物理端口）<br>注意，端口状态“不关联”(untagged)，即该端口作为本VLAN成员，进行二层交换；若选择“关联”(tagged)，端口之间通信无二层交换，而是冲突广播（hub方式）。</p>
<p>选择一个端口作为第二个WAN口的端口，在现有的VLAN配置中将其设置为“关”，然后新建一个VLAN，将该端口设置为“不关联”，其他端口设置为“关”，CPU设置为“关联”。注意，小米路由器mini有一个特殊的端口7，按照原有的两个VLAN，将其设置为“关联”即可。<br>如图，博主选择端口1来作为第二个WAN端口，在VLAN1中将其设置为“关”，并在新建的VLAN3中设置其为“不关联”。<br><img src="/images/openwrt-switch-2.png" alt=""><br>保存即可。</p>
<h2 id="新建WAN接口"><a href="#新建WAN接口" class="headerlink" title="新建WAN接口"></a>新建WAN接口</h2><p>进入 网络-&gt;接口，将当前<code>WAN</code>接口更名为<code>WAN1</code>，并添加一个新接口，命名为<code>WAN2</code>。<br>在<code>WAN2</code>的配置中，设置第二条宽带的拨号方式，在“物理设置”中选择刚才添加的VLAN3（<code>eth0.3</code>）。<br><img src="/images/openwrt-interface-1.png" alt=""></p>
<p><strong>重要</strong><br>进入<code>WAN1</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为40；<br>进入<code>WAN2</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为41；</p>
<p>若有更多的WAN需要添加，方法类似，需要注意每个WAN接口的网关跃点必须不一样。</p>
<p>设置完成后，在接口总览中应该能看到两个WAN都成功获取到IP，如果是PPPoE方式，应该都已经拨号成功。<br><img src="/images/openwrt-interface-2.png" alt=""></p>
<h2 id="MWAN3配置"><a href="#MWAN3配置" class="headerlink" title="MWAN3配置"></a>MWAN3配置</h2><p>接下来需要通过MWAN3实现多WAN负载均衡。</p>
<p>进入 网络-&gt;负载均衡。</p>
<ul>
<li><p>接口配置<br>进入 配置-&gt;接口。<br>删除所有已有的默认接口。<br>添加两个接口，分别为<code>WAN1</code>，<code>WAN2</code>。<br>在接口详情的“跟踪的IP地址”中，可添加几个国内的主机IP作为检测接口是否上线的ping地址。当ping该IP多次超时后，即该接口视作下线。<br>博主的固件版本下，这个跟踪功能并不好使，经常误判断接口下线，因此我清空了跟踪的IP地址，并视作接口始终上线。<br><img src="/images/openwrt-mwan-1.png" alt=""></p>
</li>
<li><p>成员配置<br>进入 配置-&gt;成员，删除所有已有的默认成员，添加两个成员，分别命名为<code>wan_1</code>, <code>wan_2</code>。<br>成员<code>wan_1</code>设置接口为<code>WAN1</code>，跃点数1，接口比重1；<br>成员<code>wan_2</code>设置接口为<code>WAN2</code>，跃点数1，接口比重1；</p>
</li>
<li><p>策略配置<br>进入 配置-&gt;策略，添加一个策略<code>balanced</code>（或者编辑已有的<code>balanced</code>策略），使用的成员为<code>wan_1</code>, <code>wan_2</code>。</p>
</li>
<li><p>规则配置<br>进入 配置-&gt;规则，保留已有的<code>https</code>规则。如果没有<code>default_rule</code>规则，则添加一条<code>default_rule</code>规则，目标地址设置为<code>0.0.0.0/0</code>，协议选择<code>all</code>，使用的策略为<code>balanced</code>，其他留空。</p>
</li>
<li><p>保存并应用全部设置，此时应该能够实现双线负载均衡了。</p>
</li>
</ul>
<p>至此，openwrt路由器上的双WAN配置实现带宽叠加已经完成了，可以测速看看了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/" data-id="cjh4y6u5k0012z42hit0zuge6" class="article-share-link">分享</a>
      
        <a href="https://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/#gitment-comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/router/">router</a></li></ul>

    </footer>
  </div>
  
</article>





  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OSX/">OSX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/">开发笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/安卓/">安卓</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/网络/">网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/逆向/">逆向</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSX/">OSX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/front-end/">front-end</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/OSX/" style="font-size: 11.67px;">OSX</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/android/" style="font-size: 13.33px;">android</a> <a href="/tags/backend/" style="font-size: 11.67px;">backend</a> <a href="/tags/crawler/" style="font-size: 11.67px;">crawler</a> <a href="/tags/front-end/" style="font-size: 18.33px;">front-end</a> <a href="/tags/hack/" style="font-size: 13.33px;">hack</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/maintenance/" style="font-size: 18.33px;">maintenance</a> <a href="/tags/network/" style="font-size: 16.67px;">network</a> <a href="/tags/nginx/" style="font-size: 11.67px;">nginx</a> <a href="/tags/openwrt/" style="font-size: 10px;">openwrt</a> <a href="/tags/python/" style="font-size: 11.67px;">python</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/wechat/" style="font-size: 11.67px;">wechat</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近发表</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/31/full-cone-nat-with-linux-2/">Linux 内核态实现 Full Cone NAT（2）</a>
          </li>
        
          <li>
            <a href="/2018/02/09/full-cone-nat-with-linux/">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a>
          </li>
        
          <li>
            <a href="/2017/04/06/kcptun-with-fake-tcp/">kcptun-raw：应对UDP QoS，重新实现kcptun的一次尝试</a>
          </li>
        
          <li>
            <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
          </li>
        
          <li>
            <a href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
  <h3 class="widget-title">友链</h3>
  <div class="widget">
    <a href="https://www.starduster.me" target="_blank">星尘独奏曲</a><br />
    <a href="http://www.zhouchao.me" target="_blank">chao's blog</a><br />
    <a href="http://ilazycat.com" target="_blank">小黑猫菊苣的猫窝</a><br />
    <a href="https://loli.be" target="_blank">Mashiro's Blog</a><br />
    <a href="https://bismarck.moe" target="_blank">雨宫千鹤的博客</a><br />
    <a href="https://blessing.studio" target="_blank">Blessing Studio</a><br />
    <a href="https://wwww.lvmoo.com" target="_blank">凯の秘密基地</a><br />
    <a href="https://apporz.com" target="_blank">Micooz's Personal Site</a><br />
    <a href="https://stefenson.github.io" target="_blank">Stefenson's Blog</a><br />
    <a href="https://sunskyxh.github.io" target="_blank">香香鸡的小窝</a>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Chion Tang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, themed &amp; customized by Chion
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/Chion82" class="mobile-nav-link">GitHub</a>
  
    <a href="/about.html" class="mobile-nav-link">About Me</a>
  
</nav>
    
<script>
  var disqus_shortname = 'chionlab';
  if (/*window.location.hostname.indexOf('cn2') === -1*/true) {
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
  } else {
    var disqusElements = document.querySelectorAll('.disqus-comments-section, .disqus-comment-link');
    for (var i=0; i<disqusElements.length; i++) {
      disqusElements[i].style.display = 'none';
    }
  }
</script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>