<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ChionLab | 一个萌豚开发者的窝 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="ChionLab">
<meta property="og:url" content="http://blog.chionlab.moe/index.html">
<meta property="og:site_name" content="ChionLab">
<meta property="og:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChionLab">
<meta name="twitter:description" content="Chion82(Chion Tang)的技术博客，分享御宅开发者的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="ChionLab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
  
  <link href="/stylesheets/googlefonts.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    .article-duoshuo-link {
      float: right;
      margin-left: 20px;
    }
    .article-duoshuo-link:before {
      content: "\f086";
      font-family: "FontAwesome";
      padding-right: 8px;
    }
    .jc-bs3-container {
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
  <link href="/stylesheets/jquery-confirm.min.css" rel="stylesheet" type="text/css">
  <script src="/scripts/jquery-2.2.0.min.js"></script>
  <script src="/scripts/jquery-confirm.min.js"></script>
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script>
    var JS_COOKIES_DOMAIN = '.chionlab.moe';
    var JsCookies = {
      // this gets a cookie and returns the cookies value, if no cookies it returns blank ""
      get: function(c_name) {
        if (document.cookie.length > 0) {
          var c_start = document.cookie.indexOf(c_name + "=");
          if (c_start != -1) {
            c_start = c_start + c_name.length + 1;
            var c_end = document.cookie.indexOf(";", c_start);
            if (c_end == -1) {
              c_end = document.cookie.length;
            }
            return unescape(document.cookie.substring(c_start, c_end));
          }
        }
        return "";
      },

      // this sets a cookie with your given ("cookie name", "cookie value", "good for x days")
      set: function(c_name, value, expiredays) {
        var exdate = new Date();
        if (expiredays)
          exdate.setDate(exdate.getDate() + expiredays);
        document.cookie = c_name + "=" + escape(value) + "; path=/" + "; domain=" + JS_COOKIES_DOMAIN + ((expiredays == undefined) ? "" : "; expires=" + exdate.toUTCString());
      },

      // this checks to see if a cookie exists, then returns true or false
      check: function(c_name) {
        c_name = JsCookies.get(c_name);
        if (c_name != null && c_name != "") {
          return true;
        } else {
          return false;
        }
      }

    };
  </script>

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChionLab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎来到Chion82的未来道具研究所 ( ゜- ゜)つロ 乾杯~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="https://github.com/Chion82">GitHub</a>
        
          <a class="main-nav-link" href="/about.html">About Me</a>
        
        <a class="main-nav-link nav-link-switch-cdn" href="//cn2.chionlab.moe" data-domain="cn2">CN2加速</a>
        <a class="main-nav-link nav-link-switch-cdn" href="//blog.chionlab.moe" data-domain="blog">CF加速</a>

        
          <div style="clear: both;"></div>
          <style>
            .switch-theme-btn {
              opacity: 0.8 !important;
            }

            .switch-theme-btn:hover {
              opacity: 1.0 !important;
            }
          </style>
          <div>
            
              <a class="main-nav-link switch-theme-btn"
                title="uzume" href="#" style="float: left;margin-right: -10px;"
                data-css-url="/css/style.css"
                data-theme-name="uzume">
                <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                  <img style="width: 100%; height: 100%;" src="/images/theme_uzume.png" />
                </div>
              </a>
            
              <a class="main-nav-link switch-theme-btn"
                title="miria" href="#" style="float: left;margin-right: -10px;"
                data-css-url="/stylesheets/theme_miria.css"
                data-theme-name="miria">
                <div style="width:38px; height: 38px; overflow:hidden; border-radius:19px;">
                  <img style="width: 100%; height: 100%;" src="/images/theme_miria.png" />
                </div>
              </a>
            
          </div>
          <script>
            (function(){

              function switchThemeCSS(themeName, cssUrl) {
                document.querySelector('head').querySelectorAll('link[rel=stylesheet]')[1].href = cssUrl;
              }

              var switchThemeBtns = document.querySelectorAll('.switch-theme-btn');
              for (var i=0; i<switchThemeBtns.length; i++) {
                var switchThemeBtn = switchThemeBtns[i];
                (function(switchThemeBtn) {
                  switchThemeBtn.addEventListener('click', function(){
                    switchThemeCSS(switchThemeBtn.dataset.themeName, switchThemeBtn.dataset.cssUrl);
                    JsCookies.set('theme', switchThemeBtn.dataset.themeName, 30);
                  });
                })(switchThemeBtn);
              }

              var initTheme = JsCookies.get('theme');
              if (initTheme) {
                var cssUrl = document.querySelector(".switch-theme-btn[data-theme-name='" + initTheme + "']").dataset.cssUrl;
                switchThemeCSS(initTheme, cssUrl);
              }

            })();
          </script>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.chionlab.moe"></form>
      </div>
    </div>
  </div>
  <script>
    function getGeolocation(geoInfo) {
      var rootDomain = 'chionlab.moe';
      if (geoInfo.country_code === 'CN') {
        if (window.location.hostname === 'cn2' + '.' + rootDomain) {
          JsCookies.set('domain', 'cn2', 30);
          return;
        }
        $.confirm({
          title: '线路优化建议',
          content: '检测到您是境内用户，为了提高您的访问体验，是否切换到CN2线路？',
          buttons: {
            '好的': function() {
              JsCookies.set('domain', 'cn2', 30);
              window.location.href = '//' + 'cn2' + '.' + rootDomain + window.location.pathname;
            },
            '不用了': function() {
              JsCookies.set('domain', 'blog', 30);
            }
          }
        })
      } else {
        JsCookies.set('domain', 'blog', 30);
        if ('blog' + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
          window.location.href = '//' + 'blog' + '.' + rootDomain + window.location.pathname;
        }
      }
    }
    (function(){
      var rootDomain = 'chionlab.moe';

      if (!JsCookies.check('domain')) {
        var geoLocationScript = document.createElement('script');
        geoLocationScript.setAttribute('src','//freegeoip.net/json/?callback=getGeolocation');
        document.head.appendChild(geoLocationScript);
      } else {
        if (JsCookies.get('domain') + '.' + rootDomain !== window.location.hostname && window.location.hostname.indexOf('localhost') === -1) {
          window.location.href = '//' + JsCookies.get('domain') + '.' + rootDomain + window.location.pathname;
        }
      }

      var switchBtns = document.querySelectorAll('.nav-link-switch-cdn');
      for (var i=0; i<switchBtns.length; i++) {
        (function(switchBtn){
          if (switchBtn.dataset.domain === JsCookies.get('domain')) {
            switchBtn.style.display = 'none';
          }
          switchBtn.addEventListener('click', function(ev) {
            JsCookies.set('domain', switchBtn.dataset.domain);
          });
        })(switchBtns[i]);
      }
    })();
  </script>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-universal-react-app-reuse-effects-on-server-side" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/" class="article-date">
  <time datetime="2016-12-21T10:07:32.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>同构 (universal/isomorphic) React应用旨在服务端（或者是网关层、中途岛层）和客户端（浏览器端）尽可能地复用UI组件的代码，以提高项目的可维护性。当同构应用引入以 <a href="https://github.com/reactjs/redux" target="_blank" rel="external">Redux</a> 为首的数据流管理、以 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="external">react-router</a> 为主的SPA前端路由后，同构应用将变得复杂：我们需要在服务端和客户端之间同步状态（store）和路由信息，并且尽可能地复用这些数据逻辑（如reducers）和路由配置。关于如何搭建这样的一个项目框架，你可以阅读 <a href="https://blog.tableflip.io/server-side-rendering-with-react-and-redux/" target="_blank" rel="external">Server Side Rendering with React and Redux</a>。</p>
<p>本文假设你已经熟悉如何搭建一个 React + Redux + react-router 的同构应用，我们来讨论Redux副作用（side effects，后面简称effects）在服务端复用的逐步尝试和实践。</p>
<h2 id="目前的典型场景"><a href="#目前的典型场景" class="headerlink" title="目前的典型场景"></a>目前的典型场景</h2><p>目前大多数React同构脚手架均不在服务端复用effects，而是通过直接调用Service模块的方式来加载数据，这使得我们可以直接获知异步任务何时完成，并在回调函数中直接执行我们的渲染逻辑。在渲染逻辑中，因为页面初始数据已经取得，从创建store到调用<code>store.getState()</code>来初始化渲染模板都是同步的，没有任何坑点，它看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">APIService.getTodos().then(<span class="function">(<span class="params">initialData</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> store = configureStore(makeInitialState(initialData));</div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</div><div class="line">  <span class="keyword">const</span> state = store.getState()</div><div class="line">  renderFullPage(html, state);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="例：universal-react-starter-kit"><a href="#例：universal-react-starter-kit" class="headerlink" title="例：universal-react-starter-kit"></a>例：universal-react-starter-kit</h3><p>以国内比较流行的脚手架 <a href="https://github.com/bodyno/universal-react-starter-kit" target="_blank" rel="external">bodyno/universal-react-starter-kit</a> 为例，其渲染部分的关键代码是这样的：<br><em>server/main.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState = <span class="keyword">await</span> router(ctx)</div><div class="line"><span class="keyword">const</span> store = createStore(initialState, memoryHistory)</div><div class="line"><span class="comment">/* ... */</span></div><div class="line">match(&#123;history, routes, <span class="attr">location</span>: ctx.req.url&#125;, <span class="keyword">async</span> (err, redirect, props) =&gt; &#123;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">  <span class="keyword">let</span> layout = &#123;</div><div class="line">      <span class="comment">/* ... */</span></div><div class="line">      &#123;<span class="attr">type</span>: <span class="string">'text/javascript'</span>, <span class="attr">innerHTML</span>: <span class="string">`___INITIAL_STATE__ = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(store.getState())&#125;</span>`</span>&#125;,</div><div class="line">      <span class="comment">/* ... */</span></div><div class="line">    ]&#125;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">  content = renderToString(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">AppContainer</span> <span class="attr">layout</span>=<span class="string">&#123;layout&#125;</span> /&gt;</span></span></div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其中 <code>await router(ctx)</code>的<code>router</code>部分代码如下：<br><em>server/router.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">    axios.get(<span class="string">'https://api.github.com/zen'</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</div><div class="line">      resolve(&#123;<span class="attr">zen</span>: &#123; <span class="attr">text</span>: [&#123;<span class="attr">text</span>: data&#125;]&#125; &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>await router(ctx)</code>在此处就是一次Service API调用。先不论这个<code>router</code>是否名不符实（可能因为是脚手架的原因。router.js应该是给开发者填入代码来实现对应不同路由调用不同的Service），这个脚手架的渲染逻辑跟上文的示例大同小异——直接调用Service模块异步取得初始数据，在回调（await）中通过全同步的方式用初始数据产生store并<code>getState()</code>，然后调用<code>renderToString()</code>渲染。</p>
<p>在服务端通过“直捅Service”的方式来获取页面初始数据，是最直接、最简单的方法。当然我们在客户端绝对不会这么做，在客户端我们会设计好同步的actions和reducers，并通过触发effects来实现异步数据获取。为了使我们的服务端代码更优雅、维护性更强、代码复用度更高，我们希望在服务端能够复用这些actions、reducers和effects。</p>
<h2 id="使用redux-thunk的场景"><a href="#使用redux-thunk的场景" class="headerlink" title="使用redux-thunk的场景"></a>使用redux-thunk的场景</h2><p>在服务端执行一个effect是很简单的，我们只需要调用在服务端和客户端间共享的<code>configureStore()</code>函数来创建一个空的store（这时你将拥有effects所必须的middleware），然后调用<code>store.dispatch()</code>来触发一个绑定了effects的action即可。难点是：程序如何得知一个异步effects已经执行完成？这样我们才能在effects完成后调用<code>store.getState()</code>来取得带初始数据的state。<br>如果你的项目所使用的effects是 <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="external">redux-thunk</a>，你可以很容易地在服务端复用它们：你只需要在thunk函数中返回一个promise即可——而这是官方建议的标准写法。这样，<code>store.dispatch()</code>可以直接返回这个promise。<br>你的async thunk action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch</span>) </span>&#123;</div><div class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</div><div class="line">    <span class="keyword">return</span> APIService.getTodos()</div><div class="line">      .then(<span class="function"><span class="params">payload</span> =&gt;</span> dispatch(&#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'todos/get/success'</span>,</div><div class="line">        payload,</div><div class="line">      &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>APIService看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> APIService = &#123;</div><div class="line">  <span class="attr">getTodos</span>: <span class="function"><span class="params">()</span> =&gt;</span> fetch(<span class="string">'/api/todos'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()),</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，在服务端的渲染逻辑，你可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</div><div class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;)</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</div><div class="line">    <span class="keyword">const</span> state = store.getState()</div><div class="line">    renderFullPage(html, state);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>另外，还有 <a href="https://github.com/acdlite/redux-promise" target="_blank" rel="external">redux-promise</a> 的effects解决方案。在服务端复用方面，redux-promise和redux-thunk极为相似，因为使用redux-promise同样可以通过<code>store.dispatch()</code>获得异步任务的promise。<br>唯一的不同之处是，当使用redux-promise时，async action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'todos/get'</span>,</div><div class="line">    <span class="attr">payload</span>: APIService.getTodos(), <span class="comment">//action.payload是一个promise</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="例：react-redux-universal-hot-example"><a href="#例：react-redux-universal-hot-example" class="headerlink" title="例：react-redux-universal-hot-example"></a>例：react-redux-universal-hot-example</h3><p>让我们来看看GitHub上stars最多的Universal React脚手架 <a href="https://github.com/erikras/react-redux-universal-hot-example" target="_blank" rel="external">erikras/react-redux-universal-hot-example</a> 是怎么解决的。<br>这个脚手架使用了 <a href="https://github.com/Rezonans/redux-async-connect" target="_blank" rel="external">redux-async-connect</a> middleware，这使得我们可以绑定一个promise给每一个container，并在服务端使用它提供的<code>loadOnServer()</code>方法获得待渲染的container的异步任务及其promise。<br><em>src/containers/App/App.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@asyncConnect([&#123;</div><div class="line">  <span class="attr">promise</span>: <span class="function">(<span class="params">&#123;store: &#123;dispatch, getState&#125;&#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> promises = [];</div><div class="line">    <span class="keyword">if</span> (!isInfoLoaded(getState())) &#123;</div><div class="line">      promises.push(dispatch(loadInfo()));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isAuthLoaded(getState())) &#123;</div><div class="line">      promises.push(dispatch(loadAuth()));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</div><div class="line">  &#125;</div><div class="line">&#125;])</div><div class="line">@connect(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">user</span>: state.auth.user&#125;),</div><div class="line">  &#123;logout, <span class="attr">pushState</span>: push&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>src/server.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">loadOnServer(&#123;...renderProps, store, <span class="attr">helpers</span>: &#123;client&#125;&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> component = (</div><div class="line">    &lt;Provider store=&#123;store&#125; key="provider"&gt;</div><div class="line">      &lt;ReduxAsyncConnect &#123;...renderProps&#125; /&gt;</div><div class="line">    &lt;/Provider&gt;</div><div class="line">  );</div><div class="line">  res.status(200);</div><div class="line">  global.navigator = &#123;userAgent: req.headers['user-agent']&#125;;</div><div class="line">  res.send('&lt;!doctype html&gt;\n' +</div><div class="line">    ReactDOM.renderToString(&lt;Html assets=&#123;webpackIsomorphicTools.assets()&#125; component=&#123;component&#125; store=&#123;store&#125;/&gt;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们看到：</p>
<ul>
<li>作者使用redux-async-connect将container和一个promise绑定，这个promise执行多个<code>dispatch()</code>调用，当它们返回的promise都resolve时才resolve自身。</li>
<li>服务端通过调用已经绑定的<code>loadOnServer()</code>方法得到上述的这个promise，从而可以直接在<code>.then()</code>中填写该promise执行完成后的同步渲染逻辑。</li>
<li>之所以能够这么做，还是依赖于redux-thunk的<code>store.dispatch()</code>调用能够返回异步任务对应的promise。</li>
</ul>
<h2 id="使用redux-saga的场景"><a href="#使用redux-saga的场景" class="headerlink" title="使用redux-saga的场景"></a>使用redux-saga的场景</h2><p>然而，对于业务逻辑逐渐复杂的Web APP，redux-thunk或许不能满足复杂的数据流场景。现在国内最流行的Effects方案莫过于  <a href="https://github.com/yelouafi/redux-saga" target="_blank" rel="external">redux-saga</a> 了。</p>
<p>redux-saga使得异步effects完全脱离于原生Redux数据流，没有Async Action creator（你甚至不需要多余的Action Creator）。Saga effects更像是运行于另一个线程的一组任务（除了Web Worker外目前客户端JavaScript还没有真正意义上的多线程），这些任务可以监听特定的action，并在不直接影响Redux数据流的前提下执行异步操作。</p>
<p>因为redux-saga的这些优点，使得它可以实现更复杂的异步数据流，保留更纯净的原生Redux流，这非常优雅。而正因如此，它不会对<code>store.dispatch()</code>的返回值做任何更改——这意味着，在服务端我们不能指望仅仅通过<code>store.dispatch()</code>就能获知我们的初始数据何时到达。</p>
<p>这时我想到了参考已有的、使用redux-saga的同构脚手架。</p>
<h3 id="dva提供的同构脚手架"><a href="#dva提供的同构脚手架" class="headerlink" title="dva提供的同构脚手架"></a>dva提供的同构脚手架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a> ——蚂蚁金服推出的一个轻量级框架，基于redux、redux-saga和react-router，让你能够使用类似 <a href="http://elm-lang.org" target="_blank" rel="external">elm-lang</a> 的声明性风格来组织你的代码。</p>
<p>dva官方提供的同构脚手架是 <a href="https://github.com/sorrycc/dva-boilerplate-isomorphic" target="_blank" rel="external">sorrycc/dva-boilerplate-isomorphic</a> 。让我们来看看它是怎么解决saga在服务端下的渲染的。<br><em>server/ssrMiddleware.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fetchList &#125; <span class="keyword">from</span> <span class="string">'../common/services/user'</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line">fetchList()</div><div class="line">  .then(<span class="function">(<span class="params">&#123; err, data &#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> initialState = &#123; <span class="attr">user</span>: data &#125;;</div><div class="line">    <span class="keyword">const</span> app = createApp(&#123;</div><div class="line">      <span class="attr">history</span>: createMemoryHistory(),</div><div class="line">      initialState,</div><div class="line">    &#125;, <span class="comment">/* isServer */</span><span class="literal">true</span>);</div><div class="line">    <span class="keyword">const</span> html = renderToString(app.start()(&#123; renderProps &#125;));</div><div class="line">    res.end(renderFullPage(html, initialState));</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p><em>common/services/user.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'../utils/request'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> request(<span class="string">'/api/users'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，相信大家都明白了。是的，dva在这里的服务端逻辑是“直捅Service”的。嗯，这不愧是一个很好的解决方法！</p>
<p>Are you kidding me? 这不是回到我们一开始就摒弃的方法吗。是的，dva的官方脚手架并没有解决我们的问题。<br>（顺便一提，dva因为过于强调 <strong>declarative</strong> 和 <strong>lightweight</strong>，而一定程度上束缚了redux-saga的灵活性，博主甚至觉得，dva没有必要采用saga的effects，thunk足矣。此处不再展开。）</p>
<h3 id="官方建议的runSaga"><a href="#官方建议的runSaga" class="headerlink" title="官方建议的runSaga()"></a>官方建议的runSaga()</h3><p>事实上，对于redux-saga的服务端渲染问题，早就有关于这个的讨论，参考 <a href="https://github.com/yelouafi/redux-saga/issues/13" target="_blank" rel="external">issue #13</a> 。而redux-saga已添加了 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#runsagaiterator-options" target="_blank" rel="external">runSaga()</a> 方法来实现在服务端复用saga effects。</p>
<p><code>runSaga()</code>接收一个<code>saga</code>对象和必须的store输入输出方法（<code>subscribe()</code>和<code>dispatch()</code>等），允许在store上下文之外执行一个saga任务，并返回一个<code>Task</code>实例对象。返回的<code>Task</code>对象中的<code>done</code>属性是一个promise对象的引用，该promise在传入的saga任务执行完成后resolve。</p>
<p>假设我们有这样的一个saga effect：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.getTodos);</div><div class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get/success'</span>, payload &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于我们可以获得store上下文和<code>sagaMiddleware</code>，在这里我们可以直接使用<code>sagaMiddleware.run()</code>来代替<code>runSaga()</code>。<code>sagaMiddleware.run()</code>同样返回对应这个saga任务的<code>Task</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</div><div class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState, compose(applyMiddleware(sagaMiddleware)));</div><div class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</div><div class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</div><div class="line">  <span class="keyword">const</span> state = store.getState();</div><div class="line">  renderFullPage(html, state);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>至此，我们貌似已经能够比较完美地在服务端复用saga effects了。</p>
<h3 id="更为复杂的saga"><a href="#更为复杂的saga" class="headerlink" title="更为复杂的saga"></a>更为复杂的saga</h3><p>如果我们的saga比较复杂呢？比如像这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loginFlow</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> take(<span class="string">'user/login'</span>);</div><div class="line">    <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.login);</div><div class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/login/success'</span>, payload &#125;);</div><div class="line">    <span class="keyword">yield</span> take(<span class="string">'user/logout'</span>);</div><div class="line">    <span class="keyword">yield</span> call(APIService.logout);</div><div class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/logout/success'</span> &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个task是一个典型的infinite saga flow，也是redux-saga相对于其他effects所独有的特性：我们可以随心所欲地定义“看起来是阻塞”的数据流任务，来解决复杂的业务场景，而无需担心阻塞任务会对UI线程造成影响。<br>这样的死循环saga数据流在客户端用起来是很高效优雅的，但到了服务端，这将造成严重的问题——这个saga永远不会结束，因此<code>task.done.then()</code>永远不会被回调，我们无法知道我们所需的数据什么时候加载完成。</p>
<p>对于更为普遍的情况，我们是这样定义saga任务的，比如使用蚂蚁的 <a href="https://github.com/ant-design/antd-init" target="_blank" rel="external">ant-design/antd-init</a> 脚手架：<br><em>src/sagas/todos.js</em> 中定义了todos的saga：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; jsonResult &#125; = <span class="keyword">yield</span> call(getAll);</div><div class="line">  <span class="keyword">if</span> (jsonResult.data) &#123;</div><div class="line">    <span class="keyword">yield</span> put(&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">'todos/get/success'</span>,</div><div class="line">      <span class="attr">payload</span>: jsonResult.data,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchTodosGet</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> takeLatest(<span class="string">'todos/get'</span>, getTodos)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> fork(watchTodosGet);</div><div class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span>, &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>src/sagas/index.js</em> 负责组合全部model的saga（通过<code>fork()</code>调用），并导出一个<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>.context(<span class="string">'./'</span>, <span class="literal">false</span>, /\.js$/);</div><div class="line"><span class="keyword">const</span> keys = context.keys().filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="string">'./index.js'</span> &amp;&amp; item !== <span class="string">'./SagaManager.js'</span>);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">root</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i ++) &#123;</div><div class="line">    <span class="keyword">yield</span> fork(context(keys[i]));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意这里的<code>takeLatest()</code>调用。<code>takeLatest()</code>是redux-saga的一个helper方法，而不是effect方法。参考 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#takelatestpattern-saga-args" target="_blank" rel="external">redux-saga API文档中的takeLatest</a>，我们可以看到<code>takeLatest()</code>是这样实现的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">takeLatest</span>(<span class="params">pattern, saga, ...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> lastTask</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">      <span class="keyword">const</span> action = <span class="keyword">yield</span> take(pattern)</div><div class="line">      <span class="keyword">if</span> (lastTask)</div><div class="line">        <span class="keyword">yield</span> cancel(lastTask)</div><div class="line">      lastTask = <span class="keyword">yield</span> fork(saga, ...args.concat(action))</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> task</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，当我们在saga中进行了一次<code>yield takeLatest()</code>之后，实际上是<code>fork()</code>出了一个带死循环数据流的另一个saga，而这个死循环的saga当然是永远不会结束的，除非它被我们人为<code>cancel()</code>。<br>还有一个问题是关于redux-saga的fork模型：被<code>fork()</code>出来的子saga与其父saga有怎样的生命周期关联？<a href="http://yelouafi.github.io/redux-saga/docs/advanced/ForkModel.html" target="_blank" rel="external">redux-saga的官方文档</a> 给了我们最好的回答：</p>
<blockquote>
<p>In fact, attached forks shares the same semantics with the parallel Effect:</p>
<ul>
<li>We’re executing tasks in parallel</li>
<li>The parent will terminate after all launched tasks terminate</li>
</ul>
</blockquote>
<p>意思是，父saga只有当其所有<code>fork()</code>出来的子saga都结束后才会结束（这和操作系统的fork模型是类似的）。这意味着，因为其子saga中带有死循环流，我们的<code>rootSaga</code>也是永远不会自发结束的。这样的话，我们就 <strong>不能</strong> 这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> task = sagaMiddleware.run(rootSaga);</div><div class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</div><div class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 这里的代码不会被执行</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们只能够直接<code>run()</code>不带死循环流的saga来获得初始数据，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</div><div class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</div><div class="line">  <span class="keyword">const</span> state = store.getState();</div><div class="line">  renderFullPage(html, state);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这跟我们刚才提到的官方建议的方法没有任何区别。在服务端我们需要规避那些包含死循环流的saga，如<code>watchTodosGet</code>。</p>
<p>这将导致客户端和服务端出现大量的 <strong>异构</strong> ：在客户端，我们直接执行<code>rootSaga</code>，通过<code>dispatch()</code>特定的action来获取数据并同步到state；而在服务端，我们需要找到并执行可以获取到数据并且不带死循环的saga，如<code>getTodos</code>。</p>
<h3 id="使用redux-wait-for-action来搭救"><a href="#使用redux-wait-for-action来搭救" class="headerlink" title="使用redux-wait-for-action来搭救"></a>使用redux-wait-for-action来搭救</h3><p>为了将 <strong>同构</strong> 进行到底，博主写了一个Redux middleware来解决这个问题： <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="external">redux-wait-for-action</a> 。这个代码不到80行的middleware主要实现了：在dispatch一个action时，同时指定另外一个我们期望收到的action，<code>store.dispatch()</code>返回一个promise，当这个我们期望的action到达时，该promise将resolve。<br>这样，我们可以在服务端复用<code>rootSaga</code>而不需要关心这个<code>rootSaga</code>何时结束。同时，在服务端创建的<code>store</code>，其生命周期将在http响应完成后结束，我们甚至不需要手动<code>cancel()</code>这个看似不会自发结束的<code>rootSaga</code>——交给GC来杀死它们就行了。<br>我们不妨写一个在客户端和服务端通用的<code>configureStore()</code>方法来创建我们的<code>store</code>，并且执行我们的<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> configureStore = <span class="function">(<span class="params">initialState</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</div><div class="line">  <span class="keyword">let</span> enhancer = compose(</div><div class="line">    applyMiddleware(sagaMiddleware),</div><div class="line">    applyMiddleware(createReduxWaitForMiddleware()),</div><div class="line">  );</div><div class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState, enhancer);</div><div class="line">  sagaMiddleware.run(rootSaga);</div><div class="line">  <span class="keyword">return</span> store;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在服务端渲染逻辑中，我们只需要直接<code>dispatch()</code>这个action即可——这和在客户端获取数据的方式完全相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</div><div class="line">store.dispatch(&#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'todos/get'</span>,</div><div class="line">  [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</div><div class="line">  <span class="keyword">const</span> state = store.getState();</div><div class="line">  renderFullPage(html, state);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的示例代码中，我们在<code>dispatch()</code>一个action时，在这个action中增加了一个属性<code>WAIT_FOR_ACTION</code>（<code>WAIT_FOR_ACTION</code>是一个从<code>redux-wait-for-action</code>导入的ES6 Symbol对象，因此你不需担心这会污染你的action），该属性指定了另一个我们所期望的action <code>todos/get/success</code>。这个<code>store.dispatch()</code>调用返回一个promise，当action <code>todos/get/success</code>到达时，这个promise将resolve，因此我们可以在它的<code>.then()</code>中填写我们的渲染逻辑——因为这时我们所需的数据已经准备好。</p>
<p>由于redux-wait-for-action是基于等待action的，它将适用于近乎全部的effects方案（当然，对于redux-thunk和redux-promise则没有这个必要），当以后有更为流行的effects方案时，我们仍然可以使用这个middleware。<br>关于更具体的使用方法，大家可以参考 <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="external">README for redux-wait-for-action</a> 。</p>
<h2 id="更优雅地组织同构应用"><a href="#更优雅地组织同构应用" class="headerlink" title="更优雅地组织同构应用"></a>更优雅地组织同构应用</h2><p>以上示例都是基于在服务端进行路由判断并决策执行哪个effects的，当我们的数据模型变得多时，服务端代码将变得复杂。比如：该dispatch <code>todos/get</code>还是<code>profile/get</code>？我们需要对<code>req.url</code>进行一一判断。</p>
<p>借助react-router的<code>match()</code>方法，我们能够得到对应路由下的container组件，如果我们能在每个路由下的container组件中定义一个<code>fetchData()</code>方法来dispatch合适的action，我们就可以大大简化服务端的代码，并且可以同时在服务端和客户端都使用它来加载页面数据。</p>
<p>在每个路由节点对应的container的代码中，添加一个<code>fetchData()</code> <strong>静态</strong> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodosContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> fetchData(dispatch) &#123;</div><div class="line">    <span class="keyword">return</span> dispatch(&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">'todos/get'</span>,</div><div class="line">      [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="comment">// 这个钩子方法仅会在客户端被调用</span></div><div class="line">    TodosContainer.fetchData(<span class="keyword">this</span>.props.dispatch);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在服务端渲染代码中，我们定义一个<code>getReduxPromise()</code>函数，这个函数抽出当前路由下对应的container组件，并调用其中的<code>fetchData()</code>方法，从而得到一个promise。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">match(&#123;history, routes, <span class="attr">location</span>: req.url&#125;, (error, redirectLocation, renderProps) =&gt; &#123;</div><div class="line">  <span class="comment">/* 前面这里需要处理redirectLocation、error和renderProps为null的情况 */</span></div><div class="line">  <span class="comment">/* ... */</span></div><div class="line">  <span class="keyword">const</span> getReduxPromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> component = renderProps.components[renderProps.components.length - <span class="number">1</span>].WrappedComponent;</div><div class="line">    <span class="keyword">const</span> promise = component.fetchData ?</div><div class="line">      component.fetchData(store.dispatch) :</div><div class="line">      <span class="built_in">Promise</span>.resolve();</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">  &#125;;</div><div class="line">  getReduxPromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> initStateString = <span class="built_in">JSON</span>.stringify(store.getState());</div><div class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">        &#123; <span class="tag">&lt;<span class="name">RouterContext</span> &#123;<span class="attr">...renderProps</span>&#125;/&gt;</span> &#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></div><div class="line">    );</div><div class="line">    res.status(200).send(renderFullPage(html, initStateString));</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>遇到需要传递cookie或参数的情况，我们可以稍微修改一下<code>fetchData()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> fetchData(dispatch, query, cookies) &#123;</div><div class="line">  <span class="keyword">return</span> dispatch(&#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'todos/get'</span>,</div><div class="line">    [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</div><div class="line">    query, cookies,</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在服务端调用<code>fetchData()</code>时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">component.fetchData(store.dispatch, req.query, req.cookies);</div></pre></td></tr></table></figure></p>
<p>由于客户端一般不需要在XHR中显式加cookie，因此我们在客户端调用<code>fetchData()</code>时忽略<code>cookies</code>参数即可，并在<code>APIService</code>模块中做适当的判断。</p>
<p>另外，为了节省篇幅和便于理解，以上各处示例代码中均没有异常处理部分（或被去除）。在实际项目中，请务必在effects中添加<code>try-catch</code>逻辑，并在promise的处理部分添加<code>.catch()</code>异常处理方法。</p>
<h2 id="博主的脚手架"><a href="#博主的脚手架" class="headerlink" title="博主的脚手架"></a>博主的脚手架</h2><p>为了在实践中更好地理解以上所提到的最优化方案，博主写了这个脚手架，同时便于大家快速搭建同构React应用：<br><a href="https://github.com/Chion82/react-redux-universal-minimal" target="_blank" rel="external">react-redux-universal-minimal</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/" data-id="cix4ir2jr002fv62hm8pc6ao0" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-universal-react-app-reuse-effects-on-server-side">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-better-way-to-bypass-gfw-with-tinc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/better-way-to-bypass-gfw-with-tinc/" class="article-date">
  <time datetime="2016-12-12T05:31:59.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/better-way-to-bypass-gfw-with-tinc/">tinc VPN+策略路由：Linux下更好的科学上网方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tinc是一个<a href="https://www.tinc-vpn.org/" target="_blank" rel="external">基于网状网络的VPN软件</a>，使用tinc架设VPN，对于远程办公、文件传输等需求都是十分方便的。<br>而作为VPN，我们同样可以通过redirect gateway的方式来实现科学上网。本文将介绍通过使用tinc VPN和配置策略路由的方式，实现Linux平台下的科学上网（国内请求不走代理，国外请求走代理）。</p>
<p>本文教程以Arch Linux和OpenWRT为例，配置思路同样适用于其他Linux发行版。</p>
<p>相比于<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/">使用shadowsocks进行科学上网</a>，tinc+策略路由有以下优势：</p>
<ul>
<li>VPN是工作在IP层（网络层）的，因此可以实现对IP层packet进行代理，比如基于ICMP的ping和traceroute命令；而shadowsocks只能代理传输层的TCP和UDP请求。</li>
<li>tincd进程和服务器间的通信是基于UDP的（对于屏蔽UDP的ISP，tinc会自动failover到TCP），而该socket数量是一直固定的，对于本地发出的需要代理的连接（无论是IP层还是传输层），可实现多路复用，大大提高性能。而shadowsocks对于每一个本地TCP连接，均需要向服务器建立一次新的TCP连接，速度十分有限。</li>
<li>shadowsocks服务器有可能因为同时打开太多的TCP连接而拒绝请求，需要几分钟才能恢复。这种拒绝有可能是在ASP的防火墙上发生的，修改vps的内核参数如<code>file-max</code>等也不能解决。博主的VPS服务器上的shadowsocks服务每隔几天就会遇到一次这样的情况。而tinc因为基于多路复用，则没有这个问题。</li>
</ul>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>要架设可用于科学上网的tinc服务，你需要拥有：</p>
<ul>
<li>一台境外的tinc服务器。你可能需要自行搭建一台tinc服务器，要求：tun/tap设备可用，操作系统为Linux发行版。</li>
<li>一台本地的Linux机器，可以是你的PC、软路由，或者是一台OpenWRT路由器，同样要求tun/tap可用。</li>
<li>确认服务器和本地机器上已安装iptables, iproute2, ipset。</li>
<li>本文非傻瓜教程，无法涵盖全部Linux发行版的操作，你需要熟悉自己所使用的发行版，如service，systemd等基本操作，遇到问题要知道如何排查。</li>
</ul>
<h2 id="tinc安装及配置"><a href="#tinc安装及配置" class="headerlink" title="tinc安装及配置"></a>tinc安装及配置</h2><p>你可以参考<a href="https://wiki.archlinux.org/index.php/Tinc" target="_blank" rel="external">Arch Linux wiki</a>来安装和配置tinc。这里博主简要介绍快速部署方法。</p>
<ol>
<li><p>在服务器和本地机器上安装tinc。</p>
<h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pacman -Syu</div><div class="line"># pacman -S tinc</div></pre></td></tr></table></figure>
<h3 id="OpenWRT"><a href="#OpenWRT" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># opkg update</div><div class="line"># opkg install tinc</div></pre></td></tr></table></figure>
</li>
<li><p>在服务器和本地机器上创建tinc配置文件夹。请替换<code>myvpn</code>为你喜欢的vpn名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># mkdir -p /etc/tinc/myvpn</div><div class="line"># mkdir /etc/tinc/myvpn/hosts</div></pre></td></tr></table></figure>
</li>
<li><p>服务端配置文件（在服务器上操作）：<br>你可以将<code>alpha</code>替换为自己喜欢的服务器标识名，下同。<br>/etc/tinc/<em>myvpn</em>/tinc.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Name = alpha</div><div class="line">Device = /dev/net/tun</div></pre></td></tr></table></figure>
<p>/etc/tinc/<em>myvpn</em>/tinc-up</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">ip link set $INTERFACE up</div><div class="line">ip addr add  192.168.100.1/32 dev $INTERFACE</div><div class="line">ip route add 192.168.100.0/24 dev $INTERFACE</div></pre></td></tr></table></figure>
<p>/etc/tinc/<em>myvpn</em>/tinc-down</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">ip route del 192.168.100.0/24 dev $INTERFACE</div><div class="line">ip addr del 192.168.100.1/32 dev $INTERFACE</div><div class="line">ip link set $INTERFACE down</div></pre></td></tr></table></figure>
<p>添加脚本执行权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># chmod +x /etc/tinc/myvpn/tinc-up</div><div class="line"># chmod +x /etc/tinc/myvpn/tinc-down</div></pre></td></tr></table></figure>
</li>
<li><p>本地机配置文件（在本地机器上操作）：<br>你可以将<code>beta</code>替换为自己喜欢的客户端标识名，下同。<br>/etc/tinc/<em>myvpn</em>/tinc.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Name = beta</div><div class="line">Device = /dev/net/tun</div><div class="line">ConnectTo = alpha</div></pre></td></tr></table></figure>
<p>/etc/tinc/<em>myvpn</em>/tinc-up</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">ip link set $INTERFACE up</div><div class="line">ip addr add  192.168.100.100/32 dev $INTERFACE</div><div class="line">ip route add 192.168.100.0/24 dev $INTERFACE</div></pre></td></tr></table></figure>
<p>/etc/tinc/<em>myvpn</em>/tinc-down</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">ip route del 192.168.100.0/24 dev $INTERFACE</div><div class="line">ip addr del 192.168.100.100/32 dev $INTERFACE</div><div class="line">ip link set $INTERFACE down</div></pre></td></tr></table></figure>
<p>添加脚本执行权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># chmod +x /etc/tinc/myvpn/tinc-up</div><div class="line"># chmod +x /etc/tinc/myvpn/tinc-down</div></pre></td></tr></table></figure>
</li>
<li><p>在服务器上建立host配置文件并生成密钥：<br>/etc/tinc/<em>myvpn</em>/hosts/<em>alpha</em> 请将<code>10.0.0.1</code>替换为服务器的公网IP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Address = 10.0.0.1</div><div class="line">Port = 655</div><div class="line">Subnet = 0.0.0.0/0</div></pre></td></tr></table></figure>
<p>生成密钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># tincd -n myvpn -K</div></pre></td></tr></table></figure>
</li>
<li><p>在本地机器上建立host配置文件并生成密钥：<br>/etc/tinc/<em>myvpn</em>/hosts/<em>beta</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Port = 655</div><div class="line">Subnet = 192.168.100.100/32</div></pre></td></tr></table></figure>
<p>生成密钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># tincd -n myvpn -K</div></pre></td></tr></table></figure>
</li>
<li><p>在服务器和本地机上交换host配置文件：<br>复制服务器上的<code>/etc/tinc/myvpn/hosts/alpha</code>到本地机器的<code>/etc/tinc/myvpn/hosts/alpha</code>。<br>复制本地机器上的<code>/etc/tinc/myvpn/hosts/beta</code>到服务器上的<code>/etc/tinc/myvpn/hosts/beta</code>。</p>
</li>
<li><p>在服务器和本地机上启动tinc服务：（先启动服务器上的）</p>
<h3 id="Arch-Linux和其他基于systemd管理的linux发行版"><a href="#Arch-Linux和其他基于systemd管理的linux发行版" class="headerlink" title="Arch Linux和其他基于systemd管理的linux发行版:"></a>Arch Linux和其他基于systemd管理的linux发行版:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl start tinc@myvpn.service</div></pre></td></tr></table></figure>
<h3 id="OpenWRT和其他发行版："><a href="#OpenWRT和其他发行版：" class="headerlink" title="OpenWRT和其他发行版："></a>OpenWRT和其他发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># tincd -n myvpn</div></pre></td></tr></table></figure>
</li>
<li><p>测试VPN是否正常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ifconfig #是否找到了myvpn接口？分配的IPv4地址是否正确？</div><div class="line">$ ping 192.168.100.1 #ping服务器</div><div class="line">$ ping 192.168.100.100 #ping客户端</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置服务器路由规则"><a href="#配置服务器路由规则" class="headerlink" title="配置服务器路由规则"></a>配置服务器路由规则</h2><p>以下操作在tinc服务器上进行：</p>
<ol>
<li><p>开启ip_forward：</p>
<h3 id="Arch-Linux："><a href="#Arch-Linux：" class="headerlink" title="Arch Linux："></a>Arch Linux：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># echo &apos;net.ipv4.ip_forward=1&apos; &gt; /etc/sysctl.d/99-ipforword.conf</div><div class="line"># sysctl --system</div></pre></td></tr></table></figure>
<h3 id="其他Linux发行版："><a href="#其他Linux发行版：" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/sysctl.conf</div></pre></td></tr></table></figure>
<p>将<code>net.ipv4.ip_forward=0</code>修改为<code>net.ipv4.ip_forward=1</code>。如果文件为空或没有这行，则添加一行<code>net.ipv4.ip_forward=1</code>即可。<br>随后运行这条命令使配置生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sysctl -p</div></pre></td></tr></table></figure>
</li>
<li><p>开启masquerade：<br>首先通过<code>ifconfig</code>命令（Arch Linux上使用<code>ip addr</code>），找出外网IP对应的接口名称。这里假设外网接口是<code>eth0</code>。<br>运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># iptables -t nat -A POSTROUTING -o eth0 -s 192.168.100.0/24 -j MASQUERADE</div></pre></td></tr></table></figure>
<p>你可以保存当前的iptables配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># iptables-save &gt; /etc/iptables/iptables.rules</div></pre></td></tr></table></figure>
<p>在Arch Linux上，需要开启<code>iptables.service</code>来实现重启后保留配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl enable iptables.service</div></pre></td></tr></table></figure>
<p>在CentOS6上，需要开启<code>iptables</code>服务来实现重启后保留配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># chkconfig iptables on</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置策略路由"><a href="#配置策略路由" class="headerlink" title="配置策略路由"></a>配置策略路由</h2><p>确认VPN架设成功，客户端和服务端能够互相ping通后，我们可以进行策略路由的配置了。<br>为了方便各位配置，博主已经写好了配置脚本。</p>
<p>以下操作在本地机器上进行：</p>
<ol>
<li><p>下载国内IP段文件，保存至<code>/etc/chn_route.list</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/chn_route.list -O /etc/chn_route.list</div></pre></td></tr></table></figure>
</li>
<li><p>下载策略路由初始化和停止脚本，保存至<code>/usr/bin/</code>目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cd /usr/bin</div><div class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/init_tinc_proxy -O init_tinc_proxy</div><div class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/stop_tinc_proxy -O stop_tinc_proxy</div><div class="line"># chmod +x init_tinc_proxy</div><div class="line"># chmod +x stop_tinc_proxy</div></pre></td></tr></table></figure>
</li>
<li><p>修改启动脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /usr/bin/init_tinc_proxy</div></pre></td></tr></table></figure>
<p>将第2行<code>VPN_SERVER=XX.XX.XX.XX</code>的<code>XX.XX.XX.XX</code>修改为tinc服务器的外网IP地址。<br>将第5行<code>VPN_INTERFACE=chionvpn</code>的<code>chionvpn</code>修改为<code>myvpn</code>，或者是刚才你自定义的vpn名称。<br>如果你的Linux发行版不是Arch Linux，请删除最后这两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#Set rp_filter</div><div class="line">echo 2 &gt; /proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</div></pre></td></tr></table></figure>
</li>
<li><p>修改停止脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /usr/bin/stop_tinc_proxy</div></pre></td></tr></table></figure>
<p>将第2行<code>VPN_INTERFACE=chionvpn</code>的<code>chionvpn</code>修改为<code>myvpn</code>，或者是刚才你自定义的vpn名称。<br>如果你的Linux发行版不是Arch Linux，请删除第7和第8行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#Restore rp_filter</div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>tinc-up</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/tinc/myvpn/tinc-up</div></pre></td></tr></table></figure>
<p>在最后一行添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/init_tinc_proxy &amp;</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>tinc-down</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/tinc/myvpn/tinc-down</div></pre></td></tr></table></figure>
<p>在第一行<code>#!/bin/sh</code><br>下方插入一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/stop_tinc_proxy</div></pre></td></tr></table></figure>
</li>
<li><p>重启tinc来测试配置是否正确：</p>
<h3 id="Arch-Linux-1"><a href="#Arch-Linux-1" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl restart tinc@myvpn.service</div></pre></td></tr></table></figure>
<h3 id="其他Linux发行版：-1"><a href="#其他Linux发行版：-1" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># tincd -n myvpn -k</div><div class="line"># tincd -n myvpn</div></pre></td></tr></table></figure>
<p>进行测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ping 172.217.27.132</div></pre></td></tr></table></figure>
<p>如果能够ping通，说明以上配置正确。</p>
</li>
</ol>
<h2 id="配置ChinaDNS和dnsmasq"><a href="#配置ChinaDNS和dnsmasq" class="headerlink" title="配置ChinaDNS和dnsmasq"></a>配置ChinaDNS和dnsmasq</h2><p>至此，我们的VPN和策略路由已经配置完成。为了避免国内DNS污染，我们需要使用<a href="https://github.com/shadowsocks/ChinaDNS" target="_blank" rel="external">ChinaDNS</a>。ChinaDNS的配置方法与之前的<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/">OpenWRT科学上网</a>类似，唯一不同处是，这里的国外上游DNS服务器我们可以直接填写<code>8.8.8.8</code>，而不需要shadowsocks的<code>ss-tunnel</code>隧道。</p>
<p>以下操作在本地机器上进行：</p>
<ol>
<li><p>安装并配置ChinaDNS</p>
<h3 id="Arch-Linux-2"><a href="#Arch-Linux-2" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># yaourt -S chinadns</div><div class="line"># cp /etc/chn_route.list /etc/chnroute.txt</div><div class="line"># system start chinadns.service</div></pre></td></tr></table></figure>
<h3 id="OpenWRT-1"><a href="#OpenWRT-1" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><p>参照<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/#安装ChinaDNS">OpenWRT科学上网 #安装ChinaDNS</a>来安装ChinaDNS，然后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cp /etc/chn_route.list /etc/chinadns_chnroute.txt</div></pre></td></tr></table></figure>
<p>进入OpenWRT管理网页，进入services-&gt;ChinaDNS，勾选<code>Enable</code>，中国路由表(CHNRoute File)填<code>/etc/chinadns_chnroute.txt</code>，设置<code>Upstream Servers</code>为：<code>114.114.114.114,8.8.8.8</code>。</p>
</li>
<li><p>配置dnsmasq</p>
<h3 id="Arch-Linux：-1"><a href="#Arch-Linux：-1" class="headerlink" title="Arch Linux："></a>Arch Linux：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># pacman -S dnsmasq</div></pre></td></tr></table></figure>
<p>修改<code>/etc/dnsmasq.conf</code>，清空文件并填入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">listen-address=127.0.0.1  #如果机器(如软路由)绑定了静态IP，请在这里加上静态IP，以逗号分割</div><div class="line"></div><div class="line">no-resolv</div><div class="line">server=127.0.0.1#5353</div></pre></td></tr></table></figure>
<p>启动dnsmasq：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl start dnsmasq.service</div></pre></td></tr></table></figure>
<p>修改本机的DNS配置，使其指向<code>127.0.0.1</code>。<br>如果你的网络配置文件管理器是<code>netctl</code>，在对应的配置文件(位于<code>/etc/netctl/</code>下)中设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DNS=(&apos;127.0.0.1&apos;)</div></pre></td></tr></table></figure>
<h3 id="OpenWRT："><a href="#OpenWRT：" class="headerlink" title="OpenWRT："></a>OpenWRT：</h3><p>进入网络(Network)-&gt;DHCP and DNS。<br>将DNS转发(DNS forwardings)设置为<code>127.0.0.1#5353</code>。<br>还要记得勾选“忽略解析文件”(ignore resolve file)。</p>
</li>
<li><p>测试<br>现在应该能够ping通谷歌域名了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ dig www.google.com</div><div class="line">$ ping www.google.com</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>如果需要在机器启动时自动开启科学上网，可按照以下步骤进行：</p>
<ol>
<li><p>自启动tinc服务，在服务器和本地机器上操作：</p>
<h3 id="Arch-Linux-3"><a href="#Arch-Linux-3" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl enable tinc@myvpn.service</div></pre></td></tr></table></figure>
<h3 id="其他Linux发行版：-2"><a href="#其他Linux发行版：-2" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><p>在 <code>/etc/rc.local</code> 脚本文件最后添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tincd -n myvpn</div></pre></td></tr></table></figure>
<p>当然，更好的方法是编写一个init服务脚本（位于<code>/etc/init.d/</code>）。</p>
</li>
<li><p>自启动ChinaDNS服务，在本地机上操作：</p>
<h3 id="Arch-Linux-4"><a href="#Arch-Linux-4" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># systemctl enable chinadns.service</div><div class="line"># systemctl enable dnsmasq.service</div></pre></td></tr></table></figure>
<h3 id="OpenWRT-2"><a href="#OpenWRT-2" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><p>不需要特别设置，ChinaDNS和dnsmasq服务在安装后默认是自启动的。</p>
</li>
</ol>
<p>至此，全部配置已经完成了，你现在可以上youtube看大新闻了。</p>
<h2 id="策略路由原理及常见问题"><a href="#策略路由原理及常见问题" class="headerlink" title="策略路由原理及常见问题"></a>策略路由原理及常见问题</h2><ol>
<li><p><code>init_tinc_proxy</code>这个脚本都做了些什么？</p>
<ul>
<li>首先，读取<code>/etc/chn_route.list</code>文件，这个文件的内容是国内IPv4的CIDR地址段。创建一个ipset集合<code>chn_route</code>，将这些国内地址段写入该集合。</li>
<li><p>添加一个路由表，id为<code>200</code>，该路由表接受全部IP段（<code>0.0.0.0/0</code>，或<code>default</code>），经由接口<code>myvpn</code>，网关（下一跳）是VPN服务器<code>192.168.100.1</code>。即执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ip route add default via 192.168.100.1 dev myvpn tabel 200</div></pre></td></tr></table></figure>
</li>
<li><p>添加一个路由规则，将MARK为<code>200</code>的IP报使用id为<code>200</code>的路由表进行路由。即执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ip rule add fwmark 200 table 200</div></pre></td></tr></table></figure>
</li>
<li><p>在iptables的mangle表增加一个自定义链<code>tinc_proxy</code>，并在该链中添加如下规则：<br>目的地址在<code>BYPASS</code>指定的例外IP段中的packet，采取<code>RETURN</code>处理；<br>目的地址在<code>chn_route</code>集合中的packet，采取<code>RETURN</code>处理；<br>恢复CONNMARK的值到MARK（CONNMARK：用于跟踪一个连接的标记值）；<br>对MARK的值为<code>0</code>的packet，设置其MARK为<code>200</code>；<br>将MARK的值保存到CONNMARK；</p>
</li>
<li>在mangle表的<code>PREROUTING</code>和<code>OUTPUT</code>链中插入自定义链<code>tinc_proxy</code></li>
<li>在nat表的<code>POSTROUTING</code>链中，对出口接口为<code>myvpn</code>的packet，采取<code>MASQUERADE</code>处理。</li>
</ul>
</li>
<li><p>为什么在Arch Linux下，需要将内核参数<code>/proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</code>设为<code>2</code>？<br><code>rp_filter</code>是<a href="http://tldp.org/HOWTO/Adv-Routing-HOWTO/lartc.kernel.rpf.html" target="_blank" rel="external">Reverse Path Filtering (反向路径过滤)</a>，其原理是：<br>内核对目的地址为本机的每个IP报文，先检查其来源地址，然后根据本机路由表，查找到该来源地址的路由（即反向路径查找），若查找到的路由对应的接口与该报文实际到达所经过的接口不相符，则抛弃该包。显然，这对基于fwmark的策略路由是不适用的，因此需要关闭反向路径过滤功能。<br>Arch Linux下默认使用严格的反向路径过滤策略，需要将该值设置为<code>2</code>。<br>而其他发行版，只需要将该值保持为默认的<code>0</code>即可。</p>
</li>
<li><p>tinc VPN架设成功后，服务器和客户端能够互相ping通，但是无法经由服务器科学上网？<br>请逐步排查，特别注意服务器的tinc host配置文件中，<code>Subnet</code>是否正确设置为<code>0.0.0.0</code>。<br>参考<a href="https://www.tinc-vpn.org/examples/redirect-gateway/" target="_blank" rel="external">Example: redirecting the default gateway to a host on the VPN</a>将全部流量都经过VPN，看看能否正常访问外网。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/" data-id="cix4ir2i6000cv62ho1x4ken3" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-better-way-to-bypass-gfw-with-tinc">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openwrt/">openwrt</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-chionlab-updates-dec-2016" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/chionlab-updates-dec-2016/" class="article-date">
  <time datetime="2016-12-12T03:05:29.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>早上好。本站从建立至今已将近一年，博主最近对小站进行了若干修改和调整，具体包括：</p>
<ol>
<li>新的样式主题 <em>Uzume</em> ，并保留原主题 <em>Miria</em> ，在站点顶部banner可切换主题。<ul>
<li>新主题 <em>Uzume</em> 角色是 <em>天王星うずめ</em> （天王星涡芽），出自游戏 <em>新次元ゲイム　ネプテューヌVII</em> （新次元游戏 海王星VII，PSN港区译作 <em>新次元遊戲 戰機少女VII</em> ）。Banner题图为博主亲自合成所得。</li>
<li>原主题 <em>Miria</em> 角色是 <em>赤城みりあ</em> （赤城米莉亚），出自游戏、动画和漫画 <em>アイドルマスター　シンデレラガールス</em> （偶像大师 灰姑娘女孩）系列。</li>
</ul>
</li>
<li>针对境内访问用户，对网站作了以下调整优化：<ul>
<li>新增CDN加速节点CN2( <a href="https://cn2.chionlab.moe" target="_blank" rel="external">https://cn2.chionlab.moe</a> )，保留原加速节点CloudFlare( <a href="https://blog.chionlab.moe">https://blog.chionlab.moe</a> )。对于境内和境外（或科学上网）用户，在访问本站时会自动切换。当然，你也可以在本站顶部手动切换CDN加速线路。</li>
<li>针对境内用户无法访问Disqus的问题，新增多说评论模块。CN2节点默认屏蔽Disqus评论模块，只保留多说评论模块；原CloudFlare节点则同时保留Disqus和多说两个评论模块。问题：多说模块请求了第三方http资源，因此在访问本站文章时浏览器可能会报安全策略warning，但不影响体验。</li>
<li>将Google Fonts的 <em>Source Code Pro</em> font face本地化，提高字体资源加载速度。</li>
</ul>
</li>
</ol>
<p>以上调整各处，除了CDN节点部署，均通过修改hexo和hexo主题源码完成，若有必要，以后将发表博文以提供修改思路和指点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/" data-id="cix4ir2hz0007v62he5p2ua9i" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-chionlab-updates-dec-2016">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-tcp-keepalive-on-chrome" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/07/tcp-keepalive-on-chrome/" class="article-date">
  <time datetime="2016-11-07T11:40:07.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/tcp-keepalive-on-chrome/">TCP keepalive的探究 (2) : 浏览器的Keepalive机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上文介绍了TCP Keepalive机制以及其在linux中的编程实现，本文将继续介绍这种机制在浏览器中的运用，并以Chrome为例。</p>
<h2 id="HTTP1-1中的Connection-Keep-Alive"><a href="#HTTP1-1中的Connection-Keep-Alive" class="headerlink" title="HTTP1.1中的Connection: Keep-Alive"></a>HTTP1.1中的Connection: Keep-Alive</h2><p>在介绍Chrome对TCP Keepalive的实现之前，我们先来了解一下第七层协议HTTP1.1中的Connection字段。注意，本章节讨论的Keepalive为七层协议(HTTP1.1)中的Keep-Alive机制。</p>
<p>HTTP1.1协议头(header)中的<code>Connection</code>字段可取这两个值的其中之一：<code>keep-alive</code>, <code>close</code>。<br>该字段在请求头(request header)和响应头(response header)中都可以存在，这说明，客户端可以申请开启Keep-Alive，而服务端可以接受Keep-Alive请求，或者拒绝并在响应头中告知客户端。</p>
<h3 id="作用机理"><a href="#作用机理" class="headerlink" title="作用机理"></a>作用机理</h3><p>这里以一次完整的HTTP1.1网站访问来说明。</p>
<ol>
<li>客户端浏览器向 <code>www.bilibili.com:80</code> 建立TCP连接，并在此TCP连接上传输七层报文，请求<code>GET /index.html</code>资源，在请求头中，<code>Connection</code>置为<code>keep-alive</code>。</li>
<li>服务端向浏览器返回<code>index.html</code>的文件内容，响应报头中<code>Connection</code>置为<code>keep-alive</code>，随后，<strong>不关闭和客户端的TCP连接</strong>。</li>
<li>客户端复用该TCP连接，并请求<code>GET /style.css</code>资源，请求头置<code>Connection</code>为<code>keep-alive</code>。</li>
<li>服务器向浏览器返回<code>index.css</code>文件内容，仍然不关闭该TCP连接。</li>
<li>客户端继续复用该TCP连接请求多个同域资源。</li>
<li>客户端所需的各种资源都请求完毕，但是因为客户端的最后一次资源请求头中仍置<code>Connection</code>为<code>keep-alive</code>，该TCP连接仍未被关闭。</li>
<li>如果在一段时间（通常是3分钟左右）内客户端没有使用该TCP连接请求资源，服务器可能会关闭该连接。连接被关闭后，客户端需要重新向该域建立TCP连接才能继续请求数据。</li>
</ol>
<img src="/2016/11/07/tcp-keepalive-on-chrome/http1.1.png" alt="HTTP1.1的请求示意图" title="HTTP1.1的请求示意图">
<img src="/2016/11/07/tcp-keepalive-on-chrome/10.png" alt="一次HTTP1.1的请求和响应报头" title="一次HTTP1.1的请求和响应报头">
<h3 id="几点细节"><a href="#几点细节" class="headerlink" title="几点细节"></a>几点细节</h3><ul>
<li><p>HTTP1.1的Keep-Alive机制仅对同域下的网络请求有效。比如，对于<code>http://www.bilibili.com/index.html</code>和<code>http://www.bilibili.com/style.css</code>这两个资源请求，浏览器能够复用其TCP连接，而对于非同域下的<code>http://space.bilibili.com/index.html</code>，则需要重新建立一次TCP连接。</p>
</li>
<li><p>服务器有权拒绝客户端的Keep-Alive请求，在响应头中置<code>Connection</code>为<code>close</code>，并在传输一次完整的响应报文后主动关闭TCP连接，在这之后，客户端如需向该域请求资源，则需重新建立TCP连接。而事实上，即使客户端和服务端都开启了Keep-Alive，服务端一般会主动关闭非活动的连接，否则会造成资源浪费。</p>
</li>
<li><p>Keep-Alive虽然可以在一定程度上通过复用TCP连接来提高页面资源加载性能，但是受HTTP1.1的max-connection限制，提高的性能很有限。很多时候，为了加快更多资源的加载，通常会使用多个不同域名的CDN。而在HTTP2中，通过二进制数据帧的方式来传输同域下多资源，可以解决这个问题。关于HTTP2的传输机制，可以参考<a href="https://segmentfault.com/a/1190000006923359" target="_blank" rel="external">这篇文章</a>。</p>
</li>
</ul>
<h2 id="Chrome对TCP连接的保活机制"><a href="#Chrome对TCP连接的保活机制" class="headerlink" title="Chrome对TCP连接的保活机制"></a>Chrome对TCP连接的保活机制</h2><p>上篇章节中我们熟悉了七层协议中HTTP1.1的Keep-Alive机制，本章节我们介绍Chrome对四层协议的TCP Keepalive的实现。</p>
<p><strong>Chrome何时需要启用TCP Keepalive？</strong><br>假定服务器启用了HTTP1.1 Keep-Alive，浏览器与服务器建立TCP连接，并在该TCP连接上有序地传输多个HTTP1.1七层报文，以此来请求多个资源。对于同域下，在浏览器完成一次请求并获得对应资源后，若一段时间内暂时未有新的资源请求（资源请求可能由页面JavaScript发出，如Ajax），直至下次请求发出前，该TCP连接保持空闲状态。而在这段空闲时间内，浏览器需要对该TCP连接进行保活。</p>
<p>下面我们将通过Wireshark抓包来验证。</p>
<img src="/2016/11/07/tcp-keepalive-on-chrome/9.png" alt="Wireshark抓到的Chrome发出的TCP keepalive探测包" title="Wireshark抓到的Chrome发出的TCP keepalive探测包">
<p>从上面的抓包结果中看到，在服务器返回完整HTTP 200报文的45秒后（Time=72），本地发出了第一个TCP Keepalive探测包并收到来自服务器的ACK。</p>
<p>这说明，Chrome对于可复用的TCP连接，采用的保活机制是TCP层（传输层）自带的Keepalive机制，通过TCP Keepalive探测包的方式实现，而不是在七层报文上自成协议来传输其它数据。</p>
<p>而实际上，由于HTTP1.1对时序和报文的约定，浏览器也不可在七层实现保活。假设，客户端在通过HTTP1.1获取一次资源后，若在这个TCP连接上发送一个<code>0x70</code>（无意义的数据，在七层实现保活的方式大多如此），服务器会在应用层接收到并缓存该数据，一段时间后客户端发送有效的HTTP请求报头，则服务端CGI应用程序收到的数据是<code>0x70</code>再接上一段HTTP请求头，这被认为是无效的HTTP报文，服务器则会返回400响应头，告知客户端这是坏的请求（Bad Request）。</p>
<p>所以，浏览器在处理HTTP1.1请求所对应的TCP连接的保活时，通过使用TCP Keepalive机制，来避免污染七层（应用层）的传输数据。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>本篇主要介绍浏览器对TCP Keepalive的运用，内容简单。结合本篇内容，作者将在下篇文章中详细说明作者在使用shadowsocks浏览web时遇到的问题、解决方案以及一点思考。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/" data-id="cix4ir2jc001uv62huccpujim" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-tcp-keepalive-on-chrome">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-linux-tcp-keepalive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/linux-tcp-keepalive/" class="article-date">
  <time datetime="2016-09-23T16:46:52.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/linux-tcp-keepalive/">TCP keepalive的探究 (1) : NAT和保活机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于应用层的TCP连接保活（Keepalive）机制，相信大家都听说过。对于长连接TCP保活，典型的方法是发送应用层的心跳包，但这将增加开发人员的工作量：需要专门为心跳包制定协议。而在Linux的socket通信API中，自带了TCP_KEEPALIVE的相关参数设定，通过这种方式实现TCP长连接保活，无需修改原程序的逻辑，开发人员不需要关心心跳包的实现。本系列文章将从路由器NAT原理、keepalive基本的代码实现、浏览器保活机制、存在的问题几个方面逐步深入探究。</p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>为什么要使用TCP keepalive？这得从NAT（地址转换）原理开始讲起。狭义上，NAT分为SNAT（原地址转换）和DNAT（目标地址转换），关于DNAT，有兴趣的同学可以自行查阅，本文只讨论SNAT。</p>
<p>我们都知道，路由器的最基本功能是对第三层（网络层）上的IP报文进行转发。实际上，路由器还有很关键的一个功能，这便是NAT。特别是对于ISP对普通用户链路上的路由器，NAT功能尤为重要。</p>
<p>为什么要使用NAT？原因很简单：IPv4地址非常稀缺。上网需求庞大，这使得ISP不可能为每一个入网用户都提供一个独立的公网IP，因此通常情况下，ISP会把用户接入局域网，使得多个用户共享同一个公网IP，而每一个用户各分得一个局域网内网IP。而连接公网和局域网的这台路由器，称之为网关（gateway），NAT的过程就发生在这台网关路由器上。</p>
<h3 id="三层地址转换"><a href="#三层地址转换" class="headerlink" title="三层地址转换"></a>三层地址转换</h3><p>局域网内的主机向公网发出的网络层IP报文，将经由网关被转发至公网，而在该转发过程中发生了地址转换。网关将该IP报文中的 <strong>源IP地址</strong> 从”该主机的内网IP”修改为”网关的公网IP”。</p>
<p>比如，局域网主机获得的内网IP为<code>192.168.1.100</code>，网关的公网IP为<code>210.177.63.2</code>，局域网主机向公网目标主机发出的IP报文中，源IP字段数据为<code>192.168.1.100</code>，在经过网关时，该字段数据将被修改为<code>210.177.63.2</code>。</p>
<p>为什么要这么做，相信大家已经猜到了。公网上的目标主机在收到这个IP报文后，需要知道这个IP报文的来源地址，并向该来源地址发送响应报文，但如果不经过NAT，目标主机拿到的来源地址是<code>192.168.1.100</code>，这显然是一个公网上不可访问到的私有地址，目标主机无法将响应报文发送到正确的来源主机上。开启了NAT之后，IP报文的来源地址被网关修改为<code>210.177.63.2</code>，这是一个公网地址，目标主机将向这个地址（即网关路由器的公网地址）发送响应报文。</p>
<p>但是请注意，如果这个IP报文的数据段不含传输层协议报文，而是一个pure的网络层packet，来自目标主机的响应报文是不能被网关准确转发到多台局域网主机中的其中一台的。（ICMP报文除外，其报头中有Identifier字段用于标识不同的主机或进程，网关在处理Identifier时类似于下面提到的运输层端口）</p>
<h3 id="传输层端口转换表"><a href="#传输层端口转换表" class="headerlink" title="传输层端口转换表"></a>传输层端口转换表</h3><p>在三层地址转换中，我们可以保证局域网内主机向公网发出的IP报文能顺利到达目的主机，但是从目的主机返回的IP报文却不能准确送至指定局域网主机（我们不能让网关把IP报文广播至全部局域网主机，因为这样必然会带来安全和性能问题）。为了解决这个问题，网关路由器需要借助传输层端口，通常情况下是TCP或UDP端口，由此来生成一张端口转换表。</p>
<p>让我们通过一个实例来说明端口转换表如何运作。<br>假设局域网主机A<code>192.168.1.100</code>需要与公网上的目标主机B<code>210.199.38.2:80</code>进行一次TCP通信。其中A所在局域网的网关C的公网IP地址为<code>210.177.63.2</code>。步骤如下：</p>
<p>1. 局域网主机A<code>192.168.1.100</code>发出TCP连接请求，A上的TCP端口为系统分配的<code>53600</code>。该TCP握手包中，包含源地址和端口<code>192.168.1.100:53600</code>，目的地址和端口<code>210.199.38.2:80</code>。<br>2. 网关C将该包的原地址和端口修改为<code>210.177.63.2:63000</code>，其中<code>63000</code>是网关分配的临时端口。<br>3. 网关C在端口转换表中增加一条记录：</p>
<table>
<thead>
<tr>
<th>内网主机IP</th>
<th>内网主机端口</th>
<th>网关端口</th>
<th>目的主机IP</th>
<th>目的主机端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.1.100</td>
<td>53600</td>
<td>63000</td>
<td>210.199.38.2</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>4. 网关C将修改后的TCP包发送至目的主机B。<br>5. 目的主机B收到后，发送响应TCP包。该响应TCP包含有以下信息：源地址和端口<code>210.199.38.2:80</code>，目的地址和端口<code>210.177.63.2:63000</code>。<br>6. 网关C收到这个来自B的响应包后，随即在端口转换表中查找记录。该记录须符合以下条件：目的主机IP==<code>210.199.38.2</code>，目的主机端口==<code>80</code>，网关端口==<code>63000</code>。<br>7. 网关C搜索到这条记录，记录显示内网主机IP为<code>192.168.1.100</code>，内网主机端口为<code>53600</code>。<br>8. 网关C将该包的目的地址和端口修改为<code>192.168.1.100:53600</code>。<br>9. 网关C随即将该修改后的TCP包转发至<code>192.168.1.100:53600</code>，即局域网主机A。此时运输层数据的一次交换已完成。</p>
<h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>在网关C上，由于端口数量有限（0~65535），端口转换表的维护占用系统资源，因此不能无休止地向端口转换表中增加记录。对于过期的记录，网关需要将其删除。如何判断哪些是过期记录？网关认为，一段时间内无活动的连接是过期的，应定时检测转换表中的非活动连接，并将之丢弃。<strong>而这个丢弃的过程，网关不会以任何的方式通告该连接的任何一端。</strong></p>
<p>那么问题就来了：如果一个客户端应用程序由于业务需要，需要与服务端维持长连接（如TCP聊天程序），而如果在特别长的时间内（在博主的ISP环境下，该时间在3分钟左右），这个连接没有任何的数据交换，网关会认为这个连接过期并将这个连接从端口转换表中丢弃。该连接被丢弃时，客户端和服务端对此是完全无感知的。在连接被丢弃后，客户端将收不到服务端的数据推送，客户端发送的数据包也不能到达服务端。</p>
<h2 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h2><p>让我们使用TCP测试工具netcat来实际实验一下。</p>
<ul>
<li>在公网服务器上，使用<code>nc -l 9999</code>命令监听TCP端口<code>9999</code>。</li>
<li>在局域网主机上，使用<code>nc XX.XX.XX.XX 9999</code>命令连接到这台公网服务器的<code>9999</code>端口。</li>
<li>进行基本的双向发包测试。</li>
<li>不关闭连接，在空闲5分钟后再进行双向发包测试。</li>
</ul>
<p>在我的例子中，在双方建立TCP连接后，客户端（局域网主机）发送一行<code>hello from client</code>，服务端发送一行<code>hello from server</code>。<br>等待5分钟，然后客户端发送一行<code>test from client</code>。</p>
<p>通过wireshark在客户端主机上抓包，跟踪这个TCP连接得出如下结果：<br><img src="/2016/09/24/linux-tcp-keepalive/1.png" alt="1.png" title=""></p>
<p>从上图可得出：</p>
<ul>
<li>在第144秒时，通过TCP三次握手，双方建立连接。</li>
<li>随后双方各发一行hello信息，并都成功接收到ACK响应包，证明发送成功。</li>
<li>在第500秒时，客户端发送<code>test from client</code>，但是没有收到对方响应ACK，导致客户端多次重发（TCP Retransmission），但是仍然收不到ACK。</li>
</ul>
<p>在服务端上，仅能收到客户端一开始发送的<code>hello from client</code>，5分钟后客户端发送的<code>test from client</code>并不能收到：<br><img src="/2016/09/24/linux-tcp-keepalive/2.png" alt="2.png" title=""></p>
<p>而在服务端尝试发送<code>test from server</code>，客户端也收不到了。</p>
<p>这表明，在这空闲的5分钟内，网关路由器已经“掐断”了这个TCP连接，导致5分钟后该连接不可再用。但无论是客户端还是服务端，都不知道这个连接已经作废了，因此客户端在发包没有收到ACK后仍在尝试重发，双方的netcat进程仍然没有退出，说明了网关在掐断连接时并没有通知双方。</p>
<h2 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h2><p>如果我们的业务需要我们维持长连接，这就要避免网关“干掉”我们的长连接。解决方法就是，让网关认为我们的TCP连接是活动的。在应用层，我们可以通过定时发送心跳包的方式实现。而如果使用Linux提供的TCP_KEEPALIVE，在应用层我们可完全不关心心跳包何时发送、发送什么内容，这一切由操作系统自动管理：操作系统会在该TCP连接上定时发送探测包，探测包既能像心跳包一样起到连接保活的作用，也能自动检测连接的有效性，并自动关闭无效连接。</p>
<p>在Linux全局内核设置中，有以下三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_time</div><div class="line">7200</div><div class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</div><div class="line">75</div><div class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</div><div class="line">9</div></pre></td></tr></table></figure></p>
<ul>
<li><code>tcp_keepalive_time</code>: 如果在该时间内没有数据往来，则发送探测包。</li>
<li><code>tcp_keepalive_intvl</code>: 探测包发送间隔时间。</li>
<li><code>tcp_keepalive_probes</code>: 尝试探测的次数。如果发送的探测包次数超过该值仍然没有收到对方响应，则认为连接已失效并关闭连接。</li>
</ul>
<p>TCP Keepalive默认是关闭的。要启用这个特性，需要在程序中如下设置（代码实例来自<a href="https://my.oschina.net/lvsin/blog/382904" target="_blank" rel="external">Linux下TCP keepalive属性的表现</a>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> keepAlive = <span class="number">1</span>; <span class="comment">// 开启keepalive属性</span></div><div class="line"><span class="keyword">int</span> keepIdle = <span class="number">60</span>; <span class="comment">// 如该连接在60秒内没有任何数据往来,则进行探测</span></div><div class="line"><span class="keyword">int</span> keepInterval = <span class="number">5</span>; <span class="comment">// 探测时发包的时间间隔为5 秒</span></div><div class="line"><span class="keyword">int</span> keepCount = <span class="number">3</span>; <span class="comment">// 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.</span></div><div class="line"></div><div class="line">setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</div><div class="line">setsockopt(rs, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span>*)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle)); <span class="comment">//对应tcp_keepalive_time</span></div><div class="line">setsockopt(rs, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)); <span class="comment">//对应tcp_keepalive_intvl</span></div><div class="line">setsockopt(rs, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount)); <span class="comment">//对应tcp_keepalive_probes</span></div></pre></td></tr></table></figure>
<p>如果省略<code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code>、<code>TCP_KEEPCNT</code>三个属性的设置，将使用上文的三个系统全局默认值。</p>
<h2 id="第二次实验"><a href="#第二次实验" class="headerlink" title="第二次实验"></a>第二次实验</h2><p>这次我们使用 <a href="https://github.com/cyberelf/netcat-keepalive" target="_blank" rel="external">netcat-keepalive</a> 来测试。这个Github上的开源项目在netcat的基础上加入了上述的代码。参数说明请参照README。</p>
<p>测试方法基本不变。唯一的不同之处是，客户端使用netcat-keepalive，并开启TCP Keepalive特性。</p>
<p>客户端上的测试结果和wireshark抓包记录如下：<br><img src="/2016/09/24/linux-tcp-keepalive/4.png" alt="4.png" title=""></p>
<p>抓包记录显示，在空闲的5分钟内，客户端每隔30秒发送一个TCP探测包（TCP Keep-Alive），并收到服务端ACK（TCP Keep-Alive ACK）。在5分钟后客户端发送<code>test from client</code>，服务端发送<code>test from server</code>，均发送成功。</p>
<p>服务端上的截图：<br><img src="/2016/09/24/linux-tcp-keepalive/6.png" alt="服务端收到了来自客户端的“test from client”" title="服务端收到了来自客户端的“test from client”"></p>
<p>这证明，我们通过TCP Keepalive，成功地阻止了网关路由器丢弃我们的TCP长连接，所以我们在5分钟后仍能够使用这个长连接进行通信。</p>
<p>让我们来看看这个TCP Keep-Alive探测包是个什么东西：<br><img src="/2016/09/24/linux-tcp-keepalive/5.png" alt="5.png" title=""></p>
<p>由上图可看出，探测包是一个特殊的TCP包：它的长度为零，Flags位ACK置1，Options置为两个NOP，而它的端口信息和普通的TCP数据包是一样的。</p>
<p>对于服务端响应的TCP Keep-Alive ACK探测包，是由服务器操作系统发送的。实际上，在使用应用层TCP编程时，并不能收到这个探测包，所以服务端应用程序对该探测包是无感知的。</p>
<h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p>本文从NAT基本原理介绍了TCP Keepalive的原理和基本实现，在下篇文章中，我们将探究Chrome浏览器对于TCP保活的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/" data-id="cix4ir2ir0010v62h9vrof6le" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-linux-tcp-keepalive">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-mixins-considered-harmful-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/28/mixins-considered-harmful-2/" class="article-date">
  <time datetime="2016-08-28T08:32:22.000Z" itemprop="datePublished">2016-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/28/mixins-considered-harmful-2/">mixins是有害的（Mixins Considered Harmful）［下篇］</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/2016/07/23/mixins-considered-harmful/">上篇</a></p>
<p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="external">Facebook React: Mixins Considered Harmful</a></p>
<blockquote>
<p>Migrating from Mixins<br>Let’s make it clear that mixins are not technically deprecated. If you use React.createClass(), you may keep using them. We only say that they didn’t work well for us, and so we won’t recommend using them in the future.<br>Every section below corresponds to a mixin usage pattern that we found in the Facebook codebase. For each of them, we describe the problem and a solution that we think works better than mixins. The examples are written in ES5 but once you don’t need mixins, you can switch to ES6 classes if you’d like.<br>We hope that you find this list helpful. Please let us know if we missed important use cases so we can either amend the list or be proven wrong!</p>
</blockquote>
<h2 id="从Mixins迁移"><a href="#从Mixins迁移" class="headerlink" title="从Mixins迁移"></a>从Mixins迁移</h2><p>有一点需要说明的是，从技术上来讲，mixins不是被弃用的。如果你在使用<code>React.createClass()</code>，你可以继续使用它们。我们只是说它们对我们而言不能很好地运用，并且我们不推荐在未来中继续使用它们。下面的每一章节对应了我们在Facebook代码库中发现的mixin的使用场景。对于每种情况，我们会说明问题所在，并展示我们认为比使用mixins更好的解决方案。示例都使用ES5编写，但当你不再需要mixins时，你可以随心所欲地切换到ES6 classes。<br>我们希望你能从这个列表中得到帮助。如果我们缺漏了一些比较重要的应用场景，请告知我们，因此我们能拓展这个列表，或者证明其中的部分是错误的。</p>
<blockquote>
<p>Performance Optimizations<br>One of the most commonly used mixins is PureRenderMixin. You might be using it in some components to prevent unnecessary re-renders when the props and state are shallowly equal to the previous props and state:</p>
</blockquote>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>使用率最高的mixins之一是 <a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank" rel="external">PureRenderMixin</a> 。你可能正在一些组件中使用它，当props和state跟上次的值是浅层相等时，可<a href="https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="external">避免不必要的重渲染</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [PureRenderMixin],</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>To express the same without mixins, you can use the shallowCompare function directly instead:</p>
</blockquote>
<p>为了达到相同的效果而不使用mixins，你可以直接使用<a href="https://facebook.github.io/react/docs/shallow-compare.html" target="_blank" rel="external">shallowCompare</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shallowCompare = <span class="built_in">require</span>(<span class="string">'react-addons-shallow-compare'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</div><div class="line">  <span class="attr">shouldComponentUpdate</span>: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>If you use a custom mixin implementing a shouldComponentUpdate function with different algorithm, we suggest exporting just that single function from a module and calling it directly from your components.</p>
<p>We understand that more typing can be annoying. For the most common case, we plan to introduce a new base class called React.PureComponent in the next minor release. It uses the same shallow comparison as PureRenderMixin does today.</p>
</blockquote>
<p>如果你使用一个自定义的mixin，以不同的算法实现 <code>shouldComponentUpdate</code> 方法，我们建议从模块中导出该单一的方法，并在你的组件中直接调用它。<br>我们理解频繁的编码是令人不快的。对于更普遍的情况，我们计划在下一个小版本发布中引入一个新的基类<code>React.PureComponent</code>。它将使用浅层对比算法，正如今天的<code>PureRenderMixin</code>。</p>
<blockquote>
<p>Subscriptions and Side Effects<br>The second most common type of mixins that we encountered are mixins that subscribe a React component to a third-party data source. Whether this data source is a Flux Store, an Rx Observable, or something else, the pattern is very similar: the subscription is created in componentDidMount, destroyed in componentWillUnmount, and the change handler calls this.setState().</p>
</blockquote>
<h2 id="订阅和副作用"><a href="#订阅和副作用" class="headerlink" title="订阅和副作用"></a>订阅和副作用</h2><p>我们遇到的第二种最常见的mixins类型是那些用来订阅React组件到第三方数据源的mixins。无论这些数据源是一个Flux Store，还是一个Rx Observable，抑或是其他的，该模式都是相似的：订阅在<code>componentDidMount</code>中产生，在<code>componentWillUnmount</code>中被销毁，而变更处理函数将调用 <code>this.setState()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SubscriptionMixin = &#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">handleChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [SubscriptionMixin],</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Reading comments from state managed by mixin.</span></div><div class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.state.comments;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;comments.map(function(comment) &#123;</div><div class="line">          return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</div><div class="line">        &#125;)&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = CommentList;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Solution</p>
<p>If there is just one component subscribed to this data source, it is fine to embed the subscription logic right into the component. Avoid premature abstractions.</p>
<p>If several components used this mixin to subscribe to a data source, a nice way to avoid repetition is to use a pattern called “higher-order components”. It can sound intimidating so we will take a closer look at how this pattern naturally emerges from the component model.</p>
</blockquote>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果只有一个组件被订阅到这个数据源，直接将订阅逻辑内嵌到该组件中不失为一个良策。避免草率的抽象。</p>
<p>如果多个组件都使用这个mixin来订阅到一个数据源，一个好的避免重复冗余的方法是使用一种被称为“<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" target="_blank" rel="external">高阶组件(higher-order components，又称HOC)</a>”的模式。这听起来让人生畏，所以我们将仔细分析这个模式如何自然地套用到组件模型上。</p>
<blockquote>
<p>Higher-Order Components Explained<br>Let’s forget about React for a second. Consider these two functions that add and multiply numbers, logging the results as they do that:</p>
</blockquote>
<h3 id="高阶组件的解释"><a href="#高阶组件的解释" class="headerlink" title="高阶组件的解释"></a>高阶组件的解释</h3><p>让我们暂时忘记React。想想这两个实现相加和相乘的函数，通过这样来实现记录计算结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAndLog</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = x + y;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAndLog</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = x * y;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>These two functions are not very useful but they help us demonstrate a pattern that we can later apply to components.</p>
<p>Let’s say that we want to extract the logging logic out of these functions without changing their signatures. How can we do this? An elegant solution is to write a higher-order function, that is, a function that takes a function as an argument and returns a function.</p>
<p>Again, it sounds more intimidating than it really is:</p>
</blockquote>
<p>这两个函数并不是十分有用，但它们可以帮助我们描述一个典型的模式，这个模式我们之后将把它应用到组件上。</p>
<p>假设我们想从这些函数中抽离记录逻辑而不修改它们的签名。如何做到这点？一个优雅的方案是，写一个更高阶的函数，这个更高阶的函数实际上是一个将函数作为其参数，并返回一个新函数的函数。</p>
<p>又一次，它听起来让人生畏，但实际上它是更简单的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</div><div class="line">  <span class="comment">// Return a function with the same API...</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="comment">// ... that calls the original function</span></div><div class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</div><div class="line">    <span class="comment">// ... but also logs its result!</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>The withLogging higher-order function lets us write add and multiply without the logging statements, and later wrap them to get addAndLog and multiplyAndLog with exactly the same signatures as before:</p>
</blockquote>
<p>这个 <code>withLogging</code> 高阶函数让我们在实现相加和相乘逻辑时不需考虑记录逻辑，在这之后我们通过嵌套的方式来得到与之前签名一致的 <code>addAndLog</code> 和 <code>multiplyAndLog</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Equivalent to writing addAndLog by hand:</span></div><div class="line"><span class="keyword">var</span> addAndLog = withLogging(add);</div><div class="line"></div><div class="line"><span class="comment">// Equivalent to writing multiplyAndLog by hand:</span></div><div class="line"><span class="keyword">var</span> multiplyAndLog = withLogging(multiply);</div></pre></td></tr></table></figure>
<blockquote>
<p>Higher-order components are a very similar pattern, but applied to components in React. We will apply this transformation from mixins in two steps.</p>
<p>As a first step, we will split our CommentList component in two, a child and a parent. The child will be only concerned with rendering the comments. The parent will set up the subscription and pass the up-to-date data to the child via props.</p>
</blockquote>
<p>高阶组件是一种非常相似的模式，只不过它是应用在React组件上的而已。我们将这种转换应用到mixins上，只需要两步即可。</p>
<p>第一步，我们将<code>CommentList</code>组件分为子和父两部分。子组件只关心渲染评论，而父组件将设置订阅，并将最新的数据通过props传递到子组件上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This is a child component.</span></div><div class="line"><span class="comment">// It only renders the comments it receives as props.</span></div><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Note: now reading from props rather than state.</span></div><div class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;comments.map(function(comment) &#123;</div><div class="line">          return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</div><div class="line">        &#125;)&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// This is a parent component.</div><div class="line">// It subscribes to the data source and renders &lt;CommentList /&gt;.</div><div class="line">var CommentListWithSubscription = React.createClass(&#123;</div><div class="line">  getInitialState: function() &#123;</div><div class="line">    return &#123;</div><div class="line">      comments: DataSource.getComments()</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  componentDidMount: function() &#123;</div><div class="line">    DataSource.addChangeListener(this.handleChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  componentWillUnmount: function() &#123;</div><div class="line">    DataSource.removeChangeListener(this.handleChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  handleChange: function() &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      comments: DataSource.getComments()</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    // We pass the current state as props to CommentList.</div><div class="line">    return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = CommentListWithSubscription;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>There is just one final step left to do.</p>
<p>Remember how we made withLogging() take a function and return another function wrapping it? We can apply a similar pattern to React components.</p>
<p>We will write a new function called withSubscription(WrappedComponent). Its argument could be any React component. We will pass CommentList as WrappedComponent, but we could also apply withSubscription() to any other component in our codebase.</p>
<p>This function would return another component. The returned component would manage the subscription and render <wrappedcomponent> with the current data.</wrappedcomponent></p>
<p>We call this pattern a “higher-order component”.</p>
<p>The composition happens at React rendering level rather than with a direct function call. This is why it doesn’t matter whether the wrapped component is defined with createClass(), as an ES6 class or a function. If WrappedComponent is a React component, the component created by withSubscription() can render it.</p>
</blockquote>
<p>只剩下最后一步了。</p>
<p>还记得我们如何使得<code>withLogging()</code>传入一个函数并返回另一个嵌套它的函数吗？我们可以将相似的模式应用到React组件上来。</p>
<p>我们将编写一个新的函数，叫做<code>withSubscription(WrappedComponent)</code>。它的参数可以是任意的React组件。我们将传递<code>CommentList</code>作为<code>WrappedComponent</code>，但我们也可以在我们的代码基中将<code>withSubscription()</code>应用到任意其他的组件上。</p>
<p>这个函数会返回另一个组件。返回的组件将会管理好订阅，并渲染包含数据的<code>&lt;WrappedComponent /&gt;</code>。</p>
<p>我们把这种模式称为一个“高阶组件”。</p>
<p>这种合成发生在React的渲染层，而不是通过一个直接的函数调用。这就是为什么无论内嵌的组件是由<code>createClass()</code>创建的，还是由ES6 class生成的，抑或是一个函数，都无关紧要了。如果<code>WrappedComponent</code>是一个React组件，通过<code>withSubscription()</code>创建的组件都能渲染它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This function takes a component...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...and returns another component...</span></div><div class="line">  <span class="keyword">return</span> React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ... that takes care of the subscription...</span></div><div class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">handleChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">      &#125;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// ... and renders the wrapped component with the fresh data!</span></div><div class="line">      <span class="keyword">return</span> &lt;WrappedComponent comments=&#123;this.state.comments&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Now we can declare CommentListWithSubscription by applying withSubscription to CommentList:</p>
</blockquote>
<p>现在我们可以通过应用<code>withSubscription</code>到<code>CommentList</code>上来声明<code>CommentListWithSubscription</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;comments.map(function(comment) &#123;</div><div class="line">          return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</div><div class="line">        &#125;)&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// withSubscription() returns a new component that</div><div class="line">// is subscribed to the data source and renders</div><div class="line">// &lt;CommentList /&gt; with up-to-date data.</div><div class="line">var CommentListWithSubscription = withSubscription(CommentList);</div><div class="line"></div><div class="line">// The rest of the app is interested in the subscribed component</div><div class="line">// so we export it instead of the original unwrapped CommentList.</div><div class="line">module.exports = CommentListWithSubscription;</div></pre></td></tr></table></figure>
<blockquote>
<p>Solution, Revisited<br>Now that we understand higher-order components better, let’s take another look at the complete solution that doesn’t involve mixins. There are a few minor changes that are annotated with inline comments:</p>
</blockquote>
<h3 id="解决方案，重现"><a href="#解决方案，重现" class="headerlink" title="解决方案，重现"></a>解决方案，重现</h3><p>现在我们能更好的理解高阶组件了，让我们来再看一次完整的、无需涉及mixins的解决方案。内联的注释有少量修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">      &#125;;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">componentWillUnmount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">handleChange</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">comments</span>: DataSource.getComments()</div><div class="line">      &#125;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// Use JSX spread syntax to pass all props and state down automatically.</span></div><div class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Optional change: convert CommentList to a functional component</div><div class="line">// because it doesn't use lifecycle hooks or state.</div><div class="line">function CommentList(props) &#123;</div><div class="line">  var comments = props.comments;</div><div class="line">  return (</div><div class="line">    &lt;div&gt;</div><div class="line">      &#123;comments.map(function(comment) &#123;</div><div class="line">        return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</div><div class="line">      &#125;)&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Instead of declaring CommentListWithSubscription,</div><div class="line">// we export the wrapped component right away.</div><div class="line">module.exports = withSubscription(CommentList);</div></pre></td></tr></table></figure>
<blockquote>
<p>Higher-order components are a powerful pattern. You can pass additional arguments to them if you want to further customize their behavior. After all, they are not even a feature of React. They are just functions that receive components and return components that wrap them.</p>
<p>Like any solution, higher-order components have their own pitfalls. For example, if you heavily use refs, you might notice that wrapping something into a higher-order component changes the ref to point to the wrapping component. In practice we discourage using refs for component communication so we don’t think it’s a big issue. In the future, we might consider adding ref forwarding to React to solve this annoyance.</p>
</blockquote>
<p>高阶组件是一个强大的模式。你可以给它们传递更多的参数，如果你想要进一步高度定制它们的行为。毕境，它们甚至不是React的特性之一。它们只是接受传入组件，并返回嵌套了传入组件的新组件的函数而已。</p>
<p>就像其它解决方案，高阶函数同样有他们的潜在风险。比如，如果你大量地使用refs（组件引用），你可能会发现，将任意组件嵌套进高阶组件里面时，内层组件的ref会被改变。在实践中我们不建议使用refs来实现组件间通信，所以我们不认为这是个大问题。在未来，我们将考虑引入ref重定向到React中来解决这个问题。</p>
<blockquote>
<p>Rendering Logic<br>The next most common use case for mixins that we discovered in our codebase is sharing rendering logic between components.</p>
<p>Here is a typical example of this pattern:</p>
</blockquote>
<h2 id="渲染逻辑"><a href="#渲染逻辑" class="headerlink" title="渲染逻辑"></a>渲染逻辑</h2><p>在我们的代码库中，我们发现的下一个常见的mixins用例是组件间渲染逻辑的共享。</p>
<p>以下是这个模式的典型例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> RowMixin = &#123;</div><div class="line">  <span class="comment">// Called by components from render()</span></div><div class="line">  renderHeader: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className='row-header'&gt;</div><div class="line">        &lt;h1&gt;</div><div class="line">          &#123;this.getHeaderText() /* Defined by components */&#125;</div><div class="line">        &lt;/h1&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> UserRow = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [RowMixin],</div><div class="line"></div><div class="line">  <span class="comment">// Called by RowMixin.renderHeader()</span></div><div class="line">  getHeaderText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.user.fullName;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;this.renderHeader() /* Defined by RowMixin */&#125;</div><div class="line">        &lt;h2&gt;&#123;this.props.user.biography&#125;&lt;/h2&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>Multiple components may be sharing RowMixin to render the header, and each of them would need to define getHeaderText().</p>
</blockquote>
<p>多个组件可能共享了<code>RowMixin</code>来渲染行头，而每个这些组件都需要定义一个<code>getHeaderText()</code>方法。</p>
<blockquote>
<p>Solution</p>
<p>If you see rendering logic inside a mixin, it’s time to extract a component!</p>
<p>Instead of RowMixin, we will define a <row> component. We will also replace the convention of defining a getHeaderText() method with the standard mechanism of top-data flow in React: passing props.</row></p>
<p>Finally, since neither of those components currently need lifecycle hooks or state, we can declare them as simple functions:</p>
</blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你看见了一个mixin里面含有渲染逻辑，那么是时候把它们抽离到组件中了！</p>
<p>我们将定义一个<code>&lt;Row&gt;</code>组件来取代<code>RowMixin</code>。我们也将会把借由定义一个<code>getHeaderText()</code>方法来实现转换的方式替换成React中标准的自顶向下数据流机制：传递props。</p>
<p>最后，因为这些组件现在都不再需要生命周期钩子和状态了，我们会把他们定义为简单的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">RowHeader</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div className='row-header'&gt;</div><div class="line">      &lt;h1&gt;&#123;props.text&#125;&lt;/h1&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserRow</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;RowHeader text=&#123;props.user.fullName&#125; /&gt;</div><div class="line">      &lt;h2&gt;&#123;props.user.biography&#125;&lt;/h2&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Props keep component dependencies explicit, easy to replace, and enforceable with tools like Flow and TypeScript.</p>
</blockquote>
<p>Props使得组件依赖保持显式、易于替换、对诸如Flow和TypeScript一类的工具更易执行。</p>
<blockquote>
<p>Note:</p>
<p>Defining components as functions is not required. There is also nothing wrong with using lifecycle hooks and state—they are first-class React features. We use functional components in this example because they are easier to read and we didn’t need those extra features, but classes would work just as fine.</p>
</blockquote>
<p>备注：<br>将组件定义为函数不是必需的。使用React的头等特性：生命周期钩子和状态也是没有任何错误的。我们在这个示例中使用函数式组件，因为它们可以更易于阅读，并且我们不需要那些另外的特性，但使用classes也是一样的效果。</p>
<blockquote>
<p>Context<br>Another group of mixins we discovered were helpers for providing and consuming React context. Context is an experimental unstable feature, has certain issues, and will likely change its API in the future. We don’t recommend using it unless you’re confident there is no other way of solving your problem.</p>
<p>Nevertheless, if you already use context today, you might have been hiding its usage with mixins like this:</p>
</blockquote>
<h2 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h2><p>我们发现的另外一系列mixins是提供和消费React Context的辅助器。Context是一个实验性的不稳定特性，存在确定的缺陷，而且它的API在未来可能会被改变。我们不推荐使用它，除非你十分确定没有其他方法来解决你的问题。</p>
<p>尽管如此，如果你已经使用了context，你可能把它的使用隐藏在了mixins里，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> RouterMixin = &#123;</div><div class="line">  <span class="attr">contextTypes</span>: &#123;</div><div class="line">    <span class="attr">router</span>: React.PropTypes.object.isRequired</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// The mixin provides a method so that components</span></div><div class="line">  <span class="comment">// don't have to use the context API directly.</span></div><div class="line">  push: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.context.router.push(path)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Link = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [RouterMixin],</div><div class="line"></div><div class="line">  <span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line"></div><div class="line">    <span class="comment">// This method is defined in RouterMixin.</span></div><div class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.props.to);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;a onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      &lt;/a&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Link;</div></pre></td></tr></table></figure>
<blockquote>
<p>Solution<br>We agree that hiding context usage from consuming components is a good idea until the context API stabilizes. However, we recommend using higher-order components instead of mixins for this.</p>
<p>Let the wrapping component grab something from the context, and pass it down with props to the wrapped component:</p>
</blockquote>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>在context的API稳定之前，我们认为，将context的调用在组件中隐藏起来是个好主意。不过，我们推荐使用高阶组件来取代mixins来实现这点。</p>
<p>让外层组件从context中获取数据，并通过props传递到内层组件中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> React.createClass(&#123;</div><div class="line">    <span class="attr">contextTypes</span>: &#123;</div><div class="line">      <span class="attr">router</span>: React.PropTypes.object.isRequired</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// The wrapper component reads something from the context</span></div><div class="line">      <span class="comment">// and passes it down as a prop to the wrapped component.</span></div><div class="line">      <span class="keyword">var</span> router = <span class="keyword">this</span>.context.router;</div><div class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; router=&#123;router&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Link = React.createClass(&#123;</div><div class="line">  handleClick: function(e) &#123;</div><div class="line">    e.stopPropagation();</div><div class="line"></div><div class="line">    // The wrapped component uses props instead of context.</div><div class="line">    this.props.router.push(this.props.to);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return (</div><div class="line">      &lt;a onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      &lt;/a&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Don't forget to wrap the component!</div><div class="line">module.exports = withRouter(Link);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>If you’re using a third party library that only provides a mixin, we encourage you to file an issue with them linking to this post so that they can provide a higher-order component instead. In the meantime, you can create a higher-order component around it yourself in exactly the same way.</p>
</blockquote>
<p>如果你在使用一个只提供mixin的第三方库，我们建议你去提交一个issue，引用本文链接，让他们去做成高阶组件。在这期间，通过完全一样的方式，你可以自己动手围绕它做一个高阶组件。</p>
<blockquote>
<p>Utility Methods<br>Sometimes, mixins are used solely to share utility functions between components:</p>
</blockquote>
<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>有时候，mixins仅仅是用作在组件间共享的通用工具函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ColorMixin = &#123;</div><div class="line">  getLuminance(color) &#123;</div><div class="line">    <span class="keyword">var</span> c = <span class="built_in">parseInt</span>(color, <span class="number">16</span>);</div><div class="line">    <span class="keyword">var</span> r = (c &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">var</span> g = (c &amp; <span class="number">0x00FF00</span>) &gt;&gt; <span class="number">8</span>;</div><div class="line">    <span class="keyword">var</span> b = (c &amp; <span class="number">0x0000FF</span>);</div><div class="line">    <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [ColorMixin],</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> theme = <span class="keyword">this</span>.getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=&#123;theme&#125;&gt;</div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Solution<br>Put utility functions into regular JavaScript modules and import them. This also makes it easier to test them or use them outside of your components:</p>
</blockquote>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>将通用的工具方法放入常规的JavaScript模块中，并引入它们。这同样使得测试和组件外调用变得简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getLuminance = <span class="built_in">require</span>(<span class="string">'../utils/getLuminance'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> theme = getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=&#123;theme&#125;&gt;</div><div class="line">        &#123;this.props.children&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>Other Use Cases<br>Sometimes people use mixins to selectively add logging to lifecycle hooks in some components. In the future, we intend to provide an official DevTools API that would let you implement something similar without touching the components. However it’s still very much a work in progress. If you heavily depend on logging mixins for debugging, you might want to keep using those mixins for a little longer.</p>
<p>If you can’t accomplish something with a component, a higher-order component, or a utility module, it could be mean that React should provide this out of the box. File an issue to tell us about your use case for mixins, and we’ll help you consider alternatives or perhaps implement your feature request.</p>
<p>Mixins are not deprecated in the traditional sense. You can keep using them with React.createClass(), as we won’t be changing it further. Eventually, as ES6 classes gain more adoption and their usability problems in React are solved, we might split React.createClass() into a separate package because most people wouldn’t need it. Even in that case, your old mixins would keep working.</p>
<p>We believe that the alternatives above are better for the vast majority of cases, and we invite you to try writing React apps without using mixins.</p>
</blockquote>
<h2 id="其他用例"><a href="#其他用例" class="headerlink" title="其他用例"></a>其他用例</h2><p>有时候，人们使用mixins来向一些组件添加选择性的生命周期钩子日志记录。在未来，我们计划提供一个官方的开发工具API来实现相似功能，而无需触碰组件代码。虽然这仍有大量正在进度中的工作需要完成。如果你十分依赖日志记录mixins来调试，你可能还要继续保持使用它们一段时间。</p>
<p>如果你借助一个组件、一个高阶组件、或者一个通用模块，仍然不能完成一些事情，这意味着React应该是难以完成这样的事情的。向我们提交一个issue，告诉我们你的mixins使用场景，我们会帮助你考虑可选的方案，或者是在未来实现你的新特性请求。</p>
<p>Mixins在传统感官中不是完全抛弃的。你可以通过<code>React.createClass()</code>继续使用它们，因为我们不会在未来修改它。最终，当ES6 classes得到更广泛的采用，并且它们在React中使用上的问题得到解决时，我们也许会将<code>React.createClass()</code>分离到独立的包之中，因为大多数人不再需要它。即使是在那样的情况下，你的老mixins仍然能够继续工作。</p>
<p>我们相信，以上所提到的可选方案对于绝大多数的场景是更好的选择，我们邀请你来尝试在不使用mixins的情况下编写React应用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/" data-id="cix4ir2ik000qv62hindofshu" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-mixins-considered-harmful-2">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-mixins-considered-harmful" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/23/mixins-considered-harmful/" class="article-date">
  <time datetime="2016-07-23T12:12:22.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/mixins-considered-harmful/">mixins是有害的（Mixins Considered Harmful）［上篇］</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="external">Facebook React: Mixins Considered Harmful</a></p>
<blockquote>
<p>“How do I share the code between several components?” is one of the first questions that people ask when they learn React. Our answer has always been to use component composition for code reuse. You can define a component and use it in several other components.</p>
</blockquote>
<p>“我如何在多个组件（components）之间共享代码？”，这是React初学者的问题之一。我们的答案一直都是，通过组件组合的方法来实现代码复用。你可以定义一个组件，并在其它的组件中使用它。</p>
<blockquote>
<p>It is not always obvious how a certain pattern can be solved with composition. React is influenced by functional programming but it came into the field that was dominated by object-oriented libraries. It was hard for engineers both inside and outside of Facebook to give up on the patterns they were used to.</p>
</blockquote>
<p>通过组件组合的方式来解决某一种情况不总是显而易见的。React受函数式编程影响，但结果它成为了由面向对象库组成的存在。无伦是Facebook内部员工，还是非Facebook的程序员，抛弃以往的开发方式都是困难的。</p>
<blockquote>
<p>To ease the initial adoption and learning, we included certain escape hatches into React. The mixin system was one of those escape hatches, and its goal was to give you a way to reuse code between components when you aren’t sure how to solve the same problem with composition.</p>
</blockquote>
<p>为了让入门学习变得简单，我们引入了一些解决方案（原文“escape hatches”即逃生舱，此处语义为解决问题的一些trick）。Mixin系统是其中的一个方法，它的目的是，当你不知道如何通过组件组合来解决问题时，来给你一个方法来实现组件间的代码复用。</p>
<blockquote>
<p>Three years passed since React was released. The landscape has changed. Multiple view libraries now adopt a component model similar to React. Using composition over inheritance to build declarative user interfaces is no longer a novelty. We are also more confident in the React component model, and we have seen many creative uses of it both internally and in the community.<br>In this post, we will consider the problems commonly caused by mixins. Then we will suggest several alternative patterns for the same use cases. We have found those patterns to scale better with the complexity of the codebase than mixins.</p>
</blockquote>
<p>React发布后三年过去了，大环境发生了改变。大多数视图库现在都采用类似React的组件模型。通过多个组件在继承关系之上的组合来构建用户界面不再是一个新奇的方式。我们也对React的组件模型更加自信，并且在内部和社区中，都看到了许多具有创新性的使用方式。<br>在这篇文章中，我们会讨论由mixins造成的普遍问题。然后我们会提出一些同等情况下的可选替代方案。这些新的方案，在同等的代码复杂度下，比用mixins的可扩展性更好。</p>
<h2 id="为什么说Mixins不好？"><a href="#为什么说Mixins不好？" class="headerlink" title="为什么说Mixins不好？"></a>为什么说Mixins不好？</h2><blockquote>
<p>At Facebook, React usage has grown from a few components to thousands of them. This gives us a window into how people use React. Thanks to declarative rendering and top-down data flow, many teams were able to fix a bunch of bugs while shipping new features as they adopted React.</p>
</blockquote>
<p>在Facebook，React的使用从少量的组件演变成上千的组件数量。这给我们看见了人们是如何使用React的。多亏于声明性的渲染和自上而下的数据流，很多团队能够在迁移项目到React的时候修复一些bug。</p>
<blockquote>
<p>However it’s inevitable that some of our code using React gradually became incomprehensible. Occasionally, the React team would see groups of components in different projects that people were afraid to touch. These components were too easy to break accidentally, were confusing to new developers, and eventually became just as confusing to the people who wrote them in the first place. Much of this confusion was caused by mixins. At the time, I wasn’t working at Facebook but I came to the same conclusions after writing my fair share of terrible mixins.</p>
</blockquote>
<p>但是，一个很难避免的情况是，一些代码在使用了React了之后逐渐降低了可读性。有时，使用React的开发团队中会出现一些人们不太愿意去触碰的组件，而这些组件在不同的项目中被使用了。这些组件太容易意外损坏，这不但困扰了新加入的开发者，最终也困扰了一开始编写这些组件的人。这些麻烦的问题大多是由mixins造成的。在那时，我还未在Facebook工作，但在使用了一系列糟糕的mixins之后，我也能得出跟现在一样的结论。</p>
<blockquote>
<p>This doesn’t mean that mixins themselves are bad. People successfully employ them in different languages and paradigms, including some functional languages. At Facebook, we extensively use traits in Hack which are fairly similar to mixins. Nevertheless, we think that mixins are unnecessary and problematic in React codebases. Here’s why.</p>
</blockquote>
<p>这并不代表mixins都是不好的。人们成功地在不同的语言和范例中应用了mixins，其中包括了一些函数式语言。在Facebook，我们大量使用了类似mixins的一些比较hack的实现方式。我们认为mixins在React中是不再必要的，而且是非常容易出问题的。接下来讨论这是为什么。</p>
<h2 id="Mixins引入了隐性的依赖"><a href="#Mixins引入了隐性的依赖" class="headerlink" title="Mixins引入了隐性的依赖"></a>Mixins引入了隐性的依赖</h2><blockquote>
<p>Sometimes a component relies on a certain method defined in the mixin, such as getClassName(). Sometimes it’s the other way around, and mixin calls a method like renderHeader() on the component. JavaScript is a dynamic language so it’s hard to enforce or document these dependencies.<br>Mixins break the common and usually safe assumption that you can rename a state key or a method by searching for its occurrences in the component file. You might write a stateful component and then your coworker might add a mixin that reads this state. In a few months, you might want to move that state up to the parent component so it can be shared with a sibling. Will you remember to update the mixin to read a prop instead? What if, by now, other components also use this mixin?</p>
</blockquote>
<p>有时候一个组件依赖一个在mixin中定义的确定的方法，比如<code>getClassName()</code>。有时候在另一个场景下，mixin在组件上调用了一个方法，比如<code>renderHeader()</code>。JavaScript是一种动态语言，所以去强制定义或者记录这些依赖是很困难的。<br>Mixins打破了一个通用的、通常是安全的假设：你可以通过在组件源码文件中搜索的方式来重命名一个方法或者一个状态的key。你写了一个具有状态的组件，然后你的组员加入了一个mixin来读取它的状态。过了一两个月，你想把这个状态挪到父组件上，来实现跟相邻组件共享。你会记得同时更新这个mixin的代码，把它改为读取prop吗？再如果，现在还有其它组件也使用了这个mixin？</p>
<blockquote>
<p>These implicit dependencies make it hard for new team members to contribute to a codebase. A component’s render() method might reference some method that isn’t defined on the class. Is it safe to remove? Perhaps it’s defined in one of the mixins. But which one of them? You need to scroll up to the mixin list, open each of those files, and look for this method. Worse, mixins can specify their own mixins, so the search can be deep.<br>Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace.</p>
</blockquote>
<p>这些隐形的依赖使得新成员在现有代码基础上继续开发变得困难。一个组件的<code>render()</code>方法也许引用了一些不在本类中定义的方法，删除它们是否安全？也许它们定义在mixins中，但是在哪个里面呢？你需要滚动到mixin列表，打开每个mixin的源码，来找这些方法。更坏的是，mixins可以定义它们自己的mixins，所以这次查找是一次深度查找。<br>经常地，mixins还依赖其它的mixins，如果你删除其中之一，可能会波及到另外的。在这种情况下，说明数据如何在mixins流入流出就变得很棘手了，更别说画出它们之间的依赖关系图。不像组件，mixins不会构成继承链：它们是扁平化的，并在同一个命名空间中起作用。</p>
<h2 id="Mixins造成命名冲突"><a href="#Mixins造成命名冲突" class="headerlink" title="Mixins造成命名冲突"></a>Mixins造成命名冲突</h2><blockquote>
<p>There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.<br>It’s not a big deal if you control the mixin code. When you have a conflict, you can rename that method on one of the mixins. However it’s tricky because some components or other mixins may already be calling this method directly, and you need to find and fix those calls as well.</p>
</blockquote>
<p>从没有保证说任意两个mixins可以在一起使用。比如，如果<code>FluxListenerMixin</code>定义了<code>handleChange()</code>，<code>WindowSizeMixin</code>也定义了<code>handleChange()</code>，你就不能把它们拿在一块用。你也不能在你的组件中用这个名字来命名方法。<br>如果你能控制mixin的代码，那问题是不大的。当你遇到了命名冲突，你可以在其中的mixin中修改那个方法的名字。但是，如果有另外的mixins或是组件已经直接调用了这个方法，这就变得很棘手了，你需要同时找到和修复这些调用。</p>
<blockquote>
<p>If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.<br>The situation is no better for mixin authors. Even adding a new method to a mixin is always a potentially breaking change because a method with the same name might already exist on some of the components using it, either directly or through another mixin. Once written, mixins are hard to remove or change. Bad ideas don’t get refactored away because refactoring is too risky.</p>
</blockquote>
<p>如果你在使用一个第三方包的mixin时遇到了命名冲突，你就不能改它的方法名了。取而代之，你需要在你的组件中使用很蹩脚的方法名来避免冲突。<br>这样的情况对于mixin作者来说并没有好多少。加入一个新方法到mixin中总是一个潜在的风险，因为在已经使用了这个mixin的组件中，可能早就存在同名的方法了，无伦是直接调用还是通过其它mixin来调用。一旦mixins写好，就很困难去修改或者移除其中的东西。一些欠佳的实现方式得不到重构，因为重构的风险太大。</p>
<h2 id="Mixins造成滚雪球式的复杂性"><a href="#Mixins造成滚雪球式的复杂性" class="headerlink" title="Mixins造成滚雪球式的复杂性"></a>Mixins造成滚雪球式的复杂性</h2><blockquote>
<p>Even when mixins start out simple, they tend to become complex over time. The example below is based on a real scenario I’ve seen play out in a codebase.<br>A component needs some state to track mouse hover. To keep this logic reusable, you might extract handleMouseEnter(), handleMouseLeave() and isHovering() into a HoverMixin. Next, somebody needs to implement a tooltip. They don’t want to duplicate the logic in HoverMixin so they create a TooltipMixin that uses HoverMixin. TooltipMixin reads isHovering() provided by HoverMixin in its componentDidUpdate() and either shows or hides the tooltip.</p>
</blockquote>
<p>虽然mixins是从简单开始的，但它们会随着时间变得越来越复杂。下面的例子是基于一个真实的情况。<br>一个组件需要一些状态来跟踪鼠标的悬浮（hover）。为了使这个逻辑可复用，你抽取了<code>handleMouseEnter()</code>、<code>handleMouseLeave()</code>、<code>isHovering()</code>方法到一个<code>HoverMixin</code>里。接下来，有人需要实现一个悬浮提示框（tooltip）。他们不想拷贝<code>HoverMixin</code>里的逻辑代码，因此创建了一个<code>TooltipMixin</code>，这个<code>TooltipMixin</code>引用了<code>HoverMixin</code>，<code>TooltipMixin</code>在它的<code>componentDidUpdate()</code>中读取由<code>HoverMixin</code>提供的<code>isHovering()</code>来显示或者隐藏提示框。</p>
<blockquote>
<p>A few months later, somebody wants to make the tooltip direction configurable. In an effort to avoid code duplication, they add support for a new optional method called getTooltipOptions() to TooltipMixin. By this time, components that show popovers also use HoverMixin. However popovers need a different hover delay. To solve this, somebody adds support for an optional getHoverOptions() method and implements it in TooltipMixin. Those mixins are now tightly coupled.<br>This is fine while there are no new requirements. However this solution doesn’t scale well. What if you want to support displaying multiple tooltips in a single component? You can’t define the same mixin twice in a component. What if the tooltips need to be displayed automatically in a guided tour instead of on hover? Good luck decoupling TooltipMixin from HoverMixin. What if you need to support the case where the hover area and the tooltip anchor are located in different components? You can’t easily hoist the state used by mixin up into the parent component. Unlike components, mixins don’t lend themselves naturally to such changes.</p>
</blockquote>
<p>几个月后，有人想让这个提示框的弹出方向变得可配置。为了避免代码重复，他们添加了一个新的配置方法<code>getTooltipOptions()</code>到<code>TooltipMixin</code>。在这时，需要弹出浮层的组件也使用了<code>HoverMixin</code>。但是浮层需要不同的鼠标悬浮延时。为了解决这个问题，有人添加并实现了一个配置方法<code>getHoverOptions()</code>到<code>TooltipMixin</code>中。这两个mixins现在紧紧耦合在一起了。<br>如果没有新的需求，这样是没有问题的。但是这个方法的可扩展性并不强。如果你想在同一个组件里面支持显示多个提示框呢？你不能在一个组件里面定义两次同一个mixin。如果提示框需要在用户引导里自动弹出，而不是在鼠标悬浮时弹出呢？你想解耦<code>TooltipMixin</code>和<code>HoverMixin</code>？祝你好运。如果你想让鼠标悬浮点和提示框锚点在不同的组件中呢？你不能轻易地将mixin使用的状态抬升到父组件中。不像组件，mixins在遇到这些改变时并不能很自然地交付。</p>
<blockquote>
<p>Every new requirement makes the mixins harder to understand. Components using the same mixin become increasingly coupled with time. Any new capability gets added to all of the components using that mixin. There is no way to split a “simpler” part of the mixin without either duplicating the code or introducing more dependencies and indirection between mixins. Gradually, the encapsulation boundaries erode, and since it’s hard to change or remove the existing mixins, they keep getting more abstract until nobody understands how they work.<br>These are the same problems we faced building apps before React. We found that they are solved by declarative rendering, top-down data flow, and encapsulated components. At Facebook, we have been migrating our code to use alternative patterns to mixins, and we are generally happy with the results. You can read about those patterns below.</p>
</blockquote>
<p>每个新需求让mixins变得越来越难以理解。随着时间，使用同一个mixin的组件之间的耦合度变得越来越高。任何新的功能都会同时被附加到所有使用了这个mixin的组件。没有方法去分离这个mixin的“更简单”的部分，除非去拷贝其中的代码，或者在mixins之间引入更多的依赖和奇技淫巧。逐渐地，原来的封装会瓦解，并且因为更改或者移除已经存在的mixins是困难的，它们会变得更抽象，直到没人理解它们是怎么工作的。<br>这些问题跟我们在React出来之前构建应用程序时遇到的问题是一样的。我们认为这些问题可以通过声明性的渲染、自上而下的数据流和组件封装来解决。在Facebook，我们已经将代码的实现方式从mixins迁移到了取而代之的模式，并且我们对结果很乐观。你可以继续阅读来了解我们的新模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/" data-id="cix4ir2iz001cv62hksvf5u5v" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-mixins-considered-harmful">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/front-end/">front-end</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-openwrt-multiwan-configuration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/13/openwrt-multiwan-configuration/" class="article-date">
  <time datetime="2016-07-13T14:24:37.000Z" itemprop="datePublished">2016-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/13/openwrt-multiwan-configuration/">OpenWRT下双WAN配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>晚上好。博主前段时间因沉迷CGSS和PS4游戏，长时间未更新博客，实在不好。现在正值暑假，博主在公司实习，今晚趁未加班，写一篇早就想写的openwrt路由器干货。</p>
<p>本文讲述如何在openwrt家用智能路由器上配置双WAN带宽叠加。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>两条或更多的宽带，或者是支持单线多拨的宽带。</li>
<li>已经安装MWAN3及luci图形化配置界面（Pandorabox固件默认已安装）。</li>
</ul>
<h2 id="VLAN配置"><a href="#VLAN配置" class="headerlink" title="VLAN配置"></a>VLAN配置</h2><blockquote>
<p>什么是VLAN？VLAN是在同一物理局域网内用于划分若干个不同广播域（子网）的技术，子网内的主机可以互相通信，不同子网的主机之间不可互相通信。<br>什么是VLAN ID？用于标识每个VLAN子网的ID。<br>为什么要划分VLAN？在OpenWRT下，接口是根据VLAN划分的，每个逻辑接口（interface）可对应一个VLAN ID作为物理接口，这将在后面的步骤中体现出来。</p>
</blockquote>
<p>在openwrt的web配置页面上，进入 网络-&gt;交换机 (Network-&gt;Switch)。<br>默认情况下，已经分配的VLAN应该有1个或者2个。<br>通过插拔网线的方法，将配置页上的端口和路由器的物理RJ45接口对应上来。<br>在小米路由器mini上，默认分配如下两个vlan：<br><img src="/images/openwrt-switch-1.png" alt=""><br>其中，VLAN1用作LAN，连接了除端口4以外的所有物理端口；VLAN2是默认的WAN，只连接端口4。（此处端口4即为小米路由器mini上的蓝色WAN RJ45物理端口）<br>注意，端口状态“不关联”(untagged)，即该端口作为本VLAN成员，进行二层交换；若选择“关联”(tagged)，端口之间通信无二层交换，而是冲突广播（hub方式）。</p>
<p>选择一个端口作为第二个WAN口的端口，在现有的VLAN配置中将其设置为“关”，然后新建一个VLAN，将该端口设置为“不关联”，其他端口设置为“关”，CPU设置为“关联”。注意，小米路由器mini有一个特殊的端口7，按照原有的两个VLAN，将其设置为“关联”即可。<br>如图，博主选择端口1来作为第二个WAN端口，在VLAN1中将其设置为“关”，并在新建的VLAN3中设置其为“不关联”。<br><img src="/images/openwrt-switch-2.png" alt=""><br>保存即可。</p>
<h2 id="新建WAN接口"><a href="#新建WAN接口" class="headerlink" title="新建WAN接口"></a>新建WAN接口</h2><p>进入 网络-&gt;接口，将当前<code>WAN</code>接口更名为<code>WAN1</code>，并添加一个新接口，命名为<code>WAN2</code>。<br>在<code>WAN2</code>的配置中，设置第二条宽带的拨号方式，在“物理设置”中选择刚才添加的VLAN3（<code>eth0.3</code>）。<br><img src="/images/openwrt-interface-1.png" alt=""></p>
<p><strong>重要</strong><br>进入<code>WAN1</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为40；<br>进入<code>WAN2</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为41；</p>
<p>若有更多的WAN需要添加，方法类似，需要注意每个WAN接口的网关跃点必须不一样。</p>
<p>设置完成后，在接口总览中应该能看到两个WAN都成功获取到IP，如果是PPPoE方式，应该都已经拨号成功。<br><img src="/images/openwrt-interface-2.png" alt=""></p>
<h2 id="MWAN3配置"><a href="#MWAN3配置" class="headerlink" title="MWAN3配置"></a>MWAN3配置</h2><p>接下来需要通过MWAN3实现多WAN负载均衡。</p>
<p>进入 网络-&gt;负载均衡。</p>
<ul>
<li><p>接口配置<br>进入 配置-&gt;接口。<br>删除所有已有的默认接口。<br>添加两个接口，分别为<code>WAN1</code>，<code>WAN2</code>。<br>在接口详情的“跟踪的IP地址”中，可添加几个国内的主机IP作为检测接口是否上线的ping地址。当ping该IP多次超时后，即该接口视作下线。<br>博主的固件版本下，这个跟踪功能并不好使，经常误判断接口下线，因此我清空了跟踪的IP地址，并视作接口始终上线。<br><img src="/images/openwrt-mwan-1.png" alt=""></p>
</li>
<li><p>成员配置<br>进入 配置-&gt;成员，删除所有已有的默认成员，添加两个成员，分别命名为<code>wan_1</code>, <code>wan_2</code>。<br>成员<code>wan_1</code>设置接口为<code>WAN1</code>，跃点数1，接口比重1；<br>成员<code>wan_2</code>设置接口为<code>WAN2</code>，跃点数1，接口比重1；</p>
</li>
<li><p>策略配置<br>进入 配置-&gt;策略，添加一个策略<code>balanced</code>（或者编辑已有的<code>balanced</code>策略），使用的成员为<code>wan_1</code>, <code>wan_2</code>。</p>
</li>
<li><p>规则配置<br>进入 配置-&gt;规则，保留已有的<code>https</code>规则。如果没有<code>default_rule</code>规则，则添加一条<code>default_rule</code>规则，目标地址设置为<code>0.0.0.0/0</code>，协议选择<code>all</code>，使用的策略为<code>balanced</code>，其他留空。</p>
</li>
<li><p>保存并应用全部设置，此时应该能够实现双线负载均衡了。</p>
</li>
</ul>
<p>至此，openwrt路由器上的双WAN配置实现带宽叠加已经完成了，可以测速看看了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/" data-id="cix4ir2iw0017v62hi2r0gfv1" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-openwrt-multiwan-configuration">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/router/">router</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-cron-job-locale-issues" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/29/cron-job-locale-issues/" class="article-date">
  <time datetime="2016-04-29T13:15:58.000Z" itemprop="datePublished">2016-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>►<a class="article-category-link" href="/categories/学习笔记/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/29/cron-job-locale-issues/">cron任务的locale问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文：<a href="http://www.mk-mode.com/octopress/2013/11/26/linux-cron-locale-behavior/" target="_blank" rel="external">Linux - cron での locale の挙動！ - mk-mode BLOG</a></p>
<blockquote>
<p>こんばんは。<br>Linux で、自分が作成したスクリプトがコンソール上では正常に動作するのに、 cron で定時起動させようとすると文字コードの関係でうまく日本語出力ができないことがあります。<br>以下、それについての備忘録です。</p>
</blockquote>
<p>晚上好。<br>在Linux下，自己编写的（shell）脚本，在终端下手动运行是一切正常的。但是，由于字符编码的关系，当cron在试图以定时任务来执行该脚本时，日语文字却不能被正常输出。<br>以下是解决这一问题的备忘录。</p>
<blockquote>
<p>0. 前提条件<br>CentOS 6.4 (32bit) での作業を想定。<br>cron は crontab -e ではなく、 /etc/cron.d/ ディレクトリ配下にファイルを設置する方法。<br>文字化けが起こるスクリプトは “UTF-8” でエンコードされていて、日本語出力を伴うことを想定。<br>（当然、日本語出力を伴わないのならロケールの心配もない）</p>
</blockquote>
<h2 id="0-条件"><a href="#0-条件" class="headerlink" title="0. 条件"></a>0. 条件</h2><ul>
<li>假定操作系统是CentOS 6.4 (32bit) （译者注：6.X, 64位同样适用）</li>
<li>不使用cron的<code>crontab -e</code>，而是在<code>/etc/cron.d/</code>目录下建立配置文件来设置cron任务（译者注：同样适用于通过<code>crontab -e</code>设置的任务）</li>
<li>脚本使用UTF-8编码，并假定脚本的执行将伴随有日语文字输出，且（由cron执行时）出现了乱码。<br>（当然，如果日语输出不受locale影响，则无需担心。）</li>
</ul>
<blockquote>
<p>1. cron 外（コンソール）でのロケール<br>普通にコンソールで locale コマンドでロケールを確認してみる。</p>
</blockquote>
<h2 id="1-在cron外部（用户终端）的locale"><a href="#1-在cron外部（用户终端）的locale" class="headerlink" title="1. 在cron外部（用户终端）的locale"></a>1. 在cron外部（用户终端）的locale</h2><p>在一般的用户终端（console）中，尝试通过<code>locale</code>命令来确认当前环境的locale。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># locale</span></div><div class="line">LANG=ja_JP.UTF<span class="number">-8</span></div><div class="line">LC_CTYPE=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_NUMERIC=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_TIME=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_COLLATE=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_MONETARY=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_MESSAGES=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_PAPER=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_NAME=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_ADDRESS=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_TELEPHONE=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_MEASUREMENT=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_IDENTIFICATION=<span class="string">"ja_JP.UTF-8"</span></div><div class="line">LC_ALL=</div></pre></td></tr></table></figure></p>
<blockquote>
<p>2. cron 内でのロケール<br>次に cron 内で locale コマンドを実行させてみる。<br>例えば、以下のようなファイル /etc/cron.d/locale_test を作成してみる。</p>
</blockquote>
<h2 id="2-cron内的locale"><a href="#2-cron内的locale" class="headerlink" title="2. cron内的locale"></a>2. cron内的locale</h2><p>接下来，我们尝试在cron内执行<code>locale</code>命令。（译者注：其实就是在cron job中运行<code>locale</code>命令）<br>如下例，尝试创建一个文件<code>/home/hoge/work/locale.log</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * root locale &gt; /home/hoge/work/locale.log</div></pre></td></tr></table></figure></p>
<blockquote>
<p>毎分 “/home/hoge/work/” ディレクトリ内に “locale.log” というファイルが作成されるので、内容を確認してみる。</p>
</blockquote>
<p>每分钟，<code>/home/hoge/work/</code>下的<code>locale.log</code>文件都会被写入新数据，我们来尝试确认该文件内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LANG=</div><div class="line">LC_CTYPE=<span class="string">"POSIX"</span></div><div class="line">LC_NUMERIC=<span class="string">"POSIX"</span></div><div class="line">LC_TIME=<span class="string">"POSIX"</span></div><div class="line">LC_COLLATE=<span class="string">"POSIX"</span></div><div class="line">LC_MONETARY=<span class="string">"POSIX"</span></div><div class="line">LC_MESSAGES=<span class="string">"POSIX"</span></div><div class="line">LC_PAPER=<span class="string">"POSIX"</span></div><div class="line">LC_NAME=<span class="string">"POSIX"</span></div><div class="line">LC_ADDRESS=<span class="string">"POSIX"</span></div><div class="line">LC_TELEPHONE=<span class="string">"POSIX"</span></div><div class="line">LC_MEASUREMENT=<span class="string">"POSIX"</span></div><div class="line">LC_IDENTIFICATION=<span class="string">"POSIX"</span></div><div class="line">LC_ALL=</div></pre></td></tr></table></figure></p>
<blockquote>
<p>“ja_JP.UTF-8” でなく “POSIX” となっている。<br>これでは、UTF-8 でエンコードされているスクリプトは日本語表示で不具合を起こすでしょう。</p>
</blockquote>
<p><code>ja_JP.UTF-8</code>并不在<code>POSIX</code>集合内。<br>因此，使用UTF-8编码的脚本在遇到日语输出时会出错。</p>
<blockquote>
<p>3. 対処方法<br>cron 内で UTF-8 でデンコードされたスクリプトを実行させる場合は、以下のように LC_CTYPE, LANG を設定してやる。</p>
</blockquote>
<h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h2><p>要在cron中运行通过UTF-8编码的脚本，需要设定<code>LC_CTYPE</code>和<code>LANG</code>。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LC_CTYPE=<span class="string">"ja_JP.utf8"</span></div><div class="line">LANG=<span class="string">"ja_JP.utf8"</span></div><div class="line"></div><div class="line">* * * * * root locale &gt; /home/hoge/work/locale.log</div></pre></td></tr></table></figure></p>
<blockquote>
<p>再度 “/home/hoge/work/” ディレクトリ内の “locale.log” の内容を確認してみる。</p>
</blockquote>
<p>再次确认<code>/home/hoge/work/</code>目录下的<code>locale.log</code>文件的内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LANG=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_CTYPE=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_NUMERIC=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_TIME=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_COLLATE=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_MONETARY=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_MESSAGES=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_PAPER=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_NAME=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_ADDRESS=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_TELEPHONE=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_MEASUREMENT=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_IDENTIFICATION=<span class="string">"ja_JP.utf8"</span></div><div class="line">LC_ALL=</div></pre></td></tr></table></figure></p>
<blockquote>
<p>“ja_JP.utf8” になりました。（UTF-8 と utf8 の違いはあるが問題ない）<br>これで、日本語出力で文字化けすることがなくなります。</p>
</blockquote>
<p>现在是<code>ja_JP.utf8</code>了。（UTF-8和utf8的区别并不是个问题）<br>现在，（cron job任务的）的日语输出不会再乱码了。</p>
<blockquote>
<p>4. 参考<br>上記では任意のスクリプトについて話したが、UTF-8 エンコードの Ruby スクリプト（日本語出力を伴うもの）を cron 起動させるには以下のように -Ku オプションで文字コードを指定することでも対処可能である。</p>
</blockquote>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p>上面的记录是针对任意的脚本。若需通过cron运行含有日语输出的Ruby脚本，可以通过<code>-Ku</code>选项指定字符编码。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * root /usr/local/bin/ruby -Ku test_script.rb</div></pre></td></tr></table></figure></p>
<blockquote>
<p>5. 後始末<br>当然、テストで作成した cron スクリプトは不要なので削除しておく。</p>
<p>以上。</p>
</blockquote>
<h2 id="5-后续清理"><a href="#5-后续清理" class="headerlink" title="5. 后续清理"></a>5. 后续清理</h2><p>当然，在刚才的测试中添加的cron任务脚本（locale命令）是不再需要的，请删除它。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>本文locale问题的解决方案对于简体中文也是同样适用的，只需将本文中的<code>ja_JP</code>替换成<code>zh_CN</code>即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/04/29/cron-job-locale-issues/" data-id="cix4ir2ic000hv62hqcfusp04" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/04/29/cron-job-locale-issues/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-cron-job-locale-issues">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/04/29/cron-job-locale-issues/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li></ul>

    </footer>
  </div>
  
</article>





  
    <article id="post-163-music-unlock-update-log" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/163-music-unlock-update-log/" class="article-date">
  <time datetime="2016-04-06T15:40:45.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发笔记/">开发笔记</a>►<a class="article-category-link" href="/categories/开发笔记/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/163-music-unlock-update-log/">网易云音乐反向代理163-music-unlock更新记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这几天，博主去年开发的<a href="https://github.com/Chion82/163-music-unlock" target="_blank" rel="external">163-music-unlock</a>（<a href="https://blog.chionlab.moe/2016/01/21/netease-music-app-reversed-proxy/">开发笔记</a>）用户数急剧增加，GitHub repo获得了160多个star（甚至上了GitHub的Trending列表，作者还是有点小激动的），服务器每日请求数达到10万、600IP。随着用户增多，项目也收到了不少Issue反馈，总结如下：</p>
<ul>
<li>歌曲加载速度慢（特别是版权歌曲）</li>
<li>无法下载付费歌曲</li>
<li>无法加载其他用户的个人资料和歌单信息</li>
<li>部分付费歌曲无法播放</li>
</ul>
<h2 id="提高反代性能"><a href="#提高反代性能" class="headerlink" title="提高反代性能"></a>提高反代性能</h2><p>检查nginx access log，发现其中有多个请求状态为499。499为nginx特有的状态码，含义是客户端未等待服务器回应而主动关闭连接。<br>经过测试，发现网易云音乐客户端调用API接口时都有超时重试机制，并且超时时间比较短，大概在3～5秒左右，若服务器未在该时间内响应，客户端会直接关闭连接而重试，导致服务器上有大量499请求记录。<br>首要目标是提高服务器反代性能。其实在这之前，反代服务器基本上只有博主在使用，性能问题不明显，歌曲很快就可以加载出来了，而最近用户数量上升后，明显感觉到歌曲加载速度非常慢。<br>由于反代服务器架设在SLHK节点的VPS上，经过测试，发现瓶颈在SLHK到<code>music.163.com</code>的链路上。由于nginx的优化，nginx直接到网易的反代性能还能接受。但是python脚本调用网易云音乐API时速度很慢，甚至很多时候会直接导致gunicorn主动关闭超时请求。<br>python脚本主要处理歌曲播放地址API和歌曲下载地址API这两种请求，其他请求都直接由nginx直接反代到网易了。<br>由于网易云音乐主服务器在国内，使用国内云服务器当然是最佳的。博主测试发现，反代python脚本运行在腾讯云或阿里云上时，调用网易云音乐API速度非常快。<br>但是如果直接将反代服务器架设在腾讯云或阿里云上，有个问题：客户端是使用<code>music.163.com</code>这个域名访问80端口web服务的，而国内云平台会拦截未备案域名的web请求。但是，直接通过IP访问web服务（即HTTP头中，Host的值为服务器IP）时，不会被拦截。<br>SLHK VPS到腾讯云或阿里云的链路情况也很好。因此，我将python脚本放在腾讯云上运行，而反代服务器依然使用SLHK VPS，只不过在SLHK VPS上，将歌曲播放地址API和歌曲下载地址API的URL反代到腾讯云上（直接使用腾讯云的IP），其他URL请求维持原样。<br>将python脚本部署在腾讯云上，并在SLHK VPS上修改nginx配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">upstream balanced_backend &#123;</div><div class="line">        server music.163.com;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name music.163.com;</div><div class="line">        resolver 114.114.114.114;</div><div class="line"></div><div class="line">        #一般请求直接反代到music.163.com</div><div class="line">        location / &#123;</div><div class="line">               proxy_pass http://balanced_backend;</div><div class="line">               proxy_next_upstream     error timeout invalid_header http_500;</div><div class="line">               proxy_connect_timeout   6s;</div><div class="line">               proxy_send_timeout       6s;</div><div class="line">               proxy_read_timeout       6s;</div><div class="line">               proxy_set_header Host $host;</div><div class="line">               proxy_set_header X-Real-IP $remote_addr;</div><div class="line">               proxy_set_header Accept-Encoding &quot;&quot;;</div><div class="line">               subs_filter_types *;</div><div class="line">               subs_filter &apos;&quot;st&quot;:-.+?,&apos; &apos;&quot;st&quot;:0,&apos; ir;</div><div class="line">               subs_filter &apos;&quot;pl&quot;:0&apos; &apos;&quot;pl&quot;:320000&apos;;</div><div class="line">               subs_filter &apos;&quot;dl&quot;:0&apos; &apos;&quot;dl&quot;:320000&apos;;</div><div class="line">               subs_filter &apos;&quot;sp&quot;:0&apos; &apos;&quot;sp&quot;:7&apos;;</div><div class="line">               subs_filter &apos;&quot;cp&quot;:0&apos; &apos;&quot;cp&quot;:1&apos;;</div><div class="line">               subs_filter &apos;&quot;subp&quot;:0&apos; &apos;&quot;subp&quot;:1&apos;;</div><div class="line">               subs_filter &apos;&quot;fl&quot;:0&apos; &apos;&quot;fl&quot;:320000&apos;;</div><div class="line">               subs_filter &apos;&quot;fee&quot;:.+?,&apos; &apos;&quot;fee&quot;:0,&apos; ir;</div><div class="line">      	       subs_filter &apos;&quot;abroad&quot;:1,&apos; &apos;&apos;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #歌曲播放地址API</div><div class="line">        location /eapi/song/enhance/player/url &#123;</div><div class="line">               proxy_pass http://&lt;腾讯云IP&gt;:5001;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #歌曲下载地址API</div><div class="line">        location /eapi/song/enhance/download/url &#123;</div><div class="line">               proxy_pass http://&lt;腾讯云IP&gt;:5001;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了进一步提高python反代脚本的性能，增加gunicorn的进程数到16。当某个请求使得某个服务进程（或者说是worker）调用网易API而发生io阻塞时，整个进程都会被阻塞而无法接手下一个请求，因此理论上，这种网络io瓶颈型的服务，进程数越多越好。但是单个gunicorn进程内存占用大，经测试，在博主的1G内存腾讯云上，开50个gunicorn进程已接近极限，而性能甚至不如16个进程。<br>通过gunicorn运行反代服务的启动脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">cd /root/163-music-unlock/server    #替换为本项目下的server目录</div><div class="line">/usr/local/bin/gunicorn -w 16 runapi:app -b 0.0.0.0:5001 --access-logfile /var/log/gunicorn.access.log --error-logfile /var/log/gunicorn.error.log --log-file /var/log/gunicorn.log</div></pre></td></tr></table></figure></p>
<h2 id="增加下载地址API反代"><a href="#增加下载地址API反代" class="headerlink" title="增加下载地址API反代"></a>增加下载地址API反代</h2><p>之前的版本中，python脚本只处理歌曲在线播放地址的API，所以下架歌曲或付费歌曲只能试听，无法下载。经过抓包发现，在线播放API和下载地址API只有细微的差异：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在线播放API，服务器返回格式：</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"code"</span> : <span class="number">200</span>,</div><div class="line">  <span class="string">"data"</span> : [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"id"</span> : <span class="number">123456</span>,</div><div class="line">      <span class="string">"url"</span>: <span class="string">"http://m1.music.net/music.mp3"</span>,</div><div class="line">      <span class="string">"br"</span> : <span class="number">64000</span>,</div><div class="line">      <span class="string">"size"</span>: <span class="number">12345</span>,</div><div class="line">      <span class="string">"md5"</span> : <span class="string">"11111111111111111111111111111111"</span>,</div><div class="line">      <span class="string">"code"</span>: <span class="number">200</span>,</div><div class="line">      <span class="string">"expi"</span>: <span class="number">1200</span>,</div><div class="line">      <span class="string">"type"</span>: <span class="string">"mp3"</span>,</div><div class="line">      <span class="string">"gain"</span>: <span class="number">0</span>,</div><div class="line">      <span class="string">"fee"</span>: <span class="number">0</span>,</div><div class="line">      <span class="string">"canExtend"</span>: False</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"><span class="comment">//下载地址API，服务器返回格式：</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"code"</span> : <span class="number">200</span>,</div><div class="line">  <span class="string">"data"</span> : &#123;</div><div class="line">    <span class="string">"id"</span> : <span class="number">123456</span>,</div><div class="line">    <span class="string">"url"</span>: <span class="string">"http://m1.music.net/music.mp3"</span>,</div><div class="line">    <span class="string">"br"</span> : <span class="number">64000</span>,</div><div class="line">    <span class="string">"size"</span>: <span class="number">12345</span>,</div><div class="line">    <span class="string">"md5"</span> : <span class="string">"11111111111111111111111111111111"</span>,</div><div class="line">    <span class="string">"code"</span>: <span class="number">200</span>,</div><div class="line">    <span class="string">"expi"</span>: <span class="number">1200</span>,</div><div class="line">    <span class="string">"type"</span>: <span class="string">"mp3"</span>,</div><div class="line">    <span class="string">"gain"</span>: <span class="number">0</span>,</div><div class="line">    <span class="string">"fee"</span>: <span class="number">0</span>,</div><div class="line">    <span class="string">"canExtend"</span>: False</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>python脚本只需要做稍微的调整就可以同时兼容下载地址API了。<br>经过测试，IOS和OSX客户端都可以下载付费音乐了。但是，安卓客户端在下载付费音乐时，虽然有下载速度，但是最后会报网络错误下载失败，怀疑是因为安卓客户端会校验下载文件的md5，而python反代脚本获取到的付费音乐信息不含文件md5（python脚本所调用的网易云音乐API不返回文件md5信息），直接给客户端返回<code>&quot;md5&quot;:null</code>所致。</p>
<h2 id="解决https反代的问题"><a href="#解决https反代的问题" class="headerlink" title="解决https反代的问题"></a>解决https反代的问题</h2><p>Issue中反映的无法查看其他用户资料和歌单的问题，经过抓包发现，是因为这部分API是https的，而服务器上只有http反代。博主尝试使用自签证书在nginx上实现https反代，但是IOS客户端不接受自签证书。虽然客户端可以通过PAC配置文件或者iptables，实现只将http请求转发到反代服务器，而https请求直接到网易云音乐服务器，但是在IOS或安卓上，这样的配置对于用户而言是十分繁琐的，因此还是在服务器上实现https反代。<br>通过在TCP层的转发，是可以实现免SSL证书反代https请求的。因此，在反代服务器上通过iptables实现443端口转发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#先在/etc/sysctl.conf中设置net.ipv4.ip_forward=1</div><div class="line">iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 223.252.199.7:443</div><div class="line">iptables -t nat -A POSTROUTING -j MASQUERADE</div></pre></td></tr></table></figure></p>
<p>其中，<code>223.252.199.7</code>即<code>music.163.com</code>指向的网易云音乐服务器IP。<br>另外，据github网友 <a href="https://github.com/Max-Sum" target="_blank" rel="external">Max-Sum</a> 在 <a href="https://github.com/Chion82/163-music-unlock/issues/11" target="_blank" rel="external">issue#11</a> 中提到，使用<code>SNI Proxy</code>可实现根据域名转发，即可在反代服务器443端口上架设多个https服务。<br>若使用SNI Proxy，配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">user daemon</div><div class="line">pidfile /var/run/sniproxy.pid</div><div class="line"></div><div class="line">error_log &#123;</div><div class="line">    syslog daemon</div><div class="line">    priority notice</div><div class="line">&#125;</div><div class="line"></div><div class="line">listen &lt;YOUR_SERVER_IP&gt;:443 &#123;</div><div class="line">    proto tls</div><div class="line">    table https_hosts</div><div class="line"></div><div class="line">    access_log &#123;</div><div class="line">        filename /var/log/sniproxy/https_access.log</div><div class="line">        priority notice</div><div class="line">    &#125;</div><div class="line">    fallback 127.0.0.1:443</div><div class="line">&#125;</div><div class="line"></div><div class="line">table https_hosts &#123;</div><div class="line">    music.163.com 223.252.199.7:443</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="部分付费歌曲无法播放"><a href="#部分付费歌曲无法播放" class="headerlink" title="部分付费歌曲无法播放"></a>部分付费歌曲无法播放</h2><p>免费午餐不会永久。前段时间，网易已经封了一部分付费歌曲，python脚本目前使用的API<code>http://music.163.com/api/song/detail/</code>，一部分付费歌曲已经不返回文件信息了。博主发现，部分付费专辑／付费歌曲（无论是否包月会员都需要付费的音乐）已经无法获取到音乐文件信息，而大部分包月付费包中的音乐还可以获取到最低音质的音乐文件信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.chionlab.moe/2016/04/06/163-music-unlock-update-log/" data-id="cix4ir2hs0003v62h6pq1voeo" class="article-share-link">分享</a>
      
        <a href="http://blog.chionlab.moe/2016/04/06/163-music-unlock-update-log/" class="article-duoshuo-link ds-thread-count" data-thread-key="post-163-music-unlock-update-log">多说</a>
      
      
        <a href="http://blog.chionlab.moe/2016/04/06/163-music-unlock-update-log/#disqus_thread" class="article-comment-link disqus-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hack/">hack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>





  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OSX/">OSX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/OpenWRT/">OpenWRT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/后端/">后端</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/">开发笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发笔记/安卓/">安卓</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/逆向/">逆向</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSX/">OSX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crawler/">crawler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/front-end/">front-end</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hack/">hack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maintenance/">maintenance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/OSX/" style="font-size: 11.67px;">OSX</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/android/" style="font-size: 13.33px;">android</a> <a href="/tags/backend/" style="font-size: 11.67px;">backend</a> <a href="/tags/crawler/" style="font-size: 13.33px;">crawler</a> <a href="/tags/front-end/" style="font-size: 18.33px;">front-end</a> <a href="/tags/hack/" style="font-size: 18.33px;">hack</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/maintenance/" style="font-size: 20px;">maintenance</a> <a href="/tags/network/" style="font-size: 11.67px;">network</a> <a href="/tags/nginx/" style="font-size: 13.33px;">nginx</a> <a href="/tags/openwrt/" style="font-size: 16.67px;">openwrt</a> <a href="/tags/project/" style="font-size: 10px;">project</a> <a href="/tags/python/" style="font-size: 16.67px;">python</a> <a href="/tags/router/" style="font-size: 15px;">router</a> <a href="/tags/wechat/" style="font-size: 11.67px;">wechat</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近发表</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/21/universal-react-app-reuse-effects-on-server-side/">再谈React同构应用：服务端下复用Redux Effects的实践</a>
          </li>
        
          <li>
            <a href="/2016/12/12/better-way-to-bypass-gfw-with-tinc/">tinc VPN+策略路由：Linux下更好的科学上网方式</a>
          </li>
        
          <li>
            <a href="/2016/12/12/chionlab-updates-dec-2016/">ChionLab 2016年底更新记录</a>
          </li>
        
          <li>
            <a href="/2016/11/07/tcp-keepalive-on-chrome/">TCP keepalive的探究 (2) : 浏览器的Keepalive机制</a>
          </li>
        
          <li>
            <a href="/2016/09/24/linux-tcp-keepalive/">TCP keepalive的探究 (1) : NAT和保活机制</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    <div class="widget-wrap">
  <h3 class="widget-title">友链</h3>
  <div class="widget">
    <a href="https://www.starduster.me" target="_blank">星尘独奏曲</a><br/>
    <a href="http://www.zhouchao.me" target="_blank">chao's blog</a><br/>
    <a href="http://ilazycat.com" target="_blank">小黑猫菊苣的猫窝</a><br/>
    <a href="https://loli.be" target="_blank">Mashiro's Blog</a><br/>
    <a href="https://bismarck.moe" target="_blank">雨宫千鹤的博客</a><br />
    <a href="https://blessing.studio" target="_blank">Blessing Studio</a>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Chion Tang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, themed &amp; customized by Chion
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="https://github.com/Chion82" class="mobile-nav-link">GitHub</a>
  
    <a href="/about.html" class="mobile-nav-link">About Me</a>
  
</nav>
    
<script>
  var disqus_shortname = 'chionlab';
  if (window.location.hostname.indexOf('cn2') === -1) {
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
  } else {
    var disqusElements = document.querySelectorAll('.disqus-comments-section, .disqus-comment-link');
    for (var i=0; i<disqusElements.length; i++) {
      disqusElements[i].style.display = 'none';
    }
  }
</script>



<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
  var duoshuoQuery = {short_name:'chionlab'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- 多说公共JS代码 end -->



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>