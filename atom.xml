<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChionLab</title>
  
  <subtitle>欢迎来到Chion82的未来道具研究所 ( ゜- ゜)つロ 乾杯~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.chionlab.moe/"/>
  <updated>2018-02-23T04:40:57.000Z</updated>
  <id>https://blog.chionlab.moe/</id>
  
  <author>
    <name>Chion Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</title>
    <link href="https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/"/>
    <id>https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/</id>
    <published>2018-02-09T12:51:54.000Z</published>
    <updated>2018-02-23T04:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>根据 <a href="https://www.ietf.org/rfc/rfc3489.txt" target="_blank" rel="noopener">RFC 3489</a> 中的定义，NAT类型被划分为以下四种： Full Cone, Restricted Cone, Port Restricted Cone, Symmetric. (RFC 5780 中对NAT类型定义有了更严格的拓展分类，但不是十分常用，本文暂不探讨。)</li><li>STUN过程( <a href="https://www.ietf.org/rfc/rfc3489.txt" target="_blank" rel="noopener">RFC 3489</a> 和 <a href="https://tools.ietf.org/html/rfc5389" target="_blank" rel="noopener">RFC 5389</a> )可以实现内网穿透，从而实现点到点通信。STUN技术被广泛应用于 VoIP、WebRTC、网络游戏、VPN等涉及低延迟点到点通讯的领域。</li><li>基于STUN的内网穿透成功率取决于通信双方的NAT类型，其中 Full Cone NAT 的成功率最高。</li><li>关于NAT type和STUN协议、STUN过程的详细知识请参考其他文章。本文仅探讨 RFC 3489 下定义的 Full Cone NAT 和 UDP hole punching 技术。</li><li>本文中的NAT特指NAPT。ALG等周边技术在部分厂商的linux网络设备上已有相应实现，暂不讨论。</li><li>你可以直接到 <a href="https://github.com/Chion82/netfilter-full-cone-nat" target="_blank" rel="noopener">https://github.com/Chion82/netfilter-full-cone-nat</a> 使用本文的解决方案。</li></ul><h2 id="关于NAT类型在Linux上实现的现状"><a href="#关于NAT类型在Linux上实现的现状" class="headerlink" title="关于NAT类型在Linux上实现的现状"></a>关于NAT类型在Linux上实现的现状</h2><p>TLDR: Linux上至今未实现真正意义上的Full Cone NAT，Linux的 SNAT/MASQUERADE（以<code>iptables</code>的配置为例）均是Symmetric NAT。</p><h2 id="现有的在Linux上的Full-Cone-NAT-的实现"><a href="#现有的在Linux上的Full-Cone-NAT-的实现" class="headerlink" title="现有的在Linux上的Full Cone NAT(?)的实现"></a>现有的在Linux上的Full Cone NAT(?)的实现</h2><p>之所以“Linux上未真正实现Full Cone NAT”这个问题至今没有被重视，是因为总有那么个“看似能够代替的方案”。事实上，稍微谷歌一下不难找到这样来实现Full Cone NAT的方法（假设<code>eth0</code>是外网出口网卡，内网主机是<code>192.168.1.3</code>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE #普通的SNAT</span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -j DNAT --to-destination 192.168.1.3 #将入站流量DNAT转发到内网主机192.168.1.3</span><br></pre></td></tr></table></figure></p><p>类似的实现还有<code>NETMAP</code>。这种设置都有一个共同点：入站流量其实是 <strong>定向DNAT转发</strong> 到某一台内网主机中，从而对该台内网主机而言，它的NAT类型总是Full Cone的。事实上这种设置更像是DMZ host，是不分条件地转发所有入站流量到内网DMZ主机。然而，这种设置只能对该台内网主机有效，对于同一内网下的其他主机，它们的NAT类型仍然是Symmetric。</p><h3 id="UPnP技术"><a href="#UPnP技术" class="headerlink" title="UPnP技术"></a>UPnP技术</h3><p>为了解决这个问题，UPnP起到了很重要的作用。事实上，UPnP技术基本上解决了家庭用户的内网穿透需求。（鉴于现在大多数用户都使用基于Linux的智能路由器的光猫等）在Linux上，实现UPnP的应用程序通常是 <a href="https://github.com/miniupnp/miniupnp" target="_blank" rel="noopener">miniupnp</a>。<br>内网主机的应用程序在需要进行内网穿透前，对路由器进行一次UPnP请求，该请求映射一个外网端口（UDP或TCP）到内网主机的端口。miniupnp随后会执行若干条 <code>iptables</code> 命令，例如最重要的是这条：（为便于理解，该命令已简化，事实上miniupnpd会在 <code>nat</code> 表下另建一个链）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i eth0 -p udp --dport 5000 -j DNAT --to-destination 192.168.1.3:5000</span><br></pre></td></tr></table></figure></p><p>这条命令映射了外网的 <code>udp:5000</code> 端口到内网主机 <code>192.168.1.3</code> 的 <code>udp:5000</code>。只要外网端口号不重复，内网内的任何主机都能够再次发起UPnP请求来申请新的映射。映射成功后，该内网主机使用申请的内网端口进行通信时是Full Cone的。</p><p>然而，UPnP有较大的局限性：</p><ul><li>UPnP涉及SSDP组播发现过程，miniupnpd的默认配置更是会向客户端返回全局映射表，相对而言不太安全，不适合应用于复杂的企业级大型网络及ISP入户网络。</li><li>一次UPnP请求只能进行一级NAT的映射，当然你也可以转发UPnP请求到上级NAT设备，但是似乎至今没有一款家用智能路由器会这么做。这意味着如果你在家使用两台以上的智能路由器级联上网，仅通过UPnP是无法实现内网穿透的。</li></ul><p>综上所述，目前Linux下对于Full Cone NAT的实现均是基于主动的端口映射技术（添加DNAT规则），这种实现一定程度上能满足现今的大多数家用场景，但仍在很多场合下有较大的局限性：如网吧、ISP的NAT(LSN)网关等，这些组织对于Full Cone NAT的实现通常是使用非Linux内核的企业级路由设备，这些设备可能基于如思科的硬转发芯片、FPGA等。</p><h2 id="Mailing"><a href="#Mailing" class="headerlink" title="Mailing"></a>Mailing</h2><p>对于Full Cone NAT这个feature，可以从内核（具体是netfilter子系统）的mailing list上找到相关的问题：</p><blockquote><p><a href="http://lists.netfilter.org/pipermail/netfilter/2005-February/058428.html" target="_blank" rel="noopener">Configure to Full Cone</a> :<br>How can I configure IPtables to be Full Cone?<br>- You cannot. iptable_nat only implements the most sophisticated version<br>of NAT: fully symmetric.</p><p><a href="http://lists.netfilter.org/pipermail/netfilter/2007-February/067963.html" target="_blank" rel="noopener">IPTables and different types of NAT</a> :<br>“Full cone NAT” can be implemented with 1-to-1 bidirectional NAT using<br>SNAT+DNAT or NETMAP.</p></blockquote><p>由此可见，他们的回答基本和我们的讨论基本无二：netfilter只实现最成熟的symmetric NAT，如果要实现Full Cone NAT，需要使用一对一的定向DNAT/NETMAP转发。</p><h2 id="还有没有必要在Linux上实现真正意义上的Full-Cone-NAT？"><a href="#还有没有必要在Linux上实现真正意义上的Full-Cone-NAT？" class="headerlink" title="还有没有必要在Linux上实现真正意义上的Full Cone NAT？"></a>还有没有必要在Linux上实现真正意义上的Full Cone NAT？</h2><p>经过对DMZ host和UPnP的分析，我们重新定义何为“真正意义上的Full Cone NAT”：对于内网主机中的任意一台主机，在不借助“主动端口映射”申请（如UPnP）和“手动端口转发配置”（如DMZ host或DNAT规则）下，在路由器端口用完之前，都是Full Cone的；路由器的“入站端口映射规则”是根据“内网主机出站端口映射记录”动态生成的，无论内网主机数量是否改变，内网主机的IP地址是否变更，在不依赖人工改变配置时，内网主机的NAT类型始终为Full Cone。<br>当然，这个定义只是为了方便理解本文的内容而定下的。</p><p>Linux的NAT类型的影响范围：涉及了所有日渐普及的基于Linux的嵌入式网络设备，如家用光猫、家用智能路由器等。事实上，部分小区级别的ISP由于节约成本使用的也是基于Linux的NAT路由器，出于安全考虑这些路由器当然不会开启UPnP，因此这部分ISP的终端用户将不可能得到完整的Full Cone NAT。对于电信、移动等一级运营商，通过光纤入户的普通用户通常经过企业级LSN设备的NAT，至此入户部分的PPPoE拨号终端通常是Full Cone的，但是，由于一部分用户使用光猫拨号再由光猫NAT后路由至用户最终的计算机（这也是运营商推荐的方式），而光猫没有开启UPnP或DMZ（用户通常没有权限配置），这部分用户的终端设备也不可能得到Full Cone NAT而通常是Symmetric NAT。</p><p>因此作者认为，还是有必要在Linux上实现Full Cone NAT。Symmetric NAT意味着更高的安全性，而Cone NAT能兼容更多的应用程序。我们当然不会通过硬编码来实现这个feature，而应该是为用户提供一个新的选择。</p><h2 id="netfilter内核子系统和conntrack"><a href="#netfilter内核子系统和conntrack" class="headerlink" title="netfilter内核子系统和conntrack"></a>netfilter内核子系统和conntrack</h2><p>经过作者的各种尝试，要实现一个高效的原生Full Cone NAT，在应用层是无法实现的了（就算通过程序抓包后实时添加iptables规则，或从用户态刷新conntrack，也非常低效），因此，我们只能深入linux内核来进一步研究。</p><p><strong>HACK THE KERNEL!</strong></p><p>上文已有提到，在linux中负责处理nat的内核子系统是netfilter，而netfilter对应的前端有iptables和nftables。</p><p>为对nat的状态进行跟踪，netfilter引入了conntrack。conntrack用来记录每一个连接（TCP/UDP/ICMP/DCCP等会话）的双向地址和端口（或id, code等会话标识符）信息。netfilter对每一个conntrack定义了一个 <code>struct nf_conn</code> 结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> <span class="title">ct_general</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> status;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中，<code>tuplehash</code> 数组是我们需要关心的。该数组通常有2个成员：<code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 和 <code>tuplehash[IP_CT_DIR_REPLY]</code>。要了解它们分别代表什么，先来看一下 <code>struct nf_conntrack_tuple_hash</code> 里的 <code>struct nf_conntrack_tuple tuple</code> 成员。这个 <code>tuple</code> 结构定义如下（为便于理解，一些不在同一源文件定义的struct和union被整合进来）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>   <span class="comment">//tuple.src 指示了源地址和源会话标识符</span></span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr u3;    <span class="comment">//源IP地址（ipv4或ipv6）</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">      <span class="comment">// 这个union指示了源会话标识符，可以是一个TCP/UDP端口，或ICMP id，dccp port等。</span></span><br><span class="line">      <span class="comment">// 此处省略除TCP、UDP外的其它协议</span></span><br><span class="line">      __be16 all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; tcp;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; udp;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num;</span><br><span class="line">  &#125; src;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                  <span class="comment">//tuple.dst 指示了目的地址和目的会话标识符</span></span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr u3;  <span class="comment">//目的IP地址</span></span><br><span class="line">    <span class="keyword">union</span> &#123;                 <span class="comment">//和tuple.src一样，这个union指示了目的会话标识符</span></span><br><span class="line">      __be16 all;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; tcp;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">      &#125; udp;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">u_int8_t</span> protonum;      <span class="comment">//协议号</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> dir;</span><br><span class="line">  &#125; dst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>不难看出，<code>struct nf_conntrack_tuple</code> 结构是一个五元组，其包括了：源地址/源端口/目的地址/目的端口/协议号。而在刚才的 <code>tuplehash</code> 数组中，<code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 和 <code>tuplehash[IP_CT_DIR_REPLY]</code> 分别代表 “源五元组” 和 “期望收到的应答五元组”。在这里，你可以分别把它们暂时简单的理解为出站和入站的五元组，一个conntrack由一对五元组组成。</p><p>在 <code>tuplehash[IP_CT_DIR_ORIGINAL]</code> 中，<code>src</code> 指的是内网主机（或本机）的源地址，<code>dst</code> 指的是TCP/UDP流量的远端目的地址；而在 <code>tuplehash[IP_CT_DIR_REPLY]</code> 中，<code>src</code> 是TCP/UDP的远端主机的地址，<code>dst</code> 是本机的地址。</p><p>在内网主机经过NAT网关一次普通的SNAT后，一个conntrack存放的一对五元组tuple应包含如下信息：</p><ul><li><code>tuplehash[IP_CT_DIR_ORIGINAL].tuple</code> ： 相对于内网主机到远端主机的方向，如 <code>src</code>192.168.1.3:5000 -&gt; <code>dst</code>114.114.114.114:53</li><li><code>tuplehash[IP_CT_DIR_REPLY].tuple</code> ：相对于远端主机到本机的方向，如 <code>src</code>114.114.114.114:53 -&gt; <code>dst</code>120.239.65.166:38720 （其中120.239.65.166是本机即NAT网关的外网IP，38720是SNAT映射后得到的外网端口）</li></ul><p>参考nf_nat，我们可以概括出一次SNAT由如下步骤完成：</p><ol><li>来自内网主机的数据包流经nat表的POSTROUTING链并触发SNAT/MASQUERADE hook，nf_nat 进行源IP转换和端口映射，并调用 <code>nf_nat_setup_info()</code> 对当前conntrack（我们假设这个conntrack命名为conn1）的tuplehash信息进行修改，将转换后的源外网IP和映射后的外网端口写到 <code>tuplehash[IP_CT_DIR_REPLY].tuple.dst</code> 中。</li><li>当有新的数据包流入时，nf_conntrack_core 通过在 <code>resolve_normal_ct()</code> 中根据流入的数据包得到对应的一个tuple，因为这个tuple的信息与 conn1 的 <code>tuplehash[IP_CT_DIR_REPLY].tuple</code> 一致，调用 <code>nf_conntrack_find_get()</code> 即获取到先前的 conn1。</li><li>再根据 conn1 的 <code>tuplehash[IP_CT_DIR_ORIGINAL].tuple</code> 信息，将流入的数据包的目的IP和端口还原成内网主机的IP的端口。</li></ol><p>* 以上过程仅从代码层面推测，未经过严格debug验证，如实际过程有误欢迎提出。</p><h2 id="编写一个xt-FULLCONENAT内核模块"><a href="#编写一个xt-FULLCONENAT内核模块" class="headerlink" title="编写一个xt_FULLCONENAT内核模块"></a>编写一个xt_FULLCONENAT内核模块</h2><p>要实现一个原生的Full Cone NAT功能，至少需要编写一个netfilter内核模块，外加一个或多个前端模块（前端模块是在用户态的一个.so文件，不涉及内核态API）。</p><p>注意，我们现在只关注RFC3489，即只实现UDP的Full Cone。其它协议的内网穿透相对而言不太常用，我们暂且搁置。</p><p>在此列出以下两种实现方案：</p><ul><li>实现应用于mangle表的hook，对每个流出流入的包进行地址和端口信息修改。相当于手动实现一遍DNAT和SNAT。这种方案可以绕过conntrack对五元组的严格验证，但实现复杂，而且性能较差。</li><li>参考现有的NAT模块（如NETMAP），实现应用于nat表的hook。这种方案采用netfilter现有的nat方法来实现地址转换。但是受限于conntrack的五元组约束，除了需要依赖conntrack模块内置的映射规则来进行标准的nat，还需要另行在我们的模块中维护一张映射表。</li></ul><p>作者采用了第二种方案。大体的设想是：在nat表的POSTROUTING链和PREROUTING链各添加一个FULLCONENAT规则，对于POSTROUTING的操作，FULLCONENAT与MASQUERADE表现无异，但需要将“端口映射记录”暂存到本模块维护的映射表中；而在PREROUTING链，FULLCONENAT对于每一个未被conntrack记录的入站连接，根据本模块维护的端口映射表，<strong>按需DNAT</strong>至相应的内网主机。</p><p>在前端使用iptables时，应用本模块的规则应该是这样的（假设 <code>eth0</code> 是公网出口网卡）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j FULLCONENAT #same as MASQUERADE  </span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -j FULLCONENAT  #automatically restore NAT for inbound packets</span><br></pre></td></tr></table></figure></p><p>我们使用一个hashmap来维护这个端口映射表。作者定义了这样的一个hashmap节点：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">natmapping</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port;    <span class="comment">/* external port */</span></span><br><span class="line">  __be32 int_addr;  <span class="comment">/* internal ip address */</span></span><br><span class="line">  <span class="keyword">uint16_t</span> int_port; <span class="comment">/* internal port */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">original_tuple</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当FULLCONENAT target应用在POSTROUTING链时，我们实现与MASQUERADE基本相同的SNAT：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__be32 new_ip = get_device_ip(skb-&gt;dev);  <span class="comment">// 获取interface的本地IP</span></span><br><span class="line">newrange.min_addr.ip = new_ip;            <span class="comment">// 将nat ip限制为interface的本地IP</span></span><br><span class="line">newrange.max_addr.ip = new_ip;</span><br><span class="line">ret = nf_nat_setup_info(ct, &amp;newrange, HOOK2MANIP(xt_hooknum(par)));  <span class="comment">// 调用nf_nat_setup_info()进行SNAT</span></span><br></pre></td></tr></table></figure></p><p>然后，我们将映射结果保存到端口映射表中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ct_tuple_origin = &amp;(ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple);</span><br><span class="line">ct_tuple = &amp;(ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line">ip = (ct_tuple_origin-&gt;src).u3.ip;  <span class="comment">//这里获取到内网主机的IP</span></span><br><span class="line">original_port = be16_to_cpu((ct_tuple_origin-&gt;src).u.udp.port); <span class="comment">//内网主机的端口号</span></span><br><span class="line">port = be16_to_cpu((ct_tuple-&gt;dst).u.udp.port); <span class="comment">//映射后的外网端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把映射存进映射表中</span></span><br><span class="line">mapping = get_mapping(port);  <span class="comment">//根据外网端口号从映射表中获取对应的映射记录，可能创建了新的hashmap节点</span></span><br><span class="line">mapping-&gt;int_addr = ip;   <span class="comment">//内网主机的IP</span></span><br><span class="line">mapping-&gt;int_port = original_port;  <span class="comment">//内网主机的端口号</span></span><br><span class="line"><span class="comment">//拷贝整个tuplehash[IP_CT_DIR_ORIGINAL].tuple，至于为什么这么做稍后会解释</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;mapping-&gt;original_tuple, ct_tuple_origin, <span class="keyword">sizeof</span>(struct nf_conntrack_tuple));</span><br></pre></td></tr></table></figure></p><p>当FULLCONENAT target应用在PREROUTING链时，我们需要实时查询映射表，并实现相应的DNAT：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ct_tuple = &amp;(ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple);</span><br><span class="line">ip = (ct_tuple-&gt;src).u3.ip;   <span class="comment">//外网IP</span></span><br><span class="line">port = be16_to_cpu((ct_tuple-&gt;dst).u.udp.port); <span class="comment">//外网端口号</span></span><br><span class="line">mapping = get_mapping(port); <span class="comment">//根据外网端口号从映射表中获取对应的映射记录</span></span><br><span class="line"><span class="keyword">if</span> (is_mapping_active(mapping, ct)) &#123;</span><br><span class="line">  <span class="comment">//如果映射记录有效，则继续根据该映射记录执行DNAT：</span></span><br><span class="line">  newrange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;</span><br><span class="line">  newrange.min_addr.ip = mapping-&gt;int_addr;   <span class="comment">//将nat ip限制为内网主机IP</span></span><br><span class="line">  newrange.max_addr.ip = mapping-&gt;int_addr;</span><br><span class="line">  newrange.min_proto.udp.port = cpu_to_be16(mapping-&gt;int_port);   <span class="comment">//将nat port限制为内网主机端口号</span></span><br><span class="line">  newrange.max_proto = newrange.min_proto;</span><br><span class="line">  ret = nf_nat_setup_info(ct, &amp;newrange, HOOK2MANIP(xt_hooknum(par)));  <span class="comment">// 调用nf_nat_setup_info()进行DNAT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于如何“在conntrack失效（超时）时，主动从映射表中删除对应的映射记录”，作者目前暂时未找到好的方法（尽量不改动nf_conntrack部分，是否能够注册ct失效回调？）。也就是说现在这个映射表“只能添加和替换记录，而不能删除记录”（映射表的长度不会超过映射端口的范围，暂时不会导致严重的内存泄漏问题）。</p><p>为了确保在DNAT之前，先前SNAT时注册的conntrack仍然有效，作者实现了一个 <code>is_mapping_active()</code> 函数，该函数调用 <code>nf_conntrack_find_get()</code> ，通过在映射记录中保存的 <code>original_tuple</code> 来查询对应的conntrack，如果查找结果为空，则认为该conntrack已失效，否则认为该conntrack仍然有效，并继续进行DNAT。当然，这并不是最好的方法，如果你有更好的建议，欢迎联系我。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_mapping_active</span><span class="params">(<span class="keyword">const</span> struct natmapping* mapping, <span class="keyword">const</span> struct nf_conn *ct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *<span class="title">original_tuple_hash</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (mapping-&gt;port == <span class="number">0</span> || mapping-&gt;int_addr == <span class="number">0</span> || mapping-&gt;int_port == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* get corresponding conntrack from the saved tuple */</span></span><br><span class="line">  net = nf_ct_net(ct);</span><br><span class="line">  zone = nf_ct_zone(ct);</span><br><span class="line">  <span class="keyword">if</span> (net == <span class="literal">NULL</span> || zone == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  original_tuple_hash = nf_conntrack_find_get(net, zone, &amp;mapping-&gt;original_tuple);</span><br><span class="line">  <span class="keyword">if</span> (original_tuple_hash) &#123;</span><br><span class="line">    <span class="comment">/* if the corresponding conntrack is found, consider the mapping is active */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们的xt_FULLCONENAT模块的核心部分已阐述完毕。除此之外，还需要编写对应的前端模块，作者参考了ipt_MASQUERADE，通过简单的关键字替换实现了ipt_FULLCONENAT，作为iptables extension可提供给iptables使用。</p><p>这个内核模块以及iptables extension的完整代码、编译和安装方法请参考GitHub仓库： <a href="https://github.com/Chion82/netfilter-full-cone-nat" target="_blank" rel="noopener">https://github.com/Chion82/netfilter-full-cone-nat</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>使用了Linux设备作为NAT网关，内网主机运行STUN测试的测试结果是Port Restricted Cone NAT，而不是Symmetric NAT。<br>这是因为Stun和netfilter对映射要素的理解存在差异造成的，具体可参考 <a href="http://blog.csdn.net/u011245325/article/details/9294229" target="_blank" rel="noopener">这篇文章</a>。但不能因此就断定linux的SNAT不是Symmetric。实际上，这是因为linux NAT网关上存在这条iptables规则导致的（OpenWRT发行版的firewall默认存在这条规则，虽然是在INPUT的子链中）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -i eth0 -j REJECT #或者INPUT的policy为REJECT</span><br></pre></td></tr></table></figure></li></ul><p>如果删除了这条规则（在OpenWRT上则是在Firewall设置中，将wan zone的Input策略从reject改为accept），内网主机运行STUN测试的结果会始终是Symmetric NAT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3489.txt&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="network" scheme="https://blog.chionlab.moe/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>kcptun-raw：应对UDP QoS，重新实现kcptun的一次尝试</title>
    <link href="https://blog.chionlab.moe/2017/04/06/kcptun-with-fake-tcp/"/>
    <id>https://blog.chionlab.moe/2017/04/06/kcptun-with-fake-tcp/</id>
    <published>2017-04-06T04:43:56.000Z</published>
    <updated>2017-04-23T05:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于KCP ARQ协议和kcptun请见：<br><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a><br><a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a><br>本文程序源码：<br><a href="https://github.com/Chion82/kcptun-raw" target="_blank" rel="noopener">https://github.com/Chion82/kcptun-raw</a></p></blockquote><h2 id="UDP断流问题"><a href="#UDP断流问题" class="headerlink" title="UDP断流问题"></a>UDP断流问题</h2><p>我们知道kcptun的底层协议是UDP，而很多ISP对大流量UDP会做QoS，这包括了大量issue反映的“断流”问题：在正常运行一段时间之后流量会中断，需要等待数分钟才能恢复，有时候除非更换端口，将一直保持0速度。<br>kcptun作者对此的解决方法是使用<code>--autoexpire</code>参数设置UDP连接超时并自动重连（补充：UDP虽无连接状态，但仍有会话保持机制），但此举治标不治本，对于QoS频繁的网络环境需要频繁更改UDP端口，而该过程可能会导致kcptun的上层连接（本地TCP连接）中断。<br>为了解决断流问题，各位网友各出奇招，比如 <a href="https://github.com/xtaci/kcptun/issues/228" target="_blank" rel="noopener">issue #228</a> 提到的端口随机化、上下行分不同端口等，都能一定程度缓解该问题，然而这仍然都是治标不治本的方法。<br>你可能理所当然的认为，“下层协议用TCP不就好了”（即kcp over tcp）。是的，ISP对TCP做的QoS要“宽容”很多（完全断流且不能恢复的几率不大），如果将kcptun的下层协议换成TCP，应该可以解决我们的问题？<br>答案是NO。UDP和TCP的一个重要区别是，UDP是不可靠的、基于message的实时性协议，而TCP是可靠的、基于stream的非实时性协议。而KCP作为可靠的ARQ算法，所依赖的下层协议必须保证实时性，而可靠性并不需要保证。如果我们直接将下层协议换成TCP，则流量会先经过操作系统内核进行拥塞控制和纠错处理，再递交kcp层，这样一来kcp的优化拥塞控制算法就完全没有发挥作用。</p><h2 id="伪装TCP流量的可行性"><a href="#伪装TCP流量的可行性" class="headerlink" title="伪装TCP流量的可行性"></a>伪装TCP流量的可行性</h2><p>要解决UDP断流问题，不更换下层协议是很难做到的。于是我想到，能不能直接使用网络层的IP packet作为kcp的下层协议。因为边缘路由器一般是在OSI网络层进行转发，所以在公网环境下是可行的。然而我们的客户端都是在ISP内网环境，这将不现实：因为NAT需要跟踪运输层头部数据，如双方的端口信息。后来我发现了 <a href="https://github.com/linhua55" target="_blank" rel="noopener">linhua55</a> 同学的 <a href="https://github.com/linhua55/some_kcptun_tools/tree/master/relayRawSocket" target="_blank" rel="noopener">some_kcptun_tools/relayRawSocket</a> 项目，这位同学写了个简单的python脚本实现了“fake TCP to UDP”的中继，通过raw socket来实现带静态TCP头部的IP packet收发，并转发到上层UDP。经测试，这个脚本能一定程度上解决断流问题，但存在带宽利用率不高、不稳定的问题。<br>受这个项目的启发，我想使用同样的原理重新实现一个简单的kcptun：下层协议更换为带TCP头的packet（通过raw socket或libpcap等实现），使ISP认为这是TCP流量。但这并不是严格的“kcp over tcp”，因为我们完全绕过系统内核的TCP/IP内核栈对流量的管控而直接交由kcp进行拥塞控制和纠错。这样一来，我们我们能够保证下层报文递交到kcp算法时的实时性。<br>换言之，我们需要 <strong>在用户态模拟从IP到TCP的协议栈</strong>。</p><p>在造轮子之前，需要验证这些带了伪TCP header的IP header是否能够在网络上正常收发。于是编写了这么的一个实验程序：<br><a href="https://gist.github.com/Chion82/699ae432a27507242ea788df324f4e47" target="_blank" rel="noopener">https://gist.github.com/Chion82/699ae432a27507242ea788df324f4e47</a></p><p>该程序修改自网上的一段SYN flood程序。<br>通过修改IP信息，编译出<code>client</code>和<code>server</code>两个bin，即可测试本地到服务端的双向连通性。若测试成功，双方都能收到对方的一条text消息。<br>这个程序使用raw socket实现packet收发，由程序直接拼装TCP和IP报头：在 <code>trans_packet.c</code> 中，借助 <code>struct iphdr</code> 和 <code>struct tcphdr</code> 两个结构来拼接，TCP头是静态的，置flag SYN=1。<br>在接收packet时，由于使用了 <code>ETH_P_ALL</code> 过滤器（为什么不使用 <code>IPPROTO_TCP</code> 后面会提到），经过全部网卡的所有packet都会被捕捉，因此要通过判断IP头协议以及TCP头目标端口进行过滤。</p><p>这个实验程序说明了伪装TCP流量实现双向通信是可行的。因为要使用raw socket来重写kcptun，我们就称这个项目为“kcptun-raw”吧。</p><h2 id="绕过内核TCP-IP协议栈"><a href="#绕过内核TCP-IP协议栈" class="headerlink" title="绕过内核TCP/IP协议栈"></a>绕过内核TCP/IP协议栈</h2><p>由于我们在用户态直接使用raw socket发送IP报文，双方的内核都对这个我们手动模拟的TCP连接不知情，因此当内核收到对方发送的IP报文时，内核根据报文中的TCP头信息（这些信息是我们手动拼接的）试图寻找TCP连接跟踪信息并且寻找失败，随即认为该报文是无效的，内核接着会试图“终止”我们模拟的TCP连接，并向对方发送一个RST包。该RST包会导致中间路由器认为连接已被重置，撤销打通的NAT pipe，使得接下来发送的报文都不能到达对方。</p><p>因此，我们需要使这些IP报文绕过内核的TCP/IP协议栈，以此来避免内核对我们模拟的TCP连接的干涉。这可以通过Linux的<code>iptables</code>的<code>DROP</code>命令实现。<br>假设服务端IP为<code>108.0.0.1</code>，模拟TCP连接的端口为<code>888</code>，在服务端的iptables命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 888 -j DROP</span><br></pre></td></tr></table></figure></p><p>对应的客户端命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -s 108.0.0.1 --sport 888 -j DROP</span><br></pre></td></tr></table></figure></p><p>在使用了<code>DROP</code>操作后，如果raw socket继续使用 <code>IPPROTO_TCP</code> 过滤器，将无法接收到该端口上的任何报文。因此，我们将使用 <code>ETH_P_ALL</code>，接收流经网卡的全部IP报文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> packet_recv_sd = socket(AF_PACKET , SOCK_DGRAM , htons(ETH_P_IP));</span><br></pre></td></tr></table></figure></p><p>linhua55同学在 <a href="https://github.com/Chion82/kcptun-raw/issues/2" target="_blank" rel="noopener">Issue #2</a> 中提到Windows下绕过内核协议栈的方法，即通过 <code>ipseccmd.exe</code> 或 <code>netsh</code> 命令。</p><h2 id="动态TCP-header和模拟三次握手"><a href="#动态TCP-header和模拟三次握手" class="headerlink" title="动态TCP header和模拟三次握手"></a>动态TCP header和模拟三次握手</h2><p>作者在几个ISP网络环境下进行了测试，发现部分环境下静态TCP报头无法传送到服务端，或是服务端返回的packet客户端收不到，这种情况下需要模拟TCP三次握手过程。另外，将TCP报头的seq/ack参数改为动态自增可以增强稳定性，而有的环境下则必须保持定值。<br>具体测试结果如下（<a href="https://github.com/linhua55/some_kcptun_tools/issues/2" target="_blank" rel="noopener">Issue #2</a>）：</p><ul><li>广东移动：<ul><li>服务端ack flag必须置为1，否则客户端将一直收不到服务端的packet。</li><li>seq/ack序列需要一直保持定值，如果一直自增会被QoS随后pipe被掐断；</li></ul></li><li>广电宽带（广东）和电信4G：<ul><li>必须模拟TCP三次握手过程，即 客户端SYN-&gt;服务端SYN+ACK-&gt;客户端ACK ，随后pipe才能打通。</li><li>seq/ack序列无要求，保持定值和一直自增都可以。</li></ul></li><li>服务器提供商（阿里云等）：<ul><li>vps之间通信基本无限制，在防火墙关闭的情况下，packet想怎么发都可以（因为没有经过NAT和ISP的QoS的缘故？）</li></ul></li></ul><h2 id="报文分层设计和流控"><a href="#报文分层设计和流控" class="headerlink" title="报文分层设计和流控"></a>报文分层设计和流控</h2><p>在确认了下层协议的实现可行性之后，作者即开始动手开发kcptun-raw。</p><h3 id="第一次报文分层"><a href="#第一次报文分层" class="headerlink" title="第一次报文分层"></a>第一次报文分层</h3><p>作为隧道，最上层协议当然是TCP，而KCP的下层协议是packet。一开始理所当然的想法是，一个上层的TCP连接对应一个KCP连接，而全部KCP连接共用同一个伪造的TCP连接并在其上传输带伪造TCP头的packet作为最下层传输协议。而最下层的packet封包除了传输多个kcp连接的片段数据（KCP segment），还用于传送命令，这些命令包括建立连接、关闭连接和保活命令等。<br>这样，一次上层TCP连接从建立到断开的分层流程大致如下：<br>客户端：</p><blockquote><table><thead><tr><th>→</th><th>→</th><th>→</th><th>→</th><th>→</th></tr></thead><tbody><tr><td>TCP</td><td>↓ 新连接</td><td>↓ 接收数据</td><td>↑ 发送数据</td><td>↓ 断开连接</td></tr><tr><td>KCP</td><td>↓ 新连接</td><td>↓ 发送KCP片段</td><td>↑ 接收KCP片段</td><td>↓ 杀死</td></tr><tr><td>packet</td><td>↓ 推送新连接</td><td>↓ 推送数据段</td><td>↑ 接收数据段</td><td>↓ 推送关闭连接</td></tr></tbody></table></blockquote><p>服务端：</p><blockquote><table><thead><tr><th>→</th><th>→</th><th>→</th><th>→</th><th>→</th></tr></thead><tbody><tr><td>TCP</td><td>↑ 新连接</td><td>↑ 发送数据</td><td>↓ 接收数据</td><td>↑ 断开连接</td></tr><tr><td>KCP</td><td>↑ 新连接</td><td>↑ 接收KCP片段</td><td>↓ 发送KCP片段</td><td>↑ 杀死</td></tr><tr><td>packet</td><td>↑ 对方推送新连接</td><td>↑ 接收数据段</td><td>↓ 发送数据段</td><td>↑ 对方推送关闭连接</td></tr></tbody></table></blockquote><p>这看起来没有什么问题。然而这忽略了一个很重要的东西：命令封包丢失。如果丢失的是KCP的数据段封包，这没有什么问题——KCP会自动处理好重发、拥塞和纠错策略，以保证上交到TCP层的数据是正确完整的；但是如果丢失的是建立连接或断开连接的命令封包，问题就很严重了，这会导致客户端的新TCP连接迟迟无法响应、或是其中一方的TCP连接变成“僵尸连接”（其中一方已关闭连接，而主动关闭命令未送达）。这正是为什么TCP需要三次握手和四次挥手的原因：为了处理在边界情况下的各种丢包情况。</p><h3 id="MUX层、共享KCP连接"><a href="#MUX层、共享KCP连接" class="headerlink" title="MUX层、共享KCP连接"></a>MUX层、共享KCP连接</h3><p>要解决这个问题，我们需要重新设计一次报文分层。因为KCP层以上的数据都是可靠的，因此我们可以共享kcp连接，并在此之上传送命令封包和数据封包。要实现这样的设计，我们要在TCP层之下引入MUX层。MUX即Stream Multiplexing，这样我们可以在唯一的KCP流上进行多路复用。为此我们重新设计在KCP流上传输的封包类型：标识了TCP流ID的数据帧、新连接命令、断开连接命令、保活命令。</p><p>其次，考虑到加密封包和checksum验证，最终设计的数据流分层以及对应的payload定义如下：<br><img src="https://raw.githubusercontent.com/Chion82/kcptun-raw/master/layers.png" alt=""></p><h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>为什么需要流控？考虑这样的一个情景：服务端的TCP连接在1s内接收了100MB的数据（如果是跑在服务器本机的服务，这个速度很正常），并一下子全部经由KCP传送给客户端，而受服务端到客户端的带宽所限，这100MB数据需要2min才能传输完成，此时服务端的KCP发送队列十分拥塞，如果这时服务端上有另一个TCP连接接收到了数据，这部分数据帧将追加到KCP发送队列的队尾，并迟迟发不出去，直至100MB的数据传输完毕。这样的直接表现是，正在全速下载大文件时，发出的新连接请求要等到文件下载完毕后才得到响应，并发性能极差。</p><p>为了避免这个问题，我们需要双向流控来实现双边连接的同步：当对方<code>kcp_recv()</code>速度远慢于己方<code>tcp_recv()</code>速度，导致己方KCP发送队列长时，及时暂停己方的<code>tcp_recv()</code>；当己方的TCP发送队列长（表现为非阻塞socket下、<code>send()</code> 后得到 <code>EAGAIN</code> ），暂停己方的<code>kcp_recv()</code>，以增加对方的KCP发送队列长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kcp_update_interval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//遍历活跃的TCP连接，并检测其发送队列长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector_total(&amp;open_connections_vector); i++) &#123;</span><br><span class="line">    connection = vector_get(&amp;open_connections_vector, i);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;in_use &amp;&amp; (connection-&gt;pending_send_buf_len) &gt; MAX_QUEUE_LENGTH * BUFFER_SIZE) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">//TCP发送队列过长，暂停KCP接收</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//KCP接收数据</span></span><br><span class="line">  <span class="keyword">int</span> recv_len = ikcp_recv(kcp, recv_buf, BUFFER_SIZE);</span><br><span class="line">  <span class="comment">//根据KCP发送队列长度判断是否暂停TCP recv()操作</span></span><br><span class="line">  <span class="keyword">int</span> stop_recv = (iqueue_get_len(&amp;(kcp-&gt;snd_queue)) &gt; MAX_QUEUE_LENGTH) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p>在确定了各项设计后，我们可以开始着手开发kcptun-raw了。程序使用非阻塞socket，借助 <a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">libev</a> 库实现高性能的事件并发模型，避免使用多线程/进程。</p><p>kcptun-raw的开发前后遇到了不少困难，不过最终还是做出来了。经过我的测试，效果还是不错的，单线程下载速度最高在15~20 Mbytes/s，最大并发连接数程序写死了8192（当然一般是到不了这么大的）。</p><h3 id="稳定性和保活"><a href="#稳定性和保活" class="headerlink" title="稳定性和保活"></a>稳定性和保活</h3><p>为了保证程序长期运行的稳定性，以应对各种不可避免的网络断流问题，我写了两层保活机制：</p><ul><li>模拟TCP层保活：packet层的心跳检测，超时则更换客户端端口、重新建立模拟TCP连接。</li><li>KCP层保活：在KCP流上的心跳检测，timeout时限比TCP层更长，一旦超时，将立即关闭所有上层TCP连接，重新初始化KCP流，并通知对方重新初始化KCP流。<br>一般情况下，模拟TCP层的保活可以解决绝大多数断流问题——这正是两层保活的优点：下层的自动重连不会影响到KCP流和TCP连接，而当迫不得已需要重启KCP流时，必须中断全部上层TCP连接，以保证双方数据帧的同步。</li></ul><p>经过我的测试和issue反馈，kcptun-raw目前的稳定性已经很不错了。我在软路由上运行kcptun-raw来加速VPN已经大半个月了，期间一直没有重启过。</p><h2 id="几个问题？"><a href="#几个问题？" class="headerlink" title="几个问题？"></a>几个问题？</h2><ul><li><p>kcptun-raw还有待改进的地方？<br>目前kcptun-raw的设计是简化的kcptun，特别是取消了FEC，现在发现取消了FEC后会存在延迟抖动、带宽利用率比不上原版kcptun的问题。日后如果发现有需要，会考虑引入FEC。</p></li><li><p>4.9内核后引入了BBR拥塞算法，为何还需要kcptun？或者说BBR能否为KCP提供一点改进思路？<br>首先，BBR和KCP是工作在两个不同层面的东西：BBR在内核态直接作为TCP/IP协议栈的模块，接管所有TCP连接的拥塞控制，其原理是抛弃老旧的基于丢包检测的窗口控制算法，改为主动探测水管大小，避免网络设备的缓冲区满；KCP则是通过牺牲一部分公平性原则、以大流量换取小延迟的算法，基本原理是激进重传，会消耗20%~30%额外的带宽。经过我的测试，大多时候BBR虽然传输速度比kcptun更快，但是BBR未能解决被QoS的问题：一个TCP连接一旦断流，速度将一直不能恢复，需要重新建立TCP连接方可恢复。这是当然的，因为BBR只是作为接管内核原来的TCP拥塞算法，它是针对per TCP connection而工作的，并没有改变协议栈的分层约定。而kcptun-raw作为上层TCP到下层自定义协议的隧道工具，TCP层以下的协议规则约定是可以自定义的，当下层连接断流了，该层可以自动重连，而这不会导致上层TCP连接的断开，这是解决QoS的关键所在。</p></li><li><p>另外，快乐膜法师同学基于原版kcptun，也写了一个基于raw socket和伪造TCP的改版，同时支持Linux、MacOS和Windows，并且还有伪装HTTP流量的功能，需要给运营商薅羊毛的同学可以参考：<br><a href="https://github.com/ccsexyz/kcpraw" target="_blank" rel="noopener">https://github.com/ccsexyz/kcpraw</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于KCP ARQ协议和kcptun请见：&lt;br&gt;&lt;a href=&quot;https://github.com/skywind3000/kcp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/skyw
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="network" scheme="https://blog.chionlab.moe/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>再谈React同构应用：服务端下复用Redux Effects的实践</title>
    <link href="https://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/"/>
    <id>https://blog.chionlab.moe/2016/12/21/universal-react-app-reuse-effects-on-server-side/</id>
    <published>2016-12-21T10:07:32.000Z</published>
    <updated>2017-03-01T14:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>同构 (universal/isomorphic) React应用旨在服务端（或者是网关层、中途岛层）和客户端（浏览器端）尽可能地复用UI组件的代码，以提高项目的可维护性。当同构应用引入以 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">Redux</a> 为首的数据流管理、以 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a> 为主的SPA前端路由后，同构应用将变得复杂：我们需要在服务端和客户端之间同步状态（store）和路由信息，并且尽可能地复用这些数据逻辑（如reducers）和路由配置。关于如何搭建这样的一个项目框架，你可以阅读 <a href="https://blog.tableflip.io/server-side-rendering-with-react-and-redux/" target="_blank" rel="noopener">Server Side Rendering with React and Redux</a>。</p><p>本文假设你已经熟悉如何搭建一个 React + Redux + react-router 的同构应用，我们来讨论Redux副作用（side effects，后面简称effects）在服务端复用的逐步尝试和实践。</p><h2 id="目前的典型场景"><a href="#目前的典型场景" class="headerlink" title="目前的典型场景"></a>目前的典型场景</h2><p>目前大多数React同构脚手架均不在服务端复用effects，而是通过直接调用Service模块的方式来加载数据，这使得我们可以直接获知异步任务何时完成，并在回调函数中直接执行我们的渲染逻辑。在渲染逻辑中，因为页面初始数据已经取得，从创建store到调用<code>store.getState()</code>来初始化渲染模板都是同步的，没有任何坑点，它看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">APIService.getTodos().then(<span class="function">(<span class="params">initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> store = configureStore(makeInitialState(initialData));</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</span><br><span class="line">  <span class="keyword">const</span> state = store.getState()</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="例：universal-react-starter-kit"><a href="#例：universal-react-starter-kit" class="headerlink" title="例：universal-react-starter-kit"></a>例：universal-react-starter-kit</h3><p>以国内比较流行的脚手架 <a href="https://github.com/bodyno/universal-react-starter-kit" target="_blank" rel="noopener">bodyno/universal-react-starter-kit</a> 为例，其渲染部分的关键代码是这样的：<br><em>server/main.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = <span class="keyword">await</span> router(ctx)</span><br><span class="line"><span class="keyword">const</span> store = createStore(initialState, memoryHistory)</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">match(&#123;history, routes, <span class="attr">location</span>: ctx.req.url&#125;, <span class="keyword">async</span> (err, redirect, props) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">let</span> layout = &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">      &#123;<span class="attr">type</span>: <span class="string">'text/javascript'</span>, <span class="attr">innerHTML</span>: <span class="string">`___INITIAL_STATE__ = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(store.getState())&#125;</span>`</span>&#125;,</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    ]&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  content = renderToString(</span><br><span class="line">    &lt;AppContainer layout=&#123;layout&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其中 <code>await router(ctx)</code>的<code>router</code>部分代码如下：<br><em>server/router.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    axios.get(<span class="string">'https://api.github.com/zen'</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">zen</span>: &#123; <span class="attr">text</span>: [&#123;<span class="attr">text</span>: data&#125;]&#125; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>await router(ctx)</code>在此处就是一次Service API调用。先不论这个<code>router</code>是否名不符实（可能因为是脚手架的原因。router.js应该是给开发者填入代码来实现对应不同路由调用不同的Service），这个脚手架的渲染逻辑跟上文的示例大同小异——直接调用Service模块异步取得初始数据，在回调（await）中通过全同步的方式用初始数据产生store并<code>getState()</code>，然后调用<code>renderToString()</code>渲染。</p><p>在服务端通过“直捅Service”的方式来获取页面初始数据，是最直接、最简单的方法。当然我们在客户端绝对不会这么做，在客户端我们会设计好同步的actions和reducers，并通过触发effects来实现异步数据获取。为了使我们的服务端代码更优雅、维护性更强、代码复用度更高，我们希望在服务端能够复用这些actions、reducers和effects。</p><h2 id="使用redux-thunk的场景"><a href="#使用redux-thunk的场景" class="headerlink" title="使用redux-thunk的场景"></a>使用redux-thunk的场景</h2><p>在服务端执行一个effect是很简单的，我们只需要调用在服务端和客户端间共享的<code>configureStore()</code>函数来创建一个空的store（这时你将拥有effects所必须的middleware），然后调用<code>store.dispatch()</code>来触发一个绑定了effects的action即可。难点是：程序如何得知一个异步effects已经执行完成？这样我们才能在effects完成后调用<code>store.getState()</code>来取得带初始数据的state。<br>如果你的项目所使用的effects是 <a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>，你可以很容易地在服务端复用它们：你只需要在thunk函数中返回一个promise即可——而这是官方建议的标准写法。这样，<code>store.dispatch()</code>可以直接返回这个promise。<br>你的async thunk action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> APIService.getTodos()</span><br><span class="line">      .then(<span class="function"><span class="params">payload</span> =&gt;</span> dispatch(&#123;</span><br><span class="line">        type: <span class="string">'todos/get/success'</span>,</span><br><span class="line">        payload,</span><br><span class="line">      &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>APIService看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APIService = &#123;</span><br><span class="line">  getTodos: <span class="function"><span class="params">()</span> =&gt;</span> fetch(<span class="string">'/api/todos'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，在服务端的渲染逻辑，你可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString( <span class="comment">/* ... */</span> );</span><br><span class="line">    <span class="keyword">const</span> state = store.getState()</span><br><span class="line">    renderFullPage(html, state);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>另外，还有 <a href="https://github.com/acdlite/redux-promise" target="_blank" rel="noopener">redux-promise</a> 的effects解决方案。在服务端复用方面，redux-promise和redux-thunk极为相似，因为使用redux-promise同样可以通过<code>store.dispatch()</code>获得异步任务的promise。<br>唯一的不同之处是，当使用redux-promise时，async action creator看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'todos/get'</span>,</span><br><span class="line">    payload: APIService.getTodos(), <span class="comment">//action.payload是一个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例：react-redux-universal-hot-example"><a href="#例：react-redux-universal-hot-example" class="headerlink" title="例：react-redux-universal-hot-example"></a>例：react-redux-universal-hot-example</h3><p>让我们来看看GitHub上stars最多的Universal React脚手架 <a href="https://github.com/erikras/react-redux-universal-hot-example" target="_blank" rel="noopener">erikras/react-redux-universal-hot-example</a> 是怎么解决的。<br>这个脚手架使用了 <a href="https://github.com/Rezonans/redux-async-connect" target="_blank" rel="noopener">redux-async-connect</a> middleware，这使得我们可以绑定一个promise给每一个container，并在服务端使用它提供的<code>loadOnServer()</code>方法获得待渲染的container的异步任务及其promise。<br><em>src/containers/App/App.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@asyncConnect([&#123;</span><br><span class="line">  promise: <span class="function">(<span class="params">&#123;store: &#123;dispatch, getState&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> promises = [];</span><br><span class="line">    <span class="keyword">if</span> (!isInfoLoaded(getState())) &#123;</span><br><span class="line">      promises.push(dispatch(loadInfo()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isAuthLoaded(getState())) &#123;</span><br><span class="line">      promises.push(dispatch(loadAuth()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;])</span><br><span class="line">@connect(</span><br><span class="line">  state =&gt; (&#123;<span class="attr">user</span>: state.auth.user&#125;),</span><br><span class="line">  &#123;logout, <span class="attr">pushState</span>: push&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>src/server.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loadOnServer(&#123;...renderProps, store, <span class="attr">helpers</span>: &#123;client&#125;&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> component = (</span><br><span class="line">    &lt;Provider store=&#123;store&#125; key=<span class="string">"provider"</span>&gt;</span><br><span class="line">      &lt;ReduxAsyncConnect &#123;...renderProps&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  res.status(200);</span></span><br><span class="line"><span class="regexp">  global.navigator = &#123;userAgent: req.headers['user-agent']&#125;;</span></span><br><span class="line"><span class="regexp">  res.send('&lt;!doctype html&gt;\n' +</span></span><br><span class="line"><span class="regexp">    ReactDOM.renderToString(&lt;Html assets=&#123;webpackIsomorphicTools.assets()&#125; component=&#123;component&#125; store=&#123;store&#125;/</span>&gt;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>从上面的代码中，我们看到：</p><ul><li>作者使用redux-async-connect将container和一个promise绑定，这个promise执行多个<code>dispatch()</code>调用，当它们返回的promise都resolve时才resolve自身。</li><li>服务端通过调用已经绑定的<code>loadOnServer()</code>方法得到上述的这个promise，从而可以直接在<code>.then()</code>中填写该promise执行完成后的同步渲染逻辑。</li><li>之所以能够这么做，还是依赖于redux-thunk的<code>store.dispatch()</code>调用能够返回异步任务对应的promise。</li></ul><h2 id="使用redux-saga的场景"><a href="#使用redux-saga的场景" class="headerlink" title="使用redux-saga的场景"></a>使用redux-saga的场景</h2><p>然而，对于业务逻辑逐渐复杂的Web APP，redux-thunk或许不能满足复杂的数据流场景。现在国内最流行的Effects方案莫过于  <a href="https://github.com/yelouafi/redux-saga" target="_blank" rel="noopener">redux-saga</a> 了。</p><p>redux-saga使得异步effects完全脱离于原生Redux数据流，没有Async Action creator（你甚至不需要多余的Action Creator）。Saga effects更像是运行于另一个线程的一组任务（除了Web Worker外目前客户端JavaScript还没有真正意义上的多线程），这些任务可以监听特定的action，并在不直接影响Redux数据流的前提下执行异步操作。</p><p>因为redux-saga的这些优点，使得它可以实现更复杂的异步数据流，保留更纯净的原生Redux流，这非常优雅。而正因如此，它不会对<code>store.dispatch()</code>的返回值做任何更改——这意味着，在服务端我们不能指望仅仅通过<code>store.dispatch()</code>就能获知我们的初始数据何时到达。</p><p>这时我想到了参考已有的、使用redux-saga的同构脚手架。</p><h3 id="dva提供的同构脚手架"><a href="#dva提供的同构脚手架" class="headerlink" title="dva提供的同构脚手架"></a>dva提供的同构脚手架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> ——蚂蚁金服推出的一个轻量级框架，基于redux、redux-saga和react-router，让你能够使用类似 <a href="http://elm-lang.org" target="_blank" rel="noopener">elm-lang</a> 的声明性风格来组织你的代码。</p><p>dva官方提供的同构脚手架是 <a href="https://github.com/sorrycc/dva-boilerplate-isomorphic" target="_blank" rel="noopener">sorrycc/dva-boilerplate-isomorphic</a> 。让我们来看看它是怎么解决saga在服务端下的渲染的。<br><em>server/ssrMiddleware.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchList &#125; <span class="keyword">from</span> <span class="string">'../common/services/user'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">fetchList()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; err, data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = &#123; <span class="attr">user</span>: data &#125;;</span><br><span class="line">    <span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">      history: createMemoryHistory(),</span><br><span class="line">      initialState,</span><br><span class="line">    &#125;, <span class="comment">/* isServer */</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> html = renderToString(app.start()(&#123; renderProps &#125;));</span><br><span class="line">    res.end(renderFullPage(html, initialState));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p><em>common/services/user.js</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'../utils/request'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">'/api/users'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，相信大家都明白了。dva在这里的服务端逻辑是“直捅Service”的。dva的官方脚手架并没有解决我们的问题。</p><h3 id="官方建议的runSaga"><a href="#官方建议的runSaga" class="headerlink" title="官方建议的runSaga()"></a>官方建议的runSaga()</h3><p>事实上，对于redux-saga的服务端渲染问题，早就有关于这个的讨论，参考 <a href="https://github.com/yelouafi/redux-saga/issues/13" target="_blank" rel="noopener">issue #13</a> 。而redux-saga已添加了 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#runsagaiterator-options" target="_blank" rel="noopener">runSaga()</a> 方法来实现在服务端复用saga effects。</p><p><code>runSaga()</code>接收一个<code>saga</code>对象和必须的store输入输出方法（<code>subscribe()</code>和<code>dispatch()</code>等），允许在store上下文之外执行一个saga任务，并返回一个<code>Task</code>实例对象。返回的<code>Task</code>对象中的<code>done</code>属性是一个promise对象的引用，该promise在传入的saga任务执行完成后resolve。</p><p>假设我们有这样的一个saga effect：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.getTodos);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get/success'</span>, payload &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于我们可以获得store上下文和<code>sagaMiddleware</code>，在这里我们可以直接使用<code>sagaMiddleware.run()</code>来代替<code>runSaga()</code>。<code>sagaMiddleware.run()</code>同样返回对应这个saga任务的<code>Task</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState, compose(applyMiddleware(sagaMiddleware)));</span><br><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>至此，我们貌似已经能够比较完美地在服务端复用saga effects了。</p><h3 id="更为复杂的saga"><a href="#更为复杂的saga" class="headerlink" title="更为复杂的saga"></a>更为复杂的saga</h3><p>如果我们的saga比较复杂呢？比如像这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loginFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> take(<span class="string">'user/login'</span>);</span><br><span class="line">    <span class="keyword">const</span> payload = <span class="keyword">yield</span> call(APIService.login);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/login/success'</span>, payload &#125;);</span><br><span class="line">    <span class="keyword">yield</span> take(<span class="string">'user/logout'</span>);</span><br><span class="line">    <span class="keyword">yield</span> call(APIService.logout);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'user/logout/success'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个task是一个典型的infinite saga flow，也是redux-saga相对于其他effects所独有的特性：我们可以随心所欲地定义“看起来是阻塞”的数据流任务，来解决复杂的业务场景，而无需担心阻塞任务会对UI线程造成影响。<br>这样的死循环saga数据流在客户端用起来是很高效优雅的，但到了服务端，这将造成严重的问题——这个saga永远不会结束，因此<code>task.done.then()</code>永远不会被回调，我们无法知道我们所需的数据什么时候加载完成。</p><p>对于更为普遍的情况，我们是这样定义saga任务的，比如使用蚂蚁的 <a href="https://github.com/ant-design/antd-init" target="_blank" rel="noopener">ant-design/antd-init</a> 脚手架：<br><em>src/sagas/todos.js</em> 中定义了todos的saga：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; jsonResult &#125; = <span class="keyword">yield</span> call(getAll);</span><br><span class="line">  <span class="keyword">if</span> (jsonResult.data) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">'todos/get/success'</span>,</span><br><span class="line">      payload: jsonResult.data,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchTodosGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeLatest(<span class="string">'todos/get'</span>, getTodos)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fork(watchTodosGet);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span>, &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>src/sagas/index.js</em> 负责组合全部model的saga（通过<code>fork()</code>调用），并导出一个<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>.context(<span class="string">'./'</span>, <span class="literal">false</span>, /\.js$/);</span><br><span class="line"><span class="keyword">const</span> keys = context.keys().filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="string">'./index.js'</span> &amp;&amp; item !== <span class="string">'./SagaManager.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">root</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> fork(context(keys[i]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意这里的<code>takeLatest()</code>调用。<code>takeLatest()</code>是redux-saga的一个helper方法，而不是effect方法。参考 <a href="http://yelouafi.github.io/redux-saga/docs/api/index.html#takelatestpattern-saga-args" target="_blank" rel="noopener">redux-saga API文档中的takeLatest</a>，我们可以看到<code>takeLatest()</code>是这样实现的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">takeLatest</span>(<span class="params">pattern, saga, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastTask</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="keyword">yield</span> take(pattern)</span><br><span class="line">      <span class="keyword">if</span> (lastTask)</span><br><span class="line">        <span class="keyword">yield</span> cancel(lastTask)</span><br><span class="line">      lastTask = <span class="keyword">yield</span> fork(saga, ...args.concat(action))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，当我们在saga中进行了一次<code>yield takeLatest()</code>之后，实际上是<code>fork()</code>出了一个带死循环数据流的另一个saga，而这个死循环的saga当然是永远不会结束的，除非它被我们人为<code>cancel()</code>。<br>还有一个问题是关于redux-saga的fork模型：被<code>fork()</code>出来的子saga与其父saga有怎样的生命周期关联？<a href="http://yelouafi.github.io/redux-saga/docs/advanced/ForkModel.html" target="_blank" rel="noopener">redux-saga的官方文档</a> 给了我们最好的回答：</p><blockquote><p>In fact, attached forks shares the same semantics with the parallel Effect:</p><ul><li>We’re executing tasks in parallel</li><li>The parent will terminate after all launched tasks terminate</li></ul></blockquote><p>意思是，父saga只有当其所有<code>fork()</code>出来的子saga都结束后才会结束（这和操作系统的fork模型是类似的）。这意味着，因为其子saga中带有死循环流，我们的<code>rootSaga</code>也是永远不会自发结束的。这样的话，我们就 <strong>不能</strong> 这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(rootSaga);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'todos/get'</span> &#125;);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码不会被执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们只能够直接<code>run()</code>不带死循环流的saga来获得初始数据，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> task = sagaMiddleware.run(getTodos);</span><br><span class="line">task.done.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这跟我们刚才提到的官方建议的方法没有任何区别。在服务端我们需要规避那些包含死循环流的saga，如<code>watchTodosGet</code>。</p><p>这将导致客户端和服务端出现大量的 <strong>异构</strong> ：在客户端，我们直接执行<code>rootSaga</code>，通过<code>dispatch()</code>特定的action来获取数据并同步到state；而在服务端，我们需要找到并执行可以获取到数据并且不带死循环的saga，如<code>getTodos</code>。</p><h3 id="使用redux-wait-for-action来搭救"><a href="#使用redux-wait-for-action来搭救" class="headerlink" title="使用redux-wait-for-action来搭救"></a>使用redux-wait-for-action来搭救</h3><p>为了将 <strong>同构</strong> 进行到底，博主写了一个Redux middleware来解决这个问题： <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="noopener">redux-wait-for-action</a> 。这个代码不到80行的middleware主要实现了：在dispatch一个action时，同时指定另外一个我们期望收到的action，<code>store.dispatch()</code>返回一个promise，当这个我们期望的action到达时，该promise将resolve。<br>这样，我们可以在服务端复用<code>rootSaga</code>而不需要关心这个<code>rootSaga</code>何时结束。同时，在服务端创建的<code>store</code>，其生命周期将在http响应完成后结束，我们甚至不需要手动<code>cancel()</code>这个看似不会自发结束的<code>rootSaga</code>——交给GC来杀死它们就行了。<br>我们不妨写一个在客户端和服务端通用的<code>configureStore()</code>方法来创建我们的<code>store</code>，并且执行我们的<code>rootSaga</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> configureStore = <span class="function">(<span class="params">initialState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">  <span class="keyword">let</span> enhancer = compose(</span><br><span class="line">    applyMiddleware(sagaMiddleware),</span><br><span class="line">    applyMiddleware(createReduxWaitForMiddleware()),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState, enhancer);</span><br><span class="line">  sagaMiddleware.run(rootSaga);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在服务端渲染逻辑中，我们只需要直接<code>dispatch()</code>这个action即可——这和在客户端获取数据的方式完全相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;&#125;);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'todos/get'</span>,</span><br><span class="line">  [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="comment">/* ... */</span>);</span><br><span class="line">  <span class="keyword">const</span> state = store.getState();</span><br><span class="line">  renderFullPage(html, state);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在上面的示例代码中，我们在<code>dispatch()</code>一个action时，在这个action中增加了一个属性<code>WAIT_FOR_ACTION</code>（<code>WAIT_FOR_ACTION</code>是一个从<code>redux-wait-for-action</code>导入的ES6 Symbol对象，因此你不需担心这会污染你的action），该属性指定了另一个我们所期望的action <code>todos/get/success</code>。这个<code>store.dispatch()</code>调用返回一个promise，当action <code>todos/get/success</code>到达时，这个promise将resolve，因此我们可以在它的<code>.then()</code>中填写我们的渲染逻辑——因为这时我们所需的数据已经准备好。</p><p>由于redux-wait-for-action是基于等待action的，它将适用于近乎全部的effects方案（当然，对于redux-thunk和redux-promise则没有这个必要），当以后有更为流行的effects方案时，我们仍然可以使用这个middleware。<br>关于更具体的使用方法，大家可以参考 <a href="https://github.com/Chion82/redux-wait-for-action" target="_blank" rel="noopener">README for redux-wait-for-action</a> 。</p><h2 id="更优雅地组织同构应用"><a href="#更优雅地组织同构应用" class="headerlink" title="更优雅地组织同构应用"></a>更优雅地组织同构应用</h2><p>以上示例都是基于在服务端进行路由判断并决策执行哪个effects的，当我们的数据模型变得多时，服务端代码将变得复杂。比如：该dispatch <code>todos/get</code>还是<code>profile/get</code>？我们需要对<code>req.url</code>进行一一判断。</p><p>借助react-router的<code>match()</code>方法，我们能够得到对应路由下的container组件，如果我们能在每个路由下的container组件中定义一个<code>fetchData()</code>方法来dispatch合适的action，我们就可以大大简化服务端的代码，并且可以同时在服务端和客户端都使用它来加载页面数据。</p><p>在每个路由节点对应的container的代码中，添加一个<code>fetchData()</code> <strong>静态</strong> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodosContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> fetchData(dispatch) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">      type: <span class="string">'todos/get'</span>,</span><br><span class="line">      [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 这个钩子方法仅会在客户端被调用</span></span><br><span class="line">    TodosContainer.fetchData(<span class="keyword">this</span>.props.dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在服务端渲染代码中，我们定义一个<code>getReduxPromise()</code>函数，这个函数抽出当前路由下对应的container组件，并调用其中的<code>fetchData()</code>方法，从而得到一个promise。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">match(&#123;history, routes, <span class="attr">location</span>: req.url&#125;, (error, redirectLocation, renderProps) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* 前面这里需要处理redirectLocation、error和renderProps为null的情况 */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">const</span> getReduxPromise = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> component = renderProps.components[renderProps.components.length - <span class="number">1</span>].WrappedComponent;</span><br><span class="line">    <span class="keyword">const</span> promise = component.fetchData ?</span><br><span class="line">      component.fetchData(store.dispatch) :</span><br><span class="line">      <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;;</span><br><span class="line">  getReduxPromise().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initStateString = <span class="built_in">JSON</span>.stringify(store.getState());</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &#123; &lt;RouterContext &#123;...renderProps&#125;/&gt; &#125;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">    res.status(200).send(renderFullPage(html, initStateString));</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>遇到需要传递cookie或参数的情况，我们可以稍微修改一下<code>fetchData()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> fetchData(dispatch, query, cookies) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">    type: <span class="string">'todos/get'</span>,</span><br><span class="line">    [ WAIT_FOR_ACTION ]: <span class="string">'todos/get/success'</span>,</span><br><span class="line">    query, cookies,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在服务端调用<code>fetchData()</code>时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.fetchData(store.dispatch, req.query, req.cookies);</span><br></pre></td></tr></table></figure></p><p>由于客户端一般不需要在XHR中显式加cookie，因此我们在客户端调用<code>fetchData()</code>时忽略<code>cookies</code>参数即可，并在<code>APIService</code>模块中做适当的判断。</p><p>另外，为了节省篇幅和便于理解，以上各处示例代码中均没有异常处理部分（或被去除）。在实际项目中，请务必在effects中添加<code>try-catch</code>逻辑，并在promise的处理部分添加<code>.catch()</code>异常处理方法。</p><h2 id="博主的脚手架"><a href="#博主的脚手架" class="headerlink" title="博主的脚手架"></a>博主的脚手架</h2><p>为了在实践中更好地理解以上所提到的最优化方案，博主写了这个脚手架，同时便于大家快速搭建同构React应用：<br><a href="https://github.com/Chion82/react-redux-universal-minimal" target="_blank" rel="noopener">react-redux-universal-minimal</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同构 (universal/isomorphic) React应用旨在服务端（或者是网关层、中途岛层）和客户端（浏览器端）尽可能地复用UI组件的代码，以提高项目的可维护性。当同构应用引入以 &lt;a href=&quot;https://github.com/reactjs/redux&quot;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
      <category term="React" scheme="https://blog.chionlab.moe/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>tinc VPN+策略路由：Linux下更好的科学上网方式</title>
    <link href="https://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/"/>
    <id>https://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/</id>
    <published>2016-12-12T05:31:59.000Z</published>
    <updated>2016-12-14T15:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>tinc是一个<a href="https://www.tinc-vpn.org/" target="_blank" rel="noopener">基于网状网络的VPN软件</a>，使用tinc架设VPN，对于远程办公、文件传输等需求都是十分方便的。<br>而作为VPN，我们同样可以通过redirect gateway的方式来实现科学上网。本文将介绍通过使用tinc VPN和配置策略路由的方式，实现Linux平台下的科学上网（国内请求不走代理，国外请求走代理）。</p><p>本文教程以Arch Linux和OpenWRT为例，配置思路同样适用于其他Linux发行版。</p><p>相比于<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/">使用shadowsocks进行科学上网</a>，tinc+策略路由有以下优势：</p><ul><li>VPN是工作在IP层（网络层）的，因此可以实现对IP层packet进行代理，比如基于ICMP的ping和traceroute命令；而shadowsocks只能代理传输层的TCP和UDP请求。</li><li>tincd进程和服务器间的通信是基于UDP的（对于屏蔽UDP的ISP，tinc会自动failover到TCP），而该socket数量是一直固定的，对于本地发出的需要代理的连接（无论是IP层还是传输层），可实现多路复用，大大提高性能。而shadowsocks对于每一个本地TCP连接，均需要向服务器建立一次新的TCP连接，速度十分有限。</li><li>shadowsocks服务器有可能因为同时打开太多的TCP连接而拒绝请求，需要几分钟才能恢复。这种拒绝有可能是在ASP的防火墙上发生的，修改vps的内核参数如<code>file-max</code>等也不能解决。博主的VPS服务器上的shadowsocks服务每隔几天就会遇到一次这样的情况。而tinc因为基于多路复用，则没有这个问题。</li></ul><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>要架设可用于科学上网的tinc服务，你需要拥有：</p><ul><li>一台境外的tinc服务器。你可能需要自行搭建一台tinc服务器，要求：tun/tap设备可用，操作系统为Linux发行版。</li><li>一台本地的Linux机器，可以是你的PC、软路由，或者是一台OpenWRT路由器，同样要求tun/tap可用。</li><li>确认服务器和本地机器上已安装iptables, iproute2, ipset。</li><li>本文非傻瓜教程，无法涵盖全部Linux发行版的操作，你需要熟悉自己所使用的发行版，如service，systemd等基本操作，遇到问题要知道如何排查。</li></ul><h2 id="tinc安装及配置"><a href="#tinc安装及配置" class="headerlink" title="tinc安装及配置"></a>tinc安装及配置</h2><p>你可以参考<a href="https://wiki.archlinux.org/index.php/Tinc" target="_blank" rel="noopener">Arch Linux wiki</a>来安装和配置tinc。这里博主简要介绍快速部署方法。</p><ol><li><p>在服务器和本地机器上安装tinc。</p><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pacman -Syu</span><br><span class="line"># pacman -S tinc</span><br></pre></td></tr></table></figure><h3 id="OpenWRT"><a href="#OpenWRT" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># opkg update</span><br><span class="line"># opkg install tinc</span><br></pre></td></tr></table></figure></li><li><p>在服务器和本地机器上创建tinc配置文件夹。请替换<code>myvpn</code>为你喜欢的vpn名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p /etc/tinc/myvpn</span><br><span class="line"># mkdir /etc/tinc/myvpn/hosts</span><br></pre></td></tr></table></figure></li><li><p>服务端配置文件（在服务器上操作）：<br>你可以将<code>alpha</code>替换为自己喜欢的服务器标识名，下同。<br>/etc/tinc/<em>myvpn</em>/tinc.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name = alpha</span><br><span class="line">Device = /dev/net/tun</span><br></pre></td></tr></table></figure><p>/etc/tinc/<em>myvpn</em>/tinc-up</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ip link set $INTERFACE up</span><br><span class="line">ip addr add  192.168.100.1/32 dev $INTERFACE</span><br><span class="line">ip route add 192.168.100.0/24 dev $INTERFACE</span><br></pre></td></tr></table></figure><p>/etc/tinc/<em>myvpn</em>/tinc-down</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ip route del 192.168.100.0/24 dev $INTERFACE</span><br><span class="line">ip addr del 192.168.100.1/32 dev $INTERFACE</span><br><span class="line">ip link set $INTERFACE down</span><br></pre></td></tr></table></figure><p>添加脚本执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod +x /etc/tinc/myvpn/tinc-up</span><br><span class="line"># chmod +x /etc/tinc/myvpn/tinc-down</span><br></pre></td></tr></table></figure></li><li><p>本地机配置文件（在本地机器上操作）：<br>你可以将<code>beta</code>替换为自己喜欢的客户端标识名，下同。<br>/etc/tinc/<em>myvpn</em>/tinc.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name = beta</span><br><span class="line">Device = /dev/net/tun</span><br><span class="line">ConnectTo = alpha</span><br></pre></td></tr></table></figure><p>/etc/tinc/<em>myvpn</em>/tinc-up</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ip link set $INTERFACE up</span><br><span class="line">ip addr add  192.168.100.100/32 dev $INTERFACE</span><br><span class="line">ip route add 192.168.100.0/24 dev $INTERFACE</span><br></pre></td></tr></table></figure><p>/etc/tinc/<em>myvpn</em>/tinc-down</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ip route del 192.168.100.0/24 dev $INTERFACE</span><br><span class="line">ip addr del 192.168.100.100/32 dev $INTERFACE</span><br><span class="line">ip link set $INTERFACE down</span><br></pre></td></tr></table></figure><p>添加脚本执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod +x /etc/tinc/myvpn/tinc-up</span><br><span class="line"># chmod +x /etc/tinc/myvpn/tinc-down</span><br></pre></td></tr></table></figure></li><li><p>在服务器上建立host配置文件并生成密钥：<br>/etc/tinc/<em>myvpn</em>/hosts/<em>alpha</em> 请将<code>10.0.0.1</code>替换为服务器的公网IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Address = 10.0.0.1</span><br><span class="line">Port = 655</span><br><span class="line">Subnet = 0.0.0.0/0</span><br></pre></td></tr></table></figure><p>生成密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tincd -n myvpn -K</span><br></pre></td></tr></table></figure></li><li><p>在本地机器上建立host配置文件并生成密钥：<br>/etc/tinc/<em>myvpn</em>/hosts/<em>beta</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Port = 655</span><br><span class="line">Subnet = 192.168.100.100/32</span><br></pre></td></tr></table></figure><p>生成密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tincd -n myvpn -K</span><br></pre></td></tr></table></figure></li><li><p>在服务器和本地机上交换host配置文件：<br>复制服务器上的<code>/etc/tinc/myvpn/hosts/alpha</code>到本地机器的<code>/etc/tinc/myvpn/hosts/alpha</code>。<br>复制本地机器上的<code>/etc/tinc/myvpn/hosts/beta</code>到服务器上的<code>/etc/tinc/myvpn/hosts/beta</code>。</p></li><li><p>在服务器和本地机上启动tinc服务：（先启动服务器上的）</p><h3 id="Arch-Linux和其他基于systemd管理的linux发行版"><a href="#Arch-Linux和其他基于systemd管理的linux发行版" class="headerlink" title="Arch Linux和其他基于systemd管理的linux发行版:"></a>Arch Linux和其他基于systemd管理的linux发行版:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start tinc@myvpn.service</span><br></pre></td></tr></table></figure><h3 id="OpenWRT和其他发行版："><a href="#OpenWRT和其他发行版：" class="headerlink" title="OpenWRT和其他发行版："></a>OpenWRT和其他发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tincd -n myvpn</span><br></pre></td></tr></table></figure></li><li><p>测试VPN是否正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig #是否找到了myvpn接口？分配的IPv4地址是否正确？</span><br><span class="line">$ ping 192.168.100.1 #ping服务器</span><br><span class="line">$ ping 192.168.100.100 #ping客户端</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置服务器路由规则"><a href="#配置服务器路由规则" class="headerlink" title="配置服务器路由规则"></a>配置服务器路由规则</h2><p>以下操作在tinc服务器上进行：</p><ol><li><p>开启ip_forward：</p><h3 id="Arch-Linux："><a href="#Arch-Linux：" class="headerlink" title="Arch Linux："></a>Arch Linux：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo &apos;net.ipv4.ip_forward=1&apos; &gt; /etc/sysctl.d/99-ipforword.conf</span><br><span class="line"># sysctl --system</span><br></pre></td></tr></table></figure><h3 id="其他Linux发行版："><a href="#其他Linux发行版：" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>将<code>net.ipv4.ip_forward=0</code>修改为<code>net.ipv4.ip_forward=1</code>。如果文件为空或没有这行，则添加一行<code>net.ipv4.ip_forward=1</code>即可。<br>随后运行这条命令使配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure></li><li><p>开启masquerade：<br>首先通过<code>ifconfig</code>命令（Arch Linux上使用<code>ip addr</code>），找出外网IP对应的接口名称。这里假设外网接口是<code>eth0</code>。<br>运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -t nat -A POSTROUTING -o eth0 -s 192.168.100.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>你可以保存当前的iptables配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables-save &gt; /etc/iptables/iptables.rules</span><br></pre></td></tr></table></figure><p>在Arch Linux上，需要开启<code>iptables.service</code>来实现重启后保留配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable iptables.service</span><br></pre></td></tr></table></figure><p>在CentOS6上，需要开启<code>iptables</code>服务来实现重启后保留配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig iptables on</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置策略路由"><a href="#配置策略路由" class="headerlink" title="配置策略路由"></a>配置策略路由</h2><p>确认VPN架设成功，客户端和服务端能够互相ping通后，我们可以进行策略路由的配置了。<br>为了方便各位配置，博主已经写好了配置脚本。</p><p>以下操作在本地机器上进行：</p><ol><li><p>下载国内IP段文件，保存至<code>/etc/chn_route.list</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/chn_route.list -O /etc/chn_route.list</span><br></pre></td></tr></table></figure></li><li><p>下载策略路由初始化和停止脚本，保存至<code>/usr/bin/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/bin</span><br><span class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/init_tinc_proxy -O init_tinc_proxy</span><br><span class="line"># wget https://raw.githubusercontent.com/Chion82/soft-router/master/tinc_proxy/stop_tinc_proxy -O stop_tinc_proxy</span><br><span class="line"># chmod +x init_tinc_proxy</span><br><span class="line"># chmod +x stop_tinc_proxy</span><br></pre></td></tr></table></figure></li><li><p>修改启动脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/bin/init_tinc_proxy</span><br></pre></td></tr></table></figure><p>将第2行<code>VPN_SERVER=XX.XX.XX.XX</code>的<code>XX.XX.XX.XX</code>修改为tinc服务器的外网IP地址。<br>将第5行<code>VPN_INTERFACE=chionvpn</code>的<code>chionvpn</code>修改为<code>myvpn</code>，或者是刚才你自定义的vpn名称。<br>如果你的Linux发行版不是Arch Linux，请删除最后这两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Set rp_filter</span><br><span class="line">echo 2 &gt; /proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</span><br></pre></td></tr></table></figure></li><li><p>修改停止脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/bin/stop_tinc_proxy</span><br></pre></td></tr></table></figure><p>将第2行<code>VPN_INTERFACE=chionvpn</code>的<code>chionvpn</code>修改为<code>myvpn</code>，或者是刚才你自定义的vpn名称。<br>如果你的Linux发行版不是Arch Linux，请删除第7和第8行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Restore rp_filter</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</span><br></pre></td></tr></table></figure></li><li><p>修改<code>tinc-up</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/tinc/myvpn/tinc-up</span><br></pre></td></tr></table></figure><p>在最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/init_tinc_proxy &amp;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>tinc-down</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/tinc/myvpn/tinc-down</span><br></pre></td></tr></table></figure><p>在第一行<code>#!/bin/sh</code><br>下方插入一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/stop_tinc_proxy</span><br></pre></td></tr></table></figure></li><li><p>重启tinc来测试配置是否正确：</p><h3 id="Arch-Linux-1"><a href="#Arch-Linux-1" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart tinc@myvpn.service</span><br></pre></td></tr></table></figure><h3 id="其他Linux发行版：-1"><a href="#其他Linux发行版：-1" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tincd -n myvpn -k</span><br><span class="line"># tincd -n myvpn</span><br></pre></td></tr></table></figure><p>进行测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping 172.217.27.132</span><br></pre></td></tr></table></figure><p>如果能够ping通，说明以上配置正确。</p></li></ol><h2 id="配置ChinaDNS和dnsmasq"><a href="#配置ChinaDNS和dnsmasq" class="headerlink" title="配置ChinaDNS和dnsmasq"></a>配置ChinaDNS和dnsmasq</h2><p>至此，我们的VPN和策略路由已经配置完成。为了避免国内DNS污染，我们需要使用<a href="https://github.com/shadowsocks/ChinaDNS" target="_blank" rel="noopener">ChinaDNS</a>。ChinaDNS的配置方法与之前的<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/">OpenWRT科学上网</a>类似，唯一不同处是，这里的国外上游DNS服务器我们可以直接填写<code>8.8.8.8</code>，而不需要shadowsocks的<code>ss-tunnel</code>隧道。</p><p>以下操作在本地机器上进行：</p><ol><li><p>安装并配置ChinaDNS</p><h3 id="Arch-Linux-2"><a href="#Arch-Linux-2" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yaourt -S chinadns</span><br><span class="line"># cp /etc/chn_route.list /etc/chnroute.txt</span><br><span class="line"># system start chinadns.service</span><br></pre></td></tr></table></figure><h3 id="OpenWRT-1"><a href="#OpenWRT-1" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><p>参照<a href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/#安装ChinaDNS">OpenWRT科学上网 #安装ChinaDNS</a>来安装ChinaDNS，然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp /etc/chn_route.list /etc/chinadns_chnroute.txt</span><br></pre></td></tr></table></figure><p>进入OpenWRT管理网页，进入services-&gt;ChinaDNS，勾选<code>Enable</code>，中国路由表(CHNRoute File)填<code>/etc/chinadns_chnroute.txt</code>，设置<code>Upstream Servers</code>为：<code>114.114.114.114,8.8.8.8</code>。</p></li><li><p>配置dnsmasq</p><h3 id="Arch-Linux：-1"><a href="#Arch-Linux：-1" class="headerlink" title="Arch Linux："></a>Arch Linux：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S dnsmasq</span><br></pre></td></tr></table></figure><p>修改<code>/etc/dnsmasq.conf</code>，清空文件并填入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen-address=127.0.0.1  #如果机器(如软路由)绑定了静态IP，请在这里加上静态IP，以逗号分割</span><br><span class="line"></span><br><span class="line">no-resolv</span><br><span class="line">server=127.0.0.1#5353</span><br></pre></td></tr></table></figure><p>启动dnsmasq：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start dnsmasq.service</span><br></pre></td></tr></table></figure><p>修改本机的DNS配置，使其指向<code>127.0.0.1</code>。<br>如果你的网络配置文件管理器是<code>netctl</code>，在对应的配置文件(位于<code>/etc/netctl/</code>下)中设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNS=(&apos;127.0.0.1&apos;)</span><br></pre></td></tr></table></figure><h3 id="OpenWRT："><a href="#OpenWRT：" class="headerlink" title="OpenWRT："></a>OpenWRT：</h3><p>进入网络(Network)-&gt;DHCP and DNS。<br>将DNS转发(DNS forwardings)设置为<code>127.0.0.1#5353</code>。<br>还要记得勾选“忽略解析文件”(ignore resolve file)。</p></li><li><p>测试<br>现在应该能够ping通谷歌域名了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig www.google.com</span><br><span class="line">$ ping www.google.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>如果需要在机器启动时自动开启科学上网，可按照以下步骤进行：</p><ol><li><p>自启动tinc服务，在服务器和本地机器上操作：</p><h3 id="Arch-Linux-3"><a href="#Arch-Linux-3" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable tinc@myvpn.service</span><br></pre></td></tr></table></figure><h3 id="其他Linux发行版：-2"><a href="#其他Linux发行版：-2" class="headerlink" title="其他Linux发行版："></a>其他Linux发行版：</h3><p>在 <code>/etc/rc.local</code> 脚本文件最后添加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tincd -n myvpn</span><br></pre></td></tr></table></figure><p>当然，更好的方法是编写一个init服务脚本（位于<code>/etc/init.d/</code>）。</p></li><li><p>自启动ChinaDNS服务，在本地机上操作：</p><h3 id="Arch-Linux-4"><a href="#Arch-Linux-4" class="headerlink" title="Arch Linux:"></a>Arch Linux:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable chinadns.service</span><br><span class="line"># systemctl enable dnsmasq.service</span><br></pre></td></tr></table></figure><h3 id="OpenWRT-2"><a href="#OpenWRT-2" class="headerlink" title="OpenWRT:"></a>OpenWRT:</h3><p>不需要特别设置，ChinaDNS和dnsmasq服务在安装后默认是自启动的。</p></li></ol><p>至此，全部配置已经完成了，你现在可以上youtube看大新闻了。</p><h2 id="策略路由原理及常见问题"><a href="#策略路由原理及常见问题" class="headerlink" title="策略路由原理及常见问题"></a>策略路由原理及常见问题</h2><ol><li><p><code>init_tinc_proxy</code>这个脚本都做了些什么？</p><ul><li>首先，读取<code>/etc/chn_route.list</code>文件，这个文件的内容是国内IPv4的CIDR地址段。创建一个ipset集合<code>chn_route</code>，将这些国内地址段写入该集合。</li><li><p>添加一个路由表，id为<code>200</code>，该路由表接受全部IP段（<code>0.0.0.0/0</code>，或<code>default</code>），经由接口<code>myvpn</code>，网关（下一跳）是VPN服务器<code>192.168.100.1</code>。即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip route add default via 192.168.100.1 dev myvpn tabel 200</span><br></pre></td></tr></table></figure></li><li><p>添加一个路由规则，将MARK为<code>200</code>的IP报使用id为<code>200</code>的路由表进行路由。即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ip rule add fwmark 200 table 200</span><br></pre></td></tr></table></figure></li><li><p>在iptables的mangle表增加一个自定义链<code>tinc_proxy</code>，并在该链中添加如下规则：<br>目的地址在<code>BYPASS</code>指定的例外IP段中的packet，采取<code>RETURN</code>处理；<br>目的地址在<code>chn_route</code>集合中的packet，采取<code>RETURN</code>处理；<br>恢复CONNMARK的值到MARK（CONNMARK：用于跟踪一个连接的标记值）；<br>对MARK的值为<code>0</code>的packet，设置其MARK为<code>200</code>；<br>将MARK的值保存到CONNMARK；</p></li><li>在mangle表的<code>PREROUTING</code>和<code>OUTPUT</code>链中插入自定义链<code>tinc_proxy</code></li><li>在nat表的<code>POSTROUTING</code>链中，对出口接口为<code>myvpn</code>的packet，采取<code>MASQUERADE</code>处理。</li></ul></li><li><p>为什么在Arch Linux下，需要将内核参数<code>/proc/sys/net/ipv4/conf/$VPN_INTERFACE/rp_filter</code>设为<code>2</code>？<br><code>rp_filter</code>是<a href="http://tldp.org/HOWTO/Adv-Routing-HOWTO/lartc.kernel.rpf.html" target="_blank" rel="noopener">Reverse Path Filtering (反向路径过滤)</a>，其原理是：<br>内核对目的地址为本机的每个IP报文，先检查其来源地址，然后根据本机路由表，查找到该来源地址的路由（即反向路径查找），若查找到的路由对应的接口与该报文实际到达所经过的接口不相符，则抛弃该包。显然，这对基于fwmark的策略路由是不适用的，因此需要关闭反向路径过滤功能。<br>Arch Linux下默认使用严格的反向路径过滤策略，需要将该值设置为<code>2</code>。<br>而其他发行版，只需要将该值保持为默认的<code>0</code>即可。</p></li><li><p>tinc VPN架设成功后，服务器和客户端能够互相ping通，但是无法经由服务器科学上网？<br>请逐步排查，特别注意服务器的tinc host配置文件中，<code>Subnet</code>是否正确设置为<code>0.0.0.0</code>。<br>参考<a href="https://www.tinc-vpn.org/examples/redirect-gateway/" target="_blank" rel="noopener">Example: redirecting the default gateway to a host on the VPN</a>将全部流量都经过VPN，看看能否正常访问外网。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tinc是一个&lt;a href=&quot;https://www.tinc-vpn.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于网状网络的VPN软件&lt;/a&gt;，使用tinc架设VPN，对于远程办公、文件传输等需求都是十分方便的。&lt;br&gt;而作为VPN，我
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="openwrt" scheme="https://blog.chionlab.moe/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>ChionLab 2016年底更新记录</title>
    <link href="https://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/"/>
    <id>https://blog.chionlab.moe/2016/12/12/chionlab-updates-dec-2016/</id>
    <published>2016-12-12T03:05:29.000Z</published>
    <updated>2016-12-12T04:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>早上好。本站从建立至今已将近一年，博主最近对小站进行了若干修改和调整，具体包括：</p><ol><li>新的样式主题 <em>Uzume</em> ，并保留原主题 <em>Miria</em> ，在站点顶部banner可切换主题。<ul><li>新主题 <em>Uzume</em> 角色是 <em>天王星うずめ</em> （天王星涡芽），出自游戏 <em>新次元ゲイム　ネプテューヌVII</em> （新次元游戏 海王星VII，PSN港区译作 <em>新次元遊戲 戰機少女VII</em> ）。Banner题图为博主亲自合成所得。</li><li>原主题 <em>Miria</em> 角色是 <em>赤城みりあ</em> （赤城米莉亚），出自游戏、动画和漫画 <em>アイドルマスター　シンデレラガールス</em> （偶像大师 灰姑娘女孩）系列。</li></ul></li><li>针对境内访问用户，对网站作了以下调整优化：<ul><li>新增CDN加速节点CN2( <a href="https://cn2.chionlab.moe" target="_blank" rel="noopener">https://cn2.chionlab.moe</a> )，保留原加速节点CloudFlare( <a href="https://blog.chionlab.moe">https://blog.chionlab.moe</a> )。对于境内和境外（或科学上网）用户，在访问本站时会自动切换。当然，你也可以在本站顶部手动切换CDN加速线路。</li><li>针对境内用户无法访问Disqus的问题，新增多说评论模块。CN2节点默认屏蔽Disqus评论模块，只保留多说评论模块；原CloudFlare节点则同时保留Disqus和多说两个评论模块。问题：多说模块请求了第三方http资源，因此在访问本站文章时浏览器可能会报安全策略warning，但不影响体验。</li><li>将Google Fonts的 <em>Source Code Pro</em> font face本地化，提高字体资源加载速度。</li></ul></li></ol><p>以上调整各处，除了CDN节点部署，均通过修改hexo和hexo主题源码完成，若有必要，以后将发表博文以提供修改思路和指点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上好。本站从建立至今已将近一年，博主最近对小站进行了若干修改和调整，具体包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新的样式主题 &lt;em&gt;Uzume&lt;/em&gt; ，并保留原主题 &lt;em&gt;Miria&lt;/em&gt; ，在站点顶部banner可切换主题。&lt;ul&gt;
&lt;li&gt;新主题 &lt;em&gt;Uzu
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>TCP keepalive的探究 (2) : 浏览器的Keepalive机制</title>
    <link href="https://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/"/>
    <id>https://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/</id>
    <published>2016-11-07T11:40:07.000Z</published>
    <updated>2016-11-14T14:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>上文介绍了TCP Keepalive机制以及其在linux中的编程实现，本文将继续介绍这种机制在浏览器中的运用，并以Chrome为例。</p><h2 id="HTTP1-1中的Connection-Keep-Alive"><a href="#HTTP1-1中的Connection-Keep-Alive" class="headerlink" title="HTTP1.1中的Connection: Keep-Alive"></a>HTTP1.1中的Connection: Keep-Alive</h2><p>在介绍Chrome对TCP Keepalive的实现之前，我们先来了解一下第七层协议HTTP1.1中的Connection字段。注意，本章节讨论的Keepalive为七层协议(HTTP1.1)中的Keep-Alive机制。</p><p>HTTP1.1协议头(header)中的<code>Connection</code>字段可取这两个值的其中之一：<code>keep-alive</code>, <code>close</code>。<br>该字段在请求头(request header)和响应头(response header)中都可以存在，这说明，客户端可以申请开启Keep-Alive，而服务端可以接受Keep-Alive请求，或者拒绝并在响应头中告知客户端。</p><h3 id="作用机理"><a href="#作用机理" class="headerlink" title="作用机理"></a>作用机理</h3><p>这里以一次完整的HTTP1.1网站访问来说明。</p><ol><li>客户端浏览器向 <code>www.bilibili.com:80</code> 建立TCP连接，并在此TCP连接上传输七层报文，请求<code>GET /index.html</code>资源，在请求头中，<code>Connection</code>置为<code>keep-alive</code>。</li><li>服务端向浏览器返回<code>index.html</code>的文件内容，响应报头中<code>Connection</code>置为<code>keep-alive</code>，随后，<strong>不关闭和客户端的TCP连接</strong>。</li><li>客户端复用该TCP连接，并请求<code>GET /style.css</code>资源，请求头置<code>Connection</code>为<code>keep-alive</code>。</li><li>服务器向浏览器返回<code>index.css</code>文件内容，仍然不关闭该TCP连接。</li><li>客户端继续复用该TCP连接请求多个同域资源。</li><li>客户端所需的各种资源都请求完毕，但是因为客户端的最后一次资源请求头中仍置<code>Connection</code>为<code>keep-alive</code>，该TCP连接仍未被关闭。</li><li>如果在一段时间（通常是3分钟左右）内客户端没有使用该TCP连接请求资源，服务器可能会关闭该连接。连接被关闭后，客户端需要重新向该域建立TCP连接才能继续请求数据。</li></ol><img src="/2016/11/07/tcp-keepalive-on-chrome/http1.1.png" title="HTTP1.1的请求示意图"><img src="/2016/11/07/tcp-keepalive-on-chrome/10.png" title="一次HTTP1.1的请求和响应报头"><h3 id="几点细节"><a href="#几点细节" class="headerlink" title="几点细节"></a>几点细节</h3><ul><li><p>HTTP1.1的Keep-Alive机制仅对同域下的网络请求有效。比如，对于<code>http://www.bilibili.com/index.html</code>和<code>http://www.bilibili.com/style.css</code>这两个资源请求，浏览器能够复用其TCP连接，而对于非同域下的<code>http://space.bilibili.com/index.html</code>，则需要重新建立一次TCP连接。</p></li><li><p>服务器有权拒绝客户端的Keep-Alive请求，在响应头中置<code>Connection</code>为<code>close</code>，并在传输一次完整的响应报文后主动关闭TCP连接，在这之后，客户端如需向该域请求资源，则需重新建立TCP连接。而事实上，即使客户端和服务端都开启了Keep-Alive，服务端一般会主动关闭非活动的连接，否则会造成资源浪费。</p></li><li><p>Keep-Alive虽然可以在一定程度上通过复用TCP连接来提高页面资源加载性能，但是受HTTP1.1的max-connection限制，提高的性能很有限。很多时候，为了加快更多资源的加载，通常会使用多个不同域名的CDN。而在HTTP2中，通过二进制数据帧的方式来传输同域下多资源，可以解决这个问题。关于HTTP2的传输机制，可以参考<a href="https://segmentfault.com/a/1190000006923359" target="_blank" rel="noopener">这篇文章</a>。</p></li></ul><h2 id="Chrome对TCP连接的保活机制"><a href="#Chrome对TCP连接的保活机制" class="headerlink" title="Chrome对TCP连接的保活机制"></a>Chrome对TCP连接的保活机制</h2><p>上篇章节中我们熟悉了七层协议中HTTP1.1的Keep-Alive机制，本章节我们介绍Chrome对四层协议的TCP Keepalive的实现。</p><p><strong>Chrome何时需要启用TCP Keepalive？</strong><br>假定服务器启用了HTTP1.1 Keep-Alive，浏览器与服务器建立TCP连接，并在该TCP连接上有序地传输多个HTTP1.1七层报文，以此来请求多个资源。对于同域下，在浏览器完成一次请求并获得对应资源后，若一段时间内暂时未有新的资源请求（资源请求可能由页面JavaScript发出，如Ajax），直至下次请求发出前，该TCP连接保持空闲状态。而在这段空闲时间内，浏览器需要对该TCP连接进行保活。</p><p>下面我们将通过Wireshark抓包来验证。</p><img src="/2016/11/07/tcp-keepalive-on-chrome/9.png" title="Wireshark抓到的Chrome发出的TCP keepalive探测包"><p>从上面的抓包结果中看到，在服务器返回完整HTTP 200报文的45秒后（Time=72），本地发出了第一个TCP Keepalive探测包并收到来自服务器的ACK。</p><p>这说明，Chrome对于可复用的TCP连接，采用的保活机制是TCP层（传输层）自带的Keepalive机制，通过TCP Keepalive探测包的方式实现，而不是在七层报文上自成协议来传输其它数据。</p><p>而实际上，由于HTTP1.1对时序和报文的约定，浏览器也不可在七层实现保活。假设，客户端在通过HTTP1.1获取一次资源后，若在这个TCP连接上发送一个<code>0x70</code>（无意义的数据，在七层实现保活的方式大多如此），服务器会在应用层接收到并缓存该数据，一段时间后客户端发送有效的HTTP请求报头，则服务端CGI应用程序收到的数据是<code>0x70</code>再接上一段HTTP请求头，这被认为是无效的HTTP报文，服务器则会返回400响应头，告知客户端这是坏的请求（Bad Request）。</p><p>所以，浏览器在处理HTTP1.1请求所对应的TCP连接的保活时，通过使用TCP Keepalive机制，来避免污染七层（应用层）的传输数据。</p><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>本篇主要介绍浏览器对TCP Keepalive的运用，内容简单。结合本篇内容，作者将在下篇文章中详细说明作者在使用shadowsocks浏览web时遇到的问题、解决方案以及一点思考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上文介绍了TCP Keepalive机制以及其在linux中的编程实现，本文将继续介绍这种机制在浏览器中的运用，并以Chrome为例。&lt;/p&gt;
&lt;h2 id=&quot;HTTP1-1中的Connection-Keep-Alive&quot;&gt;&lt;a href=&quot;#HTTP1-1中的Connec
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
      <category term="network" scheme="https://blog.chionlab.moe/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>TCP keepalive的探究 (1) : NAT和保活机制</title>
    <link href="https://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/"/>
    <id>https://blog.chionlab.moe/2016/09/24/linux-tcp-keepalive/</id>
    <published>2016-09-23T16:46:52.000Z</published>
    <updated>2016-09-26T15:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于应用层的TCP连接保活（Keepalive）机制，相信大家都听说过。对于长连接TCP保活，典型的方法是发送应用层的心跳包，但这将增加开发人员的工作量：需要专门为心跳包制定协议。而在Linux的socket通信API中，自带了TCP_KEEPALIVE的相关参数设定，通过这种方式实现TCP长连接保活，无需修改原程序的逻辑，开发人员不需要关心心跳包的实现。本系列文章将从路由器NAT原理、keepalive基本的代码实现、浏览器保活机制、存在的问题几个方面逐步深入探究。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>为什么要使用TCP keepalive？这得从NAT（地址转换）原理开始讲起。狭义上，NAT分为SNAT（原地址转换）和DNAT（目标地址转换），关于DNAT，有兴趣的同学可以自行查阅，本文只讨论SNAT。</p><p>我们都知道，路由器的最基本功能是对第三层（网络层）上的IP报文进行转发。实际上，路由器还有很关键的一个功能，这便是NAT。特别是对于ISP对普通用户链路上的路由器，NAT功能尤为重要。</p><p>为什么要使用NAT？原因很简单：IPv4地址非常稀缺。上网需求庞大，这使得ISP不可能为每一个入网用户都提供一个独立的公网IP，因此通常情况下，ISP会把用户接入局域网，使得多个用户共享同一个公网IP，而每一个用户各分得一个局域网内网IP。而连接公网和局域网的这台路由器，称之为网关（gateway），NAT的过程就发生在这台网关路由器上。</p><h3 id="三层地址转换"><a href="#三层地址转换" class="headerlink" title="三层地址转换"></a>三层地址转换</h3><p>局域网内的主机向公网发出的网络层IP报文，将经由网关被转发至公网，而在该转发过程中发生了地址转换。网关将该IP报文中的 <strong>源IP地址</strong> 从”该主机的内网IP”修改为”网关的公网IP”。</p><p>比如，局域网主机获得的内网IP为<code>192.168.1.100</code>，网关的公网IP为<code>210.177.63.2</code>，局域网主机向公网目标主机发出的IP报文中，源IP字段数据为<code>192.168.1.100</code>，在经过网关时，该字段数据将被修改为<code>210.177.63.2</code>。</p><p>为什么要这么做，相信大家已经猜到了。公网上的目标主机在收到这个IP报文后，需要知道这个IP报文的来源地址，并向该来源地址发送响应报文，但如果不经过NAT，目标主机拿到的来源地址是<code>192.168.1.100</code>，这显然是一个公网上不可访问到的私有地址，目标主机无法将响应报文发送到正确的来源主机上。开启了NAT之后，IP报文的来源地址被网关修改为<code>210.177.63.2</code>，这是一个公网地址，目标主机将向这个地址（即网关路由器的公网地址）发送响应报文。</p><p>但是请注意，如果这个IP报文的数据段不含传输层协议报文，而是一个pure的网络层packet，来自目标主机的响应报文是不能被网关准确转发到多台局域网主机中的其中一台的。（ICMP报文除外，其报头中有Identifier字段用于标识不同的主机或进程，网关在处理Identifier时类似于下面提到的运输层端口）</p><h3 id="传输层端口转换表"><a href="#传输层端口转换表" class="headerlink" title="传输层端口转换表"></a>传输层端口转换表</h3><p>在三层地址转换中，我们可以保证局域网内主机向公网发出的IP报文能顺利到达目的主机，但是从目的主机返回的IP报文却不能准确送至指定局域网主机（我们不能让网关把IP报文广播至全部局域网主机，因为这样必然会带来安全和性能问题）。为了解决这个问题，网关路由器需要借助传输层端口，通常情况下是TCP或UDP端口，由此来生成一张端口转换表。</p><p>让我们通过一个实例来说明端口转换表如何运作。<br>假设局域网主机A<code>192.168.1.100</code>需要与公网上的目标主机B<code>210.199.38.2:80</code>进行一次TCP通信。其中A所在局域网的网关C的公网IP地址为<code>210.177.63.2</code>。步骤如下：</p><p>1. 局域网主机A<code>192.168.1.100</code>发出TCP连接请求，A上的TCP端口为系统分配的<code>53600</code>。该TCP握手包中，包含源地址和端口<code>192.168.1.100:53600</code>，目的地址和端口<code>210.199.38.2:80</code>。<br>2. 网关C将该包的原地址和端口修改为<code>210.177.63.2:63000</code>，其中<code>63000</code>是网关分配的临时端口。<br>3. 网关C在端口转换表中增加一条记录：</p><table><thead><tr><th>内网主机IP</th><th>内网主机端口</th><th>网关端口</th><th>目的主机IP</th><th>目的主机端口</th></tr></thead><tbody><tr><td>192.168.1.100</td><td>53600</td><td>63000</td><td>210.199.38.2</td><td>80</td></tr></tbody></table><p>4. 网关C将修改后的TCP包发送至目的主机B。<br>5. 目的主机B收到后，发送响应TCP包。该响应TCP包含有以下信息：源地址和端口<code>210.199.38.2:80</code>，目的地址和端口<code>210.177.63.2:63000</code>。<br>6. 网关C收到这个来自B的响应包后，随即在端口转换表中查找记录。该记录须符合以下条件：目的主机IP==<code>210.199.38.2</code>，目的主机端口==<code>80</code>，网关端口==<code>63000</code>。<br>7. 网关C搜索到这条记录，记录显示内网主机IP为<code>192.168.1.100</code>，内网主机端口为<code>53600</code>。<br>8. 网关C将该包的目的地址和端口修改为<code>192.168.1.100:53600</code>。<br>9. 网关C随即将该修改后的TCP包转发至<code>192.168.1.100:53600</code>，即局域网主机A。此时运输层数据的一次交换已完成。</p><h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>在网关C上，由于端口数量有限（0~65535），端口转换表的维护占用系统资源，因此不能无休止地向端口转换表中增加记录。对于过期的记录，网关需要将其删除。如何判断哪些是过期记录？网关认为，一段时间内无活动的连接是过期的，应定时检测转换表中的非活动连接，并将之丢弃。<strong>而这个丢弃的过程，网关不会以任何的方式通告该连接的任何一端。</strong></p><p>那么问题就来了：如果一个客户端应用程序由于业务需要，需要与服务端维持长连接（如TCP聊天程序），而如果在特别长的时间内（在博主的ISP环境下，该时间在3分钟左右），这个连接没有任何的数据交换，网关会认为这个连接过期并将这个连接从端口转换表中丢弃。该连接被丢弃时，客户端和服务端对此是完全无感知的。在连接被丢弃后，客户端将收不到服务端的数据推送，客户端发送的数据包也不能到达服务端。</p><h2 id="第一次实验"><a href="#第一次实验" class="headerlink" title="第一次实验"></a>第一次实验</h2><p>让我们使用TCP测试工具netcat来实际实验一下。</p><ul><li>在公网服务器上，使用<code>nc -l 9999</code>命令监听TCP端口<code>9999</code>。</li><li>在局域网主机上，使用<code>nc XX.XX.XX.XX 9999</code>命令连接到这台公网服务器的<code>9999</code>端口。</li><li>进行基本的双向发包测试。</li><li>不关闭连接，在空闲5分钟后再进行双向发包测试。</li></ul><p>在我的例子中，在双方建立TCP连接后，客户端（局域网主机）发送一行<code>hello from client</code>，服务端发送一行<code>hello from server</code>。<br>等待5分钟，然后客户端发送一行<code>test from client</code>。</p><p>通过wireshark在客户端主机上抓包，跟踪这个TCP连接得出如下结果：<br><img src="/2016/09/24/linux-tcp-keepalive/1.png"></p><p>从上图可得出：</p><ul><li>在第144秒时，通过TCP三次握手，双方建立连接。</li><li>随后双方各发一行hello信息，并都成功接收到ACK响应包，证明发送成功。</li><li>在第500秒时，客户端发送<code>test from client</code>，但是没有收到对方响应ACK，导致客户端多次重发（TCP Retransmission），但是仍然收不到ACK。</li></ul><p>在服务端上，仅能收到客户端一开始发送的<code>hello from client</code>，5分钟后客户端发送的<code>test from client</code>并不能收到：<br><img src="/2016/09/24/linux-tcp-keepalive/2.png"></p><p>而在服务端尝试发送<code>test from server</code>，客户端也收不到了。</p><p>这表明，在这空闲的5分钟内，网关路由器已经“掐断”了这个TCP连接，导致5分钟后该连接不可再用。但无论是客户端还是服务端，都不知道这个连接已经作废了，因此客户端在发包没有收到ACK后仍在尝试重发，双方的netcat进程仍然没有退出，说明了网关在掐断连接时并没有通知双方。</p><h2 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h2><p>如果我们的业务需要我们维持长连接，这就要避免网关“干掉”我们的长连接。解决方法就是，让网关认为我们的TCP连接是活动的。在应用层，我们可以通过定时发送心跳包的方式实现。而如果使用Linux提供的TCP_KEEPALIVE，在应用层我们可完全不关心心跳包何时发送、发送什么内容，这一切由操作系统自动管理：操作系统会在该TCP连接上定时发送探测包，探测包既能像心跳包一样起到连接保活的作用，也能自动检测连接的有效性，并自动关闭无效连接。</p><p>在Linux全局内核设置中，有以下三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">7200</span><br><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">75</span><br><span class="line"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><ul><li><code>tcp_keepalive_time</code>: 如果在该时间内没有数据往来，则发送探测包。</li><li><code>tcp_keepalive_intvl</code>: 探测包发送间隔时间。</li><li><code>tcp_keepalive_probes</code>: 尝试探测的次数。如果发送的探测包次数超过该值仍然没有收到对方响应，则认为连接已失效并关闭连接。</li></ul><p>TCP Keepalive默认是关闭的。要启用这个特性，需要在程序中如下设置（代码实例来自<a href="https://my.oschina.net/lvsin/blog/382904" target="_blank" rel="noopener">Linux下TCP keepalive属性的表现</a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> keepAlive = <span class="number">1</span>; <span class="comment">// 开启keepalive属性</span></span><br><span class="line"><span class="keyword">int</span> keepIdle = <span class="number">60</span>; <span class="comment">// 如该连接在60秒内没有任何数据往来,则进行探测</span></span><br><span class="line"><span class="keyword">int</span> keepInterval = <span class="number">5</span>; <span class="comment">// 探测时发包的时间间隔为5 秒</span></span><br><span class="line"><span class="keyword">int</span> keepCount = <span class="number">3</span>; <span class="comment">// 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.</span></span><br><span class="line"></span><br><span class="line">setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span>*)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle)); <span class="comment">//对应tcp_keepalive_time</span></span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)); <span class="comment">//对应tcp_keepalive_intvl</span></span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount)); <span class="comment">//对应tcp_keepalive_probes</span></span><br></pre></td></tr></table></figure><p>如果省略<code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code>、<code>TCP_KEEPCNT</code>三个属性的设置，将使用上文的三个系统全局默认值。</p><h2 id="第二次实验"><a href="#第二次实验" class="headerlink" title="第二次实验"></a>第二次实验</h2><p>这次我们使用 <a href="https://github.com/cyberelf/netcat-keepalive" target="_blank" rel="noopener">netcat-keepalive</a> 来测试。这个Github上的开源项目在netcat的基础上加入了上述的代码。参数说明请参照README。</p><p>测试方法基本不变。唯一的不同之处是，客户端使用netcat-keepalive，并开启TCP Keepalive特性。</p><p>客户端上的测试结果和wireshark抓包记录如下：<br><img src="/2016/09/24/linux-tcp-keepalive/4.png"></p><p>抓包记录显示，在空闲的5分钟内，客户端每隔30秒发送一个TCP探测包（TCP Keep-Alive），并收到服务端ACK（TCP Keep-Alive ACK）。在5分钟后客户端发送<code>test from client</code>，服务端发送<code>test from server</code>，均发送成功。</p><p>服务端上的截图：<br><img src="/2016/09/24/linux-tcp-keepalive/6.png" title="服务端收到了来自客户端的“test from client”"></p><p>这证明，我们通过TCP Keepalive，成功地阻止了网关路由器丢弃我们的TCP长连接，所以我们在5分钟后仍能够使用这个长连接进行通信。</p><p>让我们来看看这个TCP Keep-Alive探测包是个什么东西：<br><img src="/2016/09/24/linux-tcp-keepalive/5.png"></p><p>由上图可看出，探测包是一个特殊的TCP包：它的长度为零，Flags位ACK置1，Options置为两个NOP，而它的端口信息和普通的TCP数据包是一样的。</p><p>对于服务端响应的TCP Keep-Alive ACK探测包，是由服务器操作系统发送的。实际上，在使用应用层TCP编程时，并不能收到这个探测包，所以服务端应用程序对该探测包是无感知的。</p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p>本文从NAT基本原理介绍了TCP Keepalive的原理和基本实现，在下篇文章中，我们将探究Chrome浏览器对于TCP保活的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于应用层的TCP连接保活（Keepalive）机制，相信大家都听说过。对于长连接TCP保活，典型的方法是发送应用层的心跳包，但这将增加开发人员的工作量：需要专门为心跳包制定协议。而在Linux的socket通信API中，自带了TCP_KEEPALIVE的相关参数设定，通过
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
      <category term="network" scheme="https://blog.chionlab.moe/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>mixins是有害的（Mixins Considered Harmful）［下篇］</title>
    <link href="https://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/"/>
    <id>https://blog.chionlab.moe/2016/08/28/mixins-considered-harmful-2/</id>
    <published>2016-08-28T08:32:22.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2016/07/23/mixins-considered-harmful/">上篇</a></p><p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Facebook React: Mixins Considered Harmful</a></p><blockquote><p>Migrating from Mixins<br>Let’s make it clear that mixins are not technically deprecated. If you use React.createClass(), you may keep using them. We only say that they didn’t work well for us, and so we won’t recommend using them in the future.<br>Every section below corresponds to a mixin usage pattern that we found in the Facebook codebase. For each of them, we describe the problem and a solution that we think works better than mixins. The examples are written in ES5 but once you don’t need mixins, you can switch to ES6 classes if you’d like.<br>We hope that you find this list helpful. Please let us know if we missed important use cases so we can either amend the list or be proven wrong!</p></blockquote><h2 id="从Mixins迁移"><a href="#从Mixins迁移" class="headerlink" title="从Mixins迁移"></a>从Mixins迁移</h2><p>有一点需要说明的是，从技术上来讲，mixins不是被弃用的。如果你在使用<code>React.createClass()</code>，你可以继续使用它们。我们只是说它们对我们而言不能很好地运用，并且我们不推荐在未来中继续使用它们。下面的每一章节对应了我们在Facebook代码库中发现的mixin的使用场景。对于每种情况，我们会说明问题所在，并展示我们认为比使用mixins更好的解决方案。示例都使用ES5编写，但当你不再需要mixins时，你可以随心所欲地切换到ES6 classes。<br>我们希望你能从这个列表中得到帮助。如果我们缺漏了一些比较重要的应用场景，请告知我们，因此我们能拓展这个列表，或者证明其中的部分是错误的。</p><blockquote><p>Performance Optimizations<br>One of the most commonly used mixins is PureRenderMixin. You might be using it in some components to prevent unnecessary re-renders when the props and state are shallowly equal to the previous props and state:</p></blockquote><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>使用率最高的mixins之一是 <a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank" rel="noopener">PureRenderMixin</a> 。你可能正在一些组件中使用它，当props和state跟上次的值是浅层相等时，可<a href="https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">避免不必要的重渲染</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p>To express the same without mixins, you can use the shallowCompare function directly instead:</p></blockquote><p>为了达到相同的效果而不使用mixins，你可以直接使用<a href="https://facebook.github.io/react/docs/shallow-compare.html" target="_blank" rel="noopener">shallowCompare</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCompare = <span class="built_in">require</span>(<span class="string">'react-addons-shallow-compare'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>If you use a custom mixin implementing a shouldComponentUpdate function with different algorithm, we suggest exporting just that single function from a module and calling it directly from your components.</p><p>We understand that more typing can be annoying. For the most common case, we plan to introduce a new base class called React.PureComponent in the next minor release. It uses the same shallow comparison as PureRenderMixin does today.</p></blockquote><p>如果你使用一个自定义的mixin，以不同的算法实现 <code>shouldComponentUpdate</code> 方法，我们建议从模块中导出该单一的方法，并在你的组件中直接调用它。<br>我们理解频繁的编码是令人不快的。对于更普遍的情况，我们计划在下一个小版本发布中引入一个新的基类<code>React.PureComponent</code>。它将使用浅层对比算法，正如今天的<code>PureRenderMixin</code>。</p><blockquote><p>Subscriptions and Side Effects<br>The second most common type of mixins that we encountered are mixins that subscribe a React component to a third-party data source. Whether this data source is a Flux Store, an Rx Observable, or something else, the pattern is very similar: the subscription is created in componentDidMount, destroyed in componentWillUnmount, and the change handler calls this.setState().</p></blockquote><h2 id="订阅和副作用"><a href="#订阅和副作用" class="headerlink" title="订阅和副作用"></a>订阅和副作用</h2><p>我们遇到的第二种最常见的mixins类型是那些用来订阅React组件到第三方数据源的mixins。无论这些数据源是一个Flux Store，还是一个Rx Observable，抑或是其他的，该模式都是相似的：订阅在<code>componentDidMount</code>中产生，在<code>componentWillUnmount</code>中被销毁，而变更处理函数将调用 <code>this.setState()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SubscriptionMixin = &#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  mixins: [SubscriptionMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Reading comments from state managed by mixin.</span></span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.state.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CommentList;</span><br></pre></td></tr></table></figure></p><blockquote><p>Solution</p><p>If there is just one component subscribed to this data source, it is fine to embed the subscription logic right into the component. Avoid premature abstractions.</p><p>If several components used this mixin to subscribe to a data source, a nice way to avoid repetition is to use a pattern called “higher-order components”. It can sound intimidating so we will take a closer look at how this pattern naturally emerges from the component model.</p></blockquote><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果只有一个组件被订阅到这个数据源，直接将订阅逻辑内嵌到该组件中不失为一个良策。避免草率的抽象。</p><p>如果多个组件都使用这个mixin来订阅到一个数据源，一个好的避免重复冗余的方法是使用一种被称为“<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" target="_blank" rel="noopener">高阶组件(higher-order components，又称HOC)</a>”的模式。这听起来让人生畏，所以我们将仔细分析这个模式如何自然地套用到组件模型上。</p><blockquote><p>Higher-Order Components Explained<br>Let’s forget about React for a second. Consider these two functions that add and multiply numbers, logging the results as they do that:</p></blockquote><h3 id="高阶组件的解释"><a href="#高阶组件的解释" class="headerlink" title="高阶组件的解释"></a>高阶组件的解释</h3><p>让我们暂时忘记React。想想这两个实现相加和相乘的函数，通过这样来实现记录计算结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAndLog</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = x + y;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAndLog</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = x * y;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>These two functions are not very useful but they help us demonstrate a pattern that we can later apply to components.</p><p>Let’s say that we want to extract the logging logic out of these functions without changing their signatures. How can we do this? An elegant solution is to write a higher-order function, that is, a function that takes a function as an argument and returns a function.</p><p>Again, it sounds more intimidating than it really is:</p></blockquote><p>这两个函数并不是十分有用，但它们可以帮助我们描述一个典型的模式，这个模式我们之后将把它应用到组件上。</p><p>假设我们想从这些函数中抽离记录逻辑而不修改它们的签名。如何做到这点？一个优雅的方案是，写一个更高阶的函数，这个更高阶的函数实际上是一个将函数作为其参数，并返回一个新函数的函数。</p><p>又一次，它听起来让人生畏，但实际上它是更简单的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Return a function with the same API...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... that calls the original function</span></span><br><span class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</span><br><span class="line">    <span class="comment">// ... but also logs its result!</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The withLogging higher-order function lets us write add and multiply without the logging statements, and later wrap them to get addAndLog and multiplyAndLog with exactly the same signatures as before:</p></blockquote><p>这个 <code>withLogging</code> 高阶函数让我们在实现相加和相乘逻辑时不需考虑记录逻辑，在这之后我们通过嵌套的方式来得到与之前签名一致的 <code>addAndLog</code> 和 <code>multiplyAndLog</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">wrappedFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = wrappedFunction(x, y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result:'</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to writing addAndLog by hand:</span></span><br><span class="line"><span class="keyword">var</span> addAndLog = withLogging(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equivalent to writing multiplyAndLog by hand:</span></span><br><span class="line"><span class="keyword">var</span> multiplyAndLog = withLogging(multiply);</span><br></pre></td></tr></table></figure><blockquote><p>Higher-order components are a very similar pattern, but applied to components in React. We will apply this transformation from mixins in two steps.</p><p>As a first step, we will split our CommentList component in two, a child and a parent. The child will be only concerned with rendering the comments. The parent will set up the subscription and pass the up-to-date data to the child via props.</p></blockquote><p>高阶组件是一种非常相似的模式，只不过它是应用在React组件上的而已。我们将这种转换应用到mixins上，只需要两步即可。</p><p>第一步，我们将<code>CommentList</code>组件分为子和父两部分。子组件只关心渲染评论，而父组件将设置订阅，并将最新的数据通过props传递到子组件上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a child component.</span></span><br><span class="line"><span class="comment">// It only renders the comments it receives as props.</span></span><br><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Note: now reading from props rather than state.</span></span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a parent component.</span></span><br><span class="line"><span class="comment">// It subscribes to the data source and renders &lt;CommentList /&gt;.</span></span><br><span class="line"><span class="keyword">var</span> CommentListWithSubscription = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// We pass the current state as props to CommentList.</span></span><br><span class="line">    <span class="keyword">return</span> &lt;CommentList comments=&#123;this.state.comments&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = CommentListWithSubscription;</span><br></pre></td></tr></table></figure></p><blockquote><p>There is just one final step left to do.</p><p>Remember how we made withLogging() take a function and return another function wrapping it? We can apply a similar pattern to React components.</p><p>We will write a new function called withSubscription(WrappedComponent). Its argument could be any React component. We will pass CommentList as WrappedComponent, but we could also apply withSubscription() to any other component in our codebase.</p><p>This function would return another component. The returned component would manage the subscription and render <wrappedcomponent> with the current data.</wrappedcomponent></p><p>We call this pattern a “higher-order component”.</p><p>The composition happens at React rendering level rather than with a direct function call. This is why it doesn’t matter whether the wrapped component is defined with createClass(), as an ES6 class or a function. If WrappedComponent is a React component, the component created by withSubscription() can render it.</p></blockquote><p>只剩下最后一步了。</p><p>还记得我们如何使得<code>withLogging()</code>传入一个函数并返回另一个嵌套它的函数吗？我们可以将相似的模式应用到React组件上来。</p><p>我们将编写一个新的函数，叫做<code>withSubscription(WrappedComponent)</code>。它的参数可以是任意的React组件。我们将传递<code>CommentList</code>作为<code>WrappedComponent</code>，但我们也可以在我们的代码基中将<code>withSubscription()</code>应用到任意其他的组件上。</p><p>这个函数会返回另一个组件。返回的组件将会管理好订阅，并渲染包含数据的<code>&lt;WrappedComponent /&gt;</code>。</p><p>我们把这种模式称为一个“高阶组件”。</p><p>这种合成发生在React的渲染层，而不是通过一个直接的函数调用。这就是为什么无论内嵌的组件是由<code>createClass()</code>创建的，还是由ES6 class生成的，抑或是一个函数，都无关紧要了。如果<code>WrappedComponent</code>是一个React组件，通过<code>withSubscription()</code>创建的组件都能渲染它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes a component...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...and returns another component...</span></span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ... that takes care of the subscription...</span></span><br><span class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ... and renders the wrapped component with the fresh data!</span></span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent comments=&#123;this.state.comments&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Now we can declare CommentListWithSubscription by applying withSubscription to CommentList:</p></blockquote><p>现在我们可以通过应用<code>withSubscription</code>到<code>CommentList</code>上来声明<code>CommentListWithSubscription</code>了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommentList = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> comments = <span class="keyword">this</span>.props.comments;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;comments.map(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// withSubscription() returns a new component that</span></span><br><span class="line"><span class="comment">// is subscribed to the data source and renders</span></span><br><span class="line"><span class="comment">// &lt;CommentList /&gt; with up-to-date data.</span></span><br><span class="line"><span class="keyword">var</span> CommentListWithSubscription = withSubscription(CommentList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The rest of the app is interested in the subscribed component</span></span><br><span class="line"><span class="comment">// so we export it instead of the original unwrapped CommentList.</span></span><br><span class="line"><span class="built_in">module</span>.exports = CommentListWithSubscription;</span><br></pre></td></tr></table></figure><blockquote><p>Solution, Revisited<br>Now that we understand higher-order components better, let’s take another look at the complete solution that doesn’t involve mixins. There are a few minor changes that are annotated with inline comments:</p></blockquote><h3 id="解决方案，重现"><a href="#解决方案，重现" class="headerlink" title="解决方案，重现"></a>解决方案，重现</h3><p>现在我们能更好的理解高阶组件了，让我们来再看一次完整的、无需涉及mixins的解决方案。内联的注释有少量修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.addChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        comments: DataSource.getComments()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Use JSX spread syntax to pass all props and state down automatically.</span></span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Optional change: convert CommentList to a functional component</span><br><span class="line">// because it doesn't use lifecycle hooks or state.</span><br><span class="line">function CommentList(props) &#123;</span><br><span class="line">  var comments = props.comments;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;comments.map(function(comment) &#123;</span><br><span class="line">        return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Instead of declaring CommentListWithSubscription,</span><br><span class="line">// we export the wrapped component right away.</span><br><span class="line">module.exports = withSubscription(CommentList);</span><br></pre></td></tr></table></figure><blockquote><p>Higher-order components are a powerful pattern. You can pass additional arguments to them if you want to further customize their behavior. After all, they are not even a feature of React. They are just functions that receive components and return components that wrap them.</p><p>Like any solution, higher-order components have their own pitfalls. For example, if you heavily use refs, you might notice that wrapping something into a higher-order component changes the ref to point to the wrapping component. In practice we discourage using refs for component communication so we don’t think it’s a big issue. In the future, we might consider adding ref forwarding to React to solve this annoyance.</p></blockquote><p>高阶组件是一个强大的模式。你可以给它们传递更多的参数，如果你想要进一步高度定制它们的行为。毕境，它们甚至不是React的特性之一。它们只是接受传入组件，并返回嵌套了传入组件的新组件的函数而已。</p><p>就像其它解决方案，高阶函数同样有他们的潜在风险。比如，如果你大量地使用refs（组件引用），你可能会发现，将任意组件嵌套进高阶组件里面时，内层组件的ref会被改变。在实践中我们不建议使用refs来实现组件间通信，所以我们不认为这是个大问题。在未来，我们将考虑引入ref重定向到React中来解决这个问题。</p><blockquote><p>Rendering Logic<br>The next most common use case for mixins that we discovered in our codebase is sharing rendering logic between components.</p><p>Here is a typical example of this pattern:</p></blockquote><h2 id="渲染逻辑"><a href="#渲染逻辑" class="headerlink" title="渲染逻辑"></a>渲染逻辑</h2><p>在我们的代码库中，我们发现的下一个常见的mixins用例是组件间渲染逻辑的共享。</p><p>以下是这个模式的典型例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RowMixin = &#123;</span><br><span class="line">  <span class="comment">// Called by components from render()</span></span><br><span class="line">  renderHeader: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'row-header'</span>&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.getHeaderText() <span class="comment">/* Defined by components */</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UserRow = React.createClass(&#123;</span><br><span class="line">  mixins: [RowMixin],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called by RowMixin.renderHeader()</span></span><br><span class="line">  getHeaderText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.user.fullName;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderHeader() <span class="comment">/* Defined by RowMixin */</span>&#125;</span><br><span class="line">        &lt;h2&gt;&#123;<span class="keyword">this</span>.props.user.biography&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>Multiple components may be sharing RowMixin to render the header, and each of them would need to define getHeaderText().</p></blockquote><p>多个组件可能共享了<code>RowMixin</code>来渲染行头，而每个这些组件都需要定义一个<code>getHeaderText()</code>方法。</p><blockquote><p>Solution</p><p>If you see rendering logic inside a mixin, it’s time to extract a component!</p><p>Instead of RowMixin, we will define a <row> component. We will also replace the convention of defining a getHeaderText() method with the standard mechanism of top-data flow in React: passing props.</row></p><p>Finally, since neither of those components currently need lifecycle hooks or state, we can declare them as simple functions:</p></blockquote><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果你看见了一个mixin里面含有渲染逻辑，那么是时候把它们抽离到组件中了！</p><p>我们将定义一个<code>&lt;Row&gt;</code>组件来取代<code>RowMixin</code>。我们也将会把借由定义一个<code>getHeaderText()</code>方法来实现转换的方式替换成React中标准的自顶向下数据流机制：传递props。</p><p>最后，因为这些组件现在都不再需要生命周期钩子和状态了，我们会把他们定义为简单的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RowHeader</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'row-header'</span>&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props.text&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserRow</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;RowHeader text=&#123;props.user.fullName&#125; /&gt;</span><br><span class="line">      &lt;h2&gt;&#123;props.user.biography&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Props keep component dependencies explicit, easy to replace, and enforceable with tools like Flow and TypeScript.</p></blockquote><p>Props使得组件依赖保持显式、易于替换、对诸如Flow和TypeScript一类的工具更易执行。</p><blockquote><p>Note:</p><p>Defining components as functions is not required. There is also nothing wrong with using lifecycle hooks and state—they are first-class React features. We use functional components in this example because they are easier to read and we didn’t need those extra features, but classes would work just as fine.</p></blockquote><p>备注：<br>将组件定义为函数不是必需的。使用React的头等特性：生命周期钩子和状态也是没有任何错误的。我们在这个示例中使用函数式组件，因为它们可以更易于阅读，并且我们不需要那些另外的特性，但使用classes也是一样的效果。</p><blockquote><p>Context<br>Another group of mixins we discovered were helpers for providing and consuming React context. Context is an experimental unstable feature, has certain issues, and will likely change its API in the future. We don’t recommend using it unless you’re confident there is no other way of solving your problem.</p><p>Nevertheless, if you already use context today, you might have been hiding its usage with mixins like this:</p></blockquote><h2 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h2><p>我们发现的另外一系列mixins是提供和消费React Context的辅助器。Context是一个实验性的不稳定特性，存在确定的缺陷，而且它的API在未来可能会被改变。我们不推荐使用它，除非你十分确定没有其他方法来解决你的问题。</p><p>尽管如此，如果你已经使用了context，你可能把它的使用隐藏在了mixins里，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RouterMixin = &#123;</span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object.isRequired</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The mixin provides a method so that components</span></span><br><span class="line">  <span class="comment">// don't have to use the context API directly.</span></span><br><span class="line">  push: <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context.router.push(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Link = React.createClass(&#123;</span><br><span class="line">  mixins: [RouterMixin],</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is defined in RouterMixin.</span></span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.props.to);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = Link;</span></span><br></pre></td></tr></table></figure><blockquote><p>Solution<br>We agree that hiding context usage from consuming components is a good idea until the context API stabilizes. However, we recommend using higher-order components instead of mixins for this.</p><p>Let the wrapping component grab something from the context, and pass it down with props to the wrapped component:</p></blockquote><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>在context的API稳定之前，我们认为，将context的调用在组件中隐藏起来是个好主意。不过，我们推荐使用高阶组件来取代mixins来实现这点。</p><p>让外层组件从context中获取数据，并通过props传递到内层组件中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRouter</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    contextTypes: &#123;</span><br><span class="line">      router: React.PropTypes.object.isRequired</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// The wrapper component reads something from the context</span></span><br><span class="line">      <span class="comment">// and passes it down as a prop to the wrapped component.</span></span><br><span class="line">      <span class="keyword">var</span> router = <span class="keyword">this</span>.context.router;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; router=&#123;router&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Link = React.createClass(&#123;</span><br><span class="line">  handleClick: function(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line"></span><br><span class="line">    // The wrapped component uses props instead of context.</span><br><span class="line">    this.props.router.push(this.props.to);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;a onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Don't forget to wrap the component!</span><br><span class="line">module.exports = withRouter(Link);</span><br></pre></td></tr></table></figure></p><blockquote><p>If you’re using a third party library that only provides a mixin, we encourage you to file an issue with them linking to this post so that they can provide a higher-order component instead. In the meantime, you can create a higher-order component around it yourself in exactly the same way.</p></blockquote><p>如果你在使用一个只提供mixin的第三方库，我们建议你去提交一个issue，引用本文链接，让他们去做成高阶组件。在这期间，通过完全一样的方式，你可以自己动手围绕它做一个高阶组件。</p><blockquote><p>Utility Methods<br>Sometimes, mixins are used solely to share utility functions between components:</p></blockquote><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>有时候，mixins仅仅是用作在组件间共享的通用工具函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ColorMixin = &#123;</span><br><span class="line">  getLuminance(color) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">parseInt</span>(color, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">var</span> r = (c &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> g = (c &amp; <span class="number">0x00FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> b = (c &amp; <span class="number">0x0000FF</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [ColorMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theme = <span class="keyword">this</span>.getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;theme&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Solution<br>Put utility functions into regular JavaScript modules and import them. This also makes it easier to test them or use them outside of your components:</p></blockquote><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>将通用的工具方法放入常规的JavaScript模块中，并引入它们。这同样使得测试和组件外调用变得简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLuminance = <span class="built_in">require</span>(<span class="string">'../utils/getLuminance'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theme = getLuminance(<span class="keyword">this</span>.props.color) &gt; <span class="number">160</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;theme&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><blockquote><p>Other Use Cases<br>Sometimes people use mixins to selectively add logging to lifecycle hooks in some components. In the future, we intend to provide an official DevTools API that would let you implement something similar without touching the components. However it’s still very much a work in progress. If you heavily depend on logging mixins for debugging, you might want to keep using those mixins for a little longer.</p><p>If you can’t accomplish something with a component, a higher-order component, or a utility module, it could be mean that React should provide this out of the box. File an issue to tell us about your use case for mixins, and we’ll help you consider alternatives or perhaps implement your feature request.</p><p>Mixins are not deprecated in the traditional sense. You can keep using them with React.createClass(), as we won’t be changing it further. Eventually, as ES6 classes gain more adoption and their usability problems in React are solved, we might split React.createClass() into a separate package because most people wouldn’t need it. Even in that case, your old mixins would keep working.</p><p>We believe that the alternatives above are better for the vast majority of cases, and we invite you to try writing React apps without using mixins.</p></blockquote><h2 id="其他用例"><a href="#其他用例" class="headerlink" title="其他用例"></a>其他用例</h2><p>有时候，人们使用mixins来向一些组件添加选择性的生命周期钩子日志记录。在未来，我们计划提供一个官方的开发工具API来实现相似功能，而无需触碰组件代码。虽然这仍有大量正在进度中的工作需要完成。如果你十分依赖日志记录mixins来调试，你可能还要继续保持使用它们一段时间。</p><p>如果你借助一个组件、一个高阶组件、或者一个通用模块，仍然不能完成一些事情，这意味着React应该是难以完成这样的事情的。向我们提交一个issue，告诉我们你的mixins使用场景，我们会帮助你考虑可选的方案，或者是在未来实现你的新特性请求。</p><p>Mixins在传统感官中不是完全抛弃的。你可以通过<code>React.createClass()</code>继续使用它们，因为我们不会在未来修改它。最终，当ES6 classes得到更广泛的采用，并且它们在React中使用上的问题得到解决时，我们也许会将<code>React.createClass()</code>分离到独立的包之中，因为大多数人不再需要它。即使是在那样的情况下，你的老mixins仍然能够继续工作。</p><p>我们相信，以上所提到的可选方案对于绝大多数的场景是更好的选择，我们邀请你来尝试在不使用mixins的情况下编写React应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/2016/07/23/mixins-considered-harmful/&quot;&gt;上篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://facebook.github.io/react/blog/2016/07/13/mixins-consid
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
      <category term="React" scheme="https://blog.chionlab.moe/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>mixins是有害的（Mixins Considered Harmful）［上篇］</title>
    <link href="https://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/"/>
    <id>https://blog.chionlab.moe/2016/07/23/mixins-considered-harmful/</id>
    <published>2016-07-23T12:12:22.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Facebook React: Mixins Considered Harmful</a></p><blockquote><p>“How do I share the code between several components?” is one of the first questions that people ask when they learn React. Our answer has always been to use component composition for code reuse. You can define a component and use it in several other components.</p></blockquote><p>“我如何在多个组件（components）之间共享代码？”，这是React初学者的问题之一。我们的答案一直都是，通过组件组合的方法来实现代码复用。你可以定义一个组件，并在其它的组件中使用它。</p><blockquote><p>It is not always obvious how a certain pattern can be solved with composition. React is influenced by functional programming but it came into the field that was dominated by object-oriented libraries. It was hard for engineers both inside and outside of Facebook to give up on the patterns they were used to.</p></blockquote><p>通过组件组合的方式来解决某一种情况不总是显而易见的。React受函数式编程影响，但结果它成为了由面向对象库组成的存在。无伦是Facebook内部员工，还是非Facebook的程序员，抛弃以往的开发方式都是困难的。</p><blockquote><p>To ease the initial adoption and learning, we included certain escape hatches into React. The mixin system was one of those escape hatches, and its goal was to give you a way to reuse code between components when you aren’t sure how to solve the same problem with composition.</p></blockquote><p>为了让入门学习变得简单，我们引入了一些解决方案（原文“escape hatches”即逃生舱，此处语义为解决问题的一些trick）。Mixin系统是其中的一个方法，它的目的是，当你不知道如何通过组件组合来解决问题时，来给你一个方法来实现组件间的代码复用。</p><blockquote><p>Three years passed since React was released. The landscape has changed. Multiple view libraries now adopt a component model similar to React. Using composition over inheritance to build declarative user interfaces is no longer a novelty. We are also more confident in the React component model, and we have seen many creative uses of it both internally and in the community.<br>In this post, we will consider the problems commonly caused by mixins. Then we will suggest several alternative patterns for the same use cases. We have found those patterns to scale better with the complexity of the codebase than mixins.</p></blockquote><p>React发布后三年过去了，大环境发生了改变。大多数视图库现在都采用类似React的组件模型。通过多个组件在继承关系之上的组合来构建用户界面不再是一个新奇的方式。我们也对React的组件模型更加自信，并且在内部和社区中，都看到了许多具有创新性的使用方式。<br>在这篇文章中，我们会讨论由mixins造成的普遍问题。然后我们会提出一些同等情况下的可选替代方案。这些新的方案，在同等的代码复杂度下，比用mixins的可扩展性更好。</p><h2 id="为什么说Mixins不好？"><a href="#为什么说Mixins不好？" class="headerlink" title="为什么说Mixins不好？"></a>为什么说Mixins不好？</h2><blockquote><p>At Facebook, React usage has grown from a few components to thousands of them. This gives us a window into how people use React. Thanks to declarative rendering and top-down data flow, many teams were able to fix a bunch of bugs while shipping new features as they adopted React.</p></blockquote><p>在Facebook，React的使用从少量的组件演变成上千的组件数量。这给我们看见了人们是如何使用React的。多亏于声明性的渲染和自上而下的数据流，很多团队能够在迁移项目到React的时候修复一些bug。</p><blockquote><p>However it’s inevitable that some of our code using React gradually became incomprehensible. Occasionally, the React team would see groups of components in different projects that people were afraid to touch. These components were too easy to break accidentally, were confusing to new developers, and eventually became just as confusing to the people who wrote them in the first place. Much of this confusion was caused by mixins. At the time, I wasn’t working at Facebook but I came to the same conclusions after writing my fair share of terrible mixins.</p></blockquote><p>但是，一个很难避免的情况是，一些代码在使用了React了之后逐渐降低了可读性。有时，使用React的开发团队中会出现一些人们不太愿意去触碰的组件，而这些组件在不同的项目中被使用了。这些组件太容易意外损坏，这不但困扰了新加入的开发者，最终也困扰了一开始编写这些组件的人。这些麻烦的问题大多是由mixins造成的。在那时，我还未在Facebook工作，但在使用了一系列糟糕的mixins之后，我也能得出跟现在一样的结论。</p><blockquote><p>This doesn’t mean that mixins themselves are bad. People successfully employ them in different languages and paradigms, including some functional languages. At Facebook, we extensively use traits in Hack which are fairly similar to mixins. Nevertheless, we think that mixins are unnecessary and problematic in React codebases. Here’s why.</p></blockquote><p>这并不代表mixins都是不好的。人们成功地在不同的语言和范例中应用了mixins，其中包括了一些函数式语言。在Facebook，我们大量使用了类似mixins的一些比较hack的实现方式。我们认为mixins在React中是不再必要的，而且是非常容易出问题的。接下来讨论这是为什么。</p><h2 id="Mixins引入了隐性的依赖"><a href="#Mixins引入了隐性的依赖" class="headerlink" title="Mixins引入了隐性的依赖"></a>Mixins引入了隐性的依赖</h2><blockquote><p>Sometimes a component relies on a certain method defined in the mixin, such as getClassName(). Sometimes it’s the other way around, and mixin calls a method like renderHeader() on the component. JavaScript is a dynamic language so it’s hard to enforce or document these dependencies.<br>Mixins break the common and usually safe assumption that you can rename a state key or a method by searching for its occurrences in the component file. You might write a stateful component and then your coworker might add a mixin that reads this state. In a few months, you might want to move that state up to the parent component so it can be shared with a sibling. Will you remember to update the mixin to read a prop instead? What if, by now, other components also use this mixin?</p></blockquote><p>有时候一个组件依赖一个在mixin中定义的确定的方法，比如<code>getClassName()</code>。有时候在另一个场景下，mixin在组件上调用了一个方法，比如<code>renderHeader()</code>。JavaScript是一种动态语言，所以去强制定义或者记录这些依赖是很困难的。<br>Mixins打破了一个通用的、通常是安全的假设：你可以通过在组件源码文件中搜索的方式来重命名一个方法或者一个状态的key。你写了一个具有状态的组件，然后你的组员加入了一个mixin来读取它的状态。过了一两个月，你想把这个状态挪到父组件上，来实现跟相邻组件共享。你会记得同时更新这个mixin的代码，把它改为读取prop吗？再如果，现在还有其它组件也使用了这个mixin？</p><blockquote><p>These implicit dependencies make it hard for new team members to contribute to a codebase. A component’s render() method might reference some method that isn’t defined on the class. Is it safe to remove? Perhaps it’s defined in one of the mixins. But which one of them? You need to scroll up to the mixin list, open each of those files, and look for this method. Worse, mixins can specify their own mixins, so the search can be deep.<br>Often, mixins come to depend on other mixins, and removing one of them breaks the other. In these situations it is very tricky to tell how the data flows in and out of mixins, and what their dependency graph looks like. Unlike components, mixins don’t form a hierarchy: they are flattened and operate in the same namespace.</p></blockquote><p>这些隐形的依赖使得新成员在现有代码基础上继续开发变得困难。一个组件的<code>render()</code>方法也许引用了一些不在本类中定义的方法，删除它们是否安全？也许它们定义在mixins中，但是在哪个里面呢？你需要滚动到mixin列表，打开每个mixin的源码，来找这些方法。更坏的是，mixins可以定义它们自己的mixins，所以这次查找是一次深度查找。<br>经常地，mixins还依赖其它的mixins，如果你删除其中之一，可能会波及到另外的。在这种情况下，说明数据如何在mixins流入流出就变得很棘手了，更别说画出它们之间的依赖关系图。不像组件，mixins不会构成继承链：它们是扁平化的，并在同一个命名空间中起作用。</p><h2 id="Mixins造成命名冲突"><a href="#Mixins造成命名冲突" class="headerlink" title="Mixins造成命名冲突"></a>Mixins造成命名冲突</h2><blockquote><p>There is no guarantee that two particular mixins can be used together. For example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(), you can’t use them together. You also can’t define a method with this name on your own component.<br>It’s not a big deal if you control the mixin code. When you have a conflict, you can rename that method on one of the mixins. However it’s tricky because some components or other mixins may already be calling this method directly, and you need to find and fix those calls as well.</p></blockquote><p>从没有保证说任意两个mixins可以在一起使用。比如，如果<code>FluxListenerMixin</code>定义了<code>handleChange()</code>，<code>WindowSizeMixin</code>也定义了<code>handleChange()</code>，你就不能把它们拿在一块用。你也不能在你的组件中用这个名字来命名方法。<br>如果你能控制mixin的代码，那问题是不大的。当你遇到了命名冲突，你可以在其中的mixin中修改那个方法的名字。但是，如果有另外的mixins或是组件已经直接调用了这个方法，这就变得很棘手了，你需要同时找到和修复这些调用。</p><blockquote><p>If you have a name conflict with a mixin from a third party package, you can’t just rename a method on it. Instead, you have to use awkward method names on your component to avoid clashes.<br>The situation is no better for mixin authors. Even adding a new method to a mixin is always a potentially breaking change because a method with the same name might already exist on some of the components using it, either directly or through another mixin. Once written, mixins are hard to remove or change. Bad ideas don’t get refactored away because refactoring is too risky.</p></blockquote><p>如果你在使用一个第三方包的mixin时遇到了命名冲突，你就不能改它的方法名了。取而代之，你需要在你的组件中使用很蹩脚的方法名来避免冲突。<br>这样的情况对于mixin作者来说并没有好多少。加入一个新方法到mixin中总是一个潜在的风险，因为在已经使用了这个mixin的组件中，可能早就存在同名的方法了，无伦是直接调用还是通过其它mixin来调用。一旦mixins写好，就很困难去修改或者移除其中的东西。一些欠佳的实现方式得不到重构，因为重构的风险太大。</p><h2 id="Mixins造成滚雪球式的复杂性"><a href="#Mixins造成滚雪球式的复杂性" class="headerlink" title="Mixins造成滚雪球式的复杂性"></a>Mixins造成滚雪球式的复杂性</h2><blockquote><p>Even when mixins start out simple, they tend to become complex over time. The example below is based on a real scenario I’ve seen play out in a codebase.<br>A component needs some state to track mouse hover. To keep this logic reusable, you might extract handleMouseEnter(), handleMouseLeave() and isHovering() into a HoverMixin. Next, somebody needs to implement a tooltip. They don’t want to duplicate the logic in HoverMixin so they create a TooltipMixin that uses HoverMixin. TooltipMixin reads isHovering() provided by HoverMixin in its componentDidUpdate() and either shows or hides the tooltip.</p></blockquote><p>虽然mixins是从简单开始的，但它们会随着时间变得越来越复杂。下面的例子是基于一个真实的情况。<br>一个组件需要一些状态来跟踪鼠标的悬浮（hover）。为了使这个逻辑可复用，你抽取了<code>handleMouseEnter()</code>、<code>handleMouseLeave()</code>、<code>isHovering()</code>方法到一个<code>HoverMixin</code>里。接下来，有人需要实现一个悬浮提示框（tooltip）。他们不想拷贝<code>HoverMixin</code>里的逻辑代码，因此创建了一个<code>TooltipMixin</code>，这个<code>TooltipMixin</code>引用了<code>HoverMixin</code>，<code>TooltipMixin</code>在它的<code>componentDidUpdate()</code>中读取由<code>HoverMixin</code>提供的<code>isHovering()</code>来显示或者隐藏提示框。</p><blockquote><p>A few months later, somebody wants to make the tooltip direction configurable. In an effort to avoid code duplication, they add support for a new optional method called getTooltipOptions() to TooltipMixin. By this time, components that show popovers also use HoverMixin. However popovers need a different hover delay. To solve this, somebody adds support for an optional getHoverOptions() method and implements it in TooltipMixin. Those mixins are now tightly coupled.<br>This is fine while there are no new requirements. However this solution doesn’t scale well. What if you want to support displaying multiple tooltips in a single component? You can’t define the same mixin twice in a component. What if the tooltips need to be displayed automatically in a guided tour instead of on hover? Good luck decoupling TooltipMixin from HoverMixin. What if you need to support the case where the hover area and the tooltip anchor are located in different components? You can’t easily hoist the state used by mixin up into the parent component. Unlike components, mixins don’t lend themselves naturally to such changes.</p></blockquote><p>几个月后，有人想让这个提示框的弹出方向变得可配置。为了避免代码重复，他们添加了一个新的配置方法<code>getTooltipOptions()</code>到<code>TooltipMixin</code>。在这时，需要弹出浮层的组件也使用了<code>HoverMixin</code>。但是浮层需要不同的鼠标悬浮延时。为了解决这个问题，有人添加并实现了一个配置方法<code>getHoverOptions()</code>到<code>TooltipMixin</code>中。这两个mixins现在紧紧耦合在一起了。<br>如果没有新的需求，这样是没有问题的。但是这个方法的可扩展性并不强。如果你想在同一个组件里面支持显示多个提示框呢？你不能在一个组件里面定义两次同一个mixin。如果提示框需要在用户引导里自动弹出，而不是在鼠标悬浮时弹出呢？你想解耦<code>TooltipMixin</code>和<code>HoverMixin</code>？祝你好运。如果你想让鼠标悬浮点和提示框锚点在不同的组件中呢？你不能轻易地将mixin使用的状态抬升到父组件中。不像组件，mixins在遇到这些改变时并不能很自然地交付。</p><blockquote><p>Every new requirement makes the mixins harder to understand. Components using the same mixin become increasingly coupled with time. Any new capability gets added to all of the components using that mixin. There is no way to split a “simpler” part of the mixin without either duplicating the code or introducing more dependencies and indirection between mixins. Gradually, the encapsulation boundaries erode, and since it’s hard to change or remove the existing mixins, they keep getting more abstract until nobody understands how they work.<br>These are the same problems we faced building apps before React. We found that they are solved by declarative rendering, top-down data flow, and encapsulated components. At Facebook, we have been migrating our code to use alternative patterns to mixins, and we are generally happy with the results. You can read about those patterns below.</p></blockquote><p>每个新需求让mixins变得越来越难以理解。随着时间，使用同一个mixin的组件之间的耦合度变得越来越高。任何新的功能都会同时被附加到所有使用了这个mixin的组件。没有方法去分离这个mixin的“更简单”的部分，除非去拷贝其中的代码，或者在mixins之间引入更多的依赖和奇技淫巧。逐渐地，原来的封装会瓦解，并且因为更改或者移除已经存在的mixins是困难的，它们会变得更抽象，直到没人理解它们是怎么工作的。<br>这些问题跟我们在React出来之前构建应用程序时遇到的问题是一样的。我们认为这些问题可以通过声明性的渲染、自上而下的数据流和组件封装来解决。在Facebook，我们已经将代码的实现方式从mixins迁移到了取而代之的模式，并且我们对结果很乐观。你可以继续阅读来了解我们的新模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Facebook Reac
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
      <category term="React" scheme="https://blog.chionlab.moe/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>OpenWRT下双WAN配置</title>
    <link href="https://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/"/>
    <id>https://blog.chionlab.moe/2016/07/13/openwrt-multiwan-configuration/</id>
    <published>2016-07-13T14:24:37.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>晚上好。博主前段时间因沉迷CGSS和PS4游戏，长时间未更新博客，实在不好。现在正值暑假，博主在公司实习，今晚趁未加班，写一篇早就想写的openwrt路由器干货。</p><p>本文讲述如何在openwrt家用智能路由器上配置双WAN带宽叠加。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>两条或更多的宽带，或者是支持单线多拨的宽带。</li><li>已经安装MWAN3及luci图形化配置界面（Pandorabox固件默认已安装）。</li></ul><h2 id="VLAN配置"><a href="#VLAN配置" class="headerlink" title="VLAN配置"></a>VLAN配置</h2><blockquote><p>什么是VLAN？VLAN是在同一物理局域网内用于划分若干个不同广播域（子网）的技术，子网内的主机可以互相通信，不同子网的主机之间不可互相通信。<br>什么是VLAN ID？用于标识每个VLAN子网的ID。<br>为什么要划分VLAN？在OpenWRT下，接口是根据VLAN划分的，每个逻辑接口（interface）可对应一个VLAN ID作为物理接口，这将在后面的步骤中体现出来。</p></blockquote><p>在openwrt的web配置页面上，进入 网络-&gt;交换机 (Network-&gt;Switch)。<br>默认情况下，已经分配的VLAN应该有1个或者2个。<br>通过插拔网线的方法，将配置页上的端口和路由器的物理RJ45接口对应上来。<br>在小米路由器mini上，默认分配如下两个vlan：<br><img src="/images/openwrt-switch-1.png" alt=""><br>其中，VLAN1用作LAN，连接了除端口4以外的所有物理端口；VLAN2是默认的WAN，只连接端口4。（此处端口4即为小米路由器mini上的蓝色WAN RJ45物理端口）<br>注意，端口状态“不关联”(untagged)，即该端口作为本VLAN成员，进行二层交换；若选择“关联”(tagged)，端口之间通信无二层交换，而是冲突广播（hub方式）。</p><p>选择一个端口作为第二个WAN口的端口，在现有的VLAN配置中将其设置为“关”，然后新建一个VLAN，将该端口设置为“不关联”，其他端口设置为“关”，CPU设置为“关联”。注意，小米路由器mini有一个特殊的端口7，按照原有的两个VLAN，将其设置为“关联”即可。<br>如图，博主选择端口1来作为第二个WAN端口，在VLAN1中将其设置为“关”，并在新建的VLAN3中设置其为“不关联”。<br><img src="/images/openwrt-switch-2.png" alt=""><br>保存即可。</p><h2 id="新建WAN接口"><a href="#新建WAN接口" class="headerlink" title="新建WAN接口"></a>新建WAN接口</h2><p>进入 网络-&gt;接口，将当前<code>WAN</code>接口更名为<code>WAN1</code>，并添加一个新接口，命名为<code>WAN2</code>。<br>在<code>WAN2</code>的配置中，设置第二条宽带的拨号方式，在“物理设置”中选择刚才添加的VLAN3（<code>eth0.3</code>）。<br><img src="/images/openwrt-interface-1.png" alt=""></p><p><strong>重要</strong><br>进入<code>WAN1</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为40；<br>进入<code>WAN2</code>的编辑页，在“高级设置”中，勾选“使用默认网关”，填写“使用网关跃点”为41；</p><p>若有更多的WAN需要添加，方法类似，需要注意每个WAN接口的网关跃点必须不一样。</p><p>设置完成后，在接口总览中应该能看到两个WAN都成功获取到IP，如果是PPPoE方式，应该都已经拨号成功。<br><img src="/images/openwrt-interface-2.png" alt=""></p><h2 id="MWAN3配置"><a href="#MWAN3配置" class="headerlink" title="MWAN3配置"></a>MWAN3配置</h2><p>接下来需要通过MWAN3实现多WAN负载均衡。</p><p>进入 网络-&gt;负载均衡。</p><ul><li><p>接口配置<br>进入 配置-&gt;接口。<br>删除所有已有的默认接口。<br>添加两个接口，分别为<code>WAN1</code>，<code>WAN2</code>。<br>在接口详情的“跟踪的IP地址”中，可添加几个国内的主机IP作为检测接口是否上线的ping地址。当ping该IP多次超时后，即该接口视作下线。<br>博主的固件版本下，这个跟踪功能并不好使，经常误判断接口下线，因此我清空了跟踪的IP地址，并视作接口始终上线。<br><img src="/images/openwrt-mwan-1.png" alt=""></p></li><li><p>成员配置<br>进入 配置-&gt;成员，删除所有已有的默认成员，添加两个成员，分别命名为<code>wan_1</code>, <code>wan_2</code>。<br>成员<code>wan_1</code>设置接口为<code>WAN1</code>，跃点数1，接口比重1；<br>成员<code>wan_2</code>设置接口为<code>WAN2</code>，跃点数1，接口比重1；</p></li><li><p>策略配置<br>进入 配置-&gt;策略，添加一个策略<code>balanced</code>（或者编辑已有的<code>balanced</code>策略），使用的成员为<code>wan_1</code>, <code>wan_2</code>。</p></li><li><p>规则配置<br>进入 配置-&gt;规则，保留已有的<code>https</code>规则。如果没有<code>default_rule</code>规则，则添加一条<code>default_rule</code>规则，目标地址设置为<code>0.0.0.0/0</code>，协议选择<code>all</code>，使用的策略为<code>balanced</code>，其他留空。</p></li><li><p>保存并应用全部设置，此时应该能够实现双线负载均衡了。</p></li></ul><p>至此，openwrt路由器上的双WAN配置实现带宽叠加已经完成了，可以测速看看了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晚上好。博主前段时间因沉迷CGSS和PS4游戏，长时间未更新博客，实在不好。现在正值暑假，博主在公司实习，今晚趁未加班，写一篇早就想写的openwrt路由器干货。&lt;/p&gt;
&lt;p&gt;本文讲述如何在openwrt家用智能路由器上配置双WAN带宽叠加。&lt;/p&gt;
&lt;h2 id=&quot;前提
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenWRT" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OpenWRT/"/>
    
    
      <category term="openwrt" scheme="https://blog.chionlab.moe/tags/openwrt/"/>
    
      <category term="router" scheme="https://blog.chionlab.moe/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>cron任务的locale问题</title>
    <link href="https://blog.chionlab.moe/2016/04/29/cron-job-locale-issues/"/>
    <id>https://blog.chionlab.moe/2016/04/29/cron-job-locale-issues/</id>
    <published>2016-04-29T13:15:58.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.mk-mode.com/octopress/2013/11/26/linux-cron-locale-behavior/" target="_blank" rel="noopener">Linux - cron での locale の挙動！ - mk-mode BLOG</a></p><blockquote><p>こんばんは。<br>Linux で、自分が作成したスクリプトがコンソール上では正常に動作するのに、 cron で定時起動させようとすると文字コードの関係でうまく日本語出力ができないことがあります。<br>以下、それについての備忘録です。</p></blockquote><p>晚上好。<br>在Linux下，自己编写的（shell）脚本，在终端下手动运行是一切正常的。但是，由于字符编码的关系，当cron在试图以定时任务来执行该脚本时，日语文字却不能被正常输出。<br>以下是解决这一问题的备忘录。</p><blockquote><p>0. 前提条件<br>CentOS 6.4 (32bit) での作業を想定。<br>cron は crontab -e ではなく、 /etc/cron.d/ ディレクトリ配下にファイルを設置する方法。<br>文字化けが起こるスクリプトは “UTF-8” でエンコードされていて、日本語出力を伴うことを想定。<br>（当然、日本語出力を伴わないのならロケールの心配もない）</p></blockquote><h2 id="0-条件"><a href="#0-条件" class="headerlink" title="0. 条件"></a>0. 条件</h2><ul><li>假定操作系统是CentOS 6.4 (32bit) （译者注：6.X, 64位同样适用）</li><li>不使用cron的<code>crontab -e</code>，而是在<code>/etc/cron.d/</code>目录下建立配置文件来设置cron任务（译者注：同样适用于通过<code>crontab -e</code>设置的任务）</li><li>脚本使用UTF-8编码，并假定脚本的执行将伴随有日语文字输出，且（由cron执行时）出现了乱码。<br>（当然，如果日语输出不受locale影响，则无需担心。）</li></ul><blockquote><p>1. cron 外（コンソール）でのロケール<br>普通にコンソールで locale コマンドでロケールを確認してみる。</p></blockquote><h2 id="1-在cron外部（用户终端）的locale"><a href="#1-在cron外部（用户终端）的locale" class="headerlink" title="1. 在cron外部（用户终端）的locale"></a>1. 在cron外部（用户终端）的locale</h2><p>在一般的用户终端（console）中，尝试通过<code>locale</code>命令来确认当前环境的locale。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># locale</span></span><br><span class="line">LANG=ja_JP.UTF<span class="number">-8</span></span><br><span class="line">LC_CTYPE=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_TIME=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_PAPER=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_NAME=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"ja_JP.UTF-8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><blockquote><p>2. cron 内でのロケール<br>次に cron 内で locale コマンドを実行させてみる。<br>例えば、以下のようなファイル /etc/cron.d/locale_test を作成してみる。</p></blockquote><h2 id="2-cron内的locale"><a href="#2-cron内的locale" class="headerlink" title="2. cron内的locale"></a>2. cron内的locale</h2><p>接下来，我们尝试在cron内执行<code>locale</code>命令。（译者注：其实就是在cron job中运行<code>locale</code>命令）<br>如下例，尝试创建一个文件<code>/home/hoge/work/locale.log</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * root locale &gt; /home/hoge/work/locale.log</span><br></pre></td></tr></table></figure></p><blockquote><p>毎分 “/home/hoge/work/” ディレクトリ内に “locale.log” というファイルが作成されるので、内容を確認してみる。</p></blockquote><p>每分钟，<code>/home/hoge/work/</code>下的<code>locale.log</code>文件都会被写入新数据，我们来尝试确认该文件内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LANG=</span><br><span class="line">LC_CTYPE=<span class="string">"POSIX"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"POSIX"</span></span><br><span class="line">LC_TIME=<span class="string">"POSIX"</span></span><br><span class="line">LC_COLLATE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MONETARY=<span class="string">"POSIX"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"POSIX"</span></span><br><span class="line">LC_PAPER=<span class="string">"POSIX"</span></span><br><span class="line">LC_NAME=<span class="string">"POSIX"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"POSIX"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"POSIX"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"POSIX"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"POSIX"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><blockquote><p>“ja_JP.UTF-8” でなく “POSIX” となっている。<br>これでは、UTF-8 でエンコードされているスクリプトは日本語表示で不具合を起こすでしょう。</p></blockquote><p><code>ja_JP.UTF-8</code>并不在<code>POSIX</code>集合内。<br>因此，使用UTF-8编码的脚本在遇到日语输出时会出错。</p><blockquote><p>3. 対処方法<br>cron 内で UTF-8 でデンコードされたスクリプトを実行させる場合は、以下のように LC_CTYPE, LANG を設定してやる。</p></blockquote><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h2><p>要在cron中运行通过UTF-8编码的脚本，需要设定<code>LC_CTYPE</code>和<code>LANG</code>。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LC_CTYPE=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LANG=<span class="string">"ja_JP.utf8"</span></span><br><span class="line"></span><br><span class="line">* * * * * root locale &gt; /home/hoge/work/locale.log</span><br></pre></td></tr></table></figure></p><blockquote><p>再度 “/home/hoge/work/” ディレクトリ内の “locale.log” の内容を確認してみる。</p></blockquote><p>再次确认<code>/home/hoge/work/</code>目录下的<code>locale.log</code>文件的内容。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LANG=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_CTYPE=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_NUMERIC=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_TIME=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_COLLATE=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_MONETARY=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_MESSAGES=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_PAPER=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_NAME=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_ADDRESS=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_TELEPHONE=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">"ja_JP.utf8"</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure></p><blockquote><p>“ja_JP.utf8” になりました。（UTF-8 と utf8 の違いはあるが問題ない）<br>これで、日本語出力で文字化けすることがなくなります。</p></blockquote><p>现在是<code>ja_JP.utf8</code>了。（UTF-8和utf8的区别并不是个问题）<br>现在，（cron job任务的）的日语输出不会再乱码了。</p><blockquote><p>4. 参考<br>上記では任意のスクリプトについて話したが、UTF-8 エンコードの Ruby スクリプト（日本語出力を伴うもの）を cron 起動させるには以下のように -Ku オプションで文字コードを指定することでも対処可能である。</p></blockquote><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p>上面的记录是针对任意的脚本。若需通过cron运行含有日语输出的Ruby脚本，可以通过<code>-Ku</code>选项指定字符编码。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * root /usr/local/bin/ruby -Ku test_script.rb</span><br></pre></td></tr></table></figure></p><blockquote><p>5. 後始末<br>当然、テストで作成した cron スクリプトは不要なので削除しておく。</p><p>以上。</p></blockquote><h2 id="5-后续清理"><a href="#5-后续清理" class="headerlink" title="5. 后续清理"></a>5. 后续清理</h2><p>当然，在刚才的测试中添加的cron任务脚本（locale命令）是不再需要的，请删除它。</p><h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>本文locale问题的解决方案对于简体中文也是同样适用的，只需将本文中的<code>ja_JP</code>替换成<code>zh_CN</code>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;http://www.mk-mode.com/octopress/2013/11/26/linux-cron-locale-behavior/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux - cron での local
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
  </entry>
  
  <entry>
    <title>WeChatMomentStat：微信朋友圈导出工具开发记录</title>
    <link href="https://blog.chionlab.moe/2016/03/31/WeChatMomentStat-update-log/"/>
    <id>https://blog.chionlab.moe/2016/03/31/WeChatMomentStat-update-log/</id>
    <published>2016-03-31T02:32:52.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub-repo"><a href="#GitHub-repo" class="headerlink" title="GitHub repo"></a>GitHub repo</h2><p><a href="https://github.com/Chion82/WeChatMomentStat-Android" target="_blank" rel="noopener">https://github.com/Chion82/WeChatMomentStat-Android</a></p><h2 id="关于WeChatMomentStat-Android"><a href="#关于WeChatMomentStat-Android" class="headerlink" title="关于WeChatMomentStat-Android"></a>关于WeChatMomentStat-Android</h2><p>博主之前开发过<a href="https://github.com/Chion82/WeChatMomentExport" target="_blank" rel="noopener">WeChatMomentExport</a>，借助Xposed实现了导出微信朋友圈数据。该项目在GitHub上获得了不少Star，被应用平台收录之后也有几千的下载量，可见这个需求是存在的。但是，对于WeChatMomentExport，还存在以下问题：  </p><ul><li>作为Xposed模块，必需依赖Xposed才能运行  </li><li>因为数据抓取方式为hook，故用户需要在微信朋友圈页面手动下滑加载</li><li>微信版本每更新一次会导致源码被重新混淆，相应的本项目也需要更新钩子逻辑</li><li>项目的定位是将导出数据作为开发者二次开发所需的数据源，但从酷安网的用户评论看，普通用户不能理解需求</li></ul><p>对于上述问题，博主考虑了以下相应对策：</p><ul><li>从<a href="https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/">上次的逆向分析结果</a>看，只要想办法调用到这几个类（以下称为parser），就可以解析微信SQLite缓存中的blob数据，这样就不需要借助Xposed的hook了，也能实现一键导出</li><li>考虑到blob格式不会经常变更，因此可在项目中整合parser，这样本项目就无需经常更新</li><li>博主在开发WeChatMomentExport之后随手写的<a href="https://github.com/Chion82/WeChatMomentStat" target="_blank" rel="noopener">朋友圈数据统计脚本</a>也获得了少量star，因此认为，对于普通用户，生成这样的简易统计数据更有吸引性</li></ul><p>于是，决定整合WeChatMomentExport和统计脚本，做一个功能稍完善的工具。</p><h2 id="几个技术难点"><a href="#几个技术难点" class="headerlink" title="几个技术难点"></a>几个技术难点</h2><p>要做这样的一个独立的APP，而不是一个Xposed模块，需要解决以下问题：</p><ol><li>如何在APP中整合parser？parser的逻辑代码被混淆在微信的dex中，直接分析其算法难度太大。</li><li>如何越权获得微信的SQLite缓存数据？</li><li>如何确保从SQLite缓存中取得的朋友圈数据足够齐全？</li></ol><p>经过查阅各种文档和亲自实验，还是找到了解决方案。</p><h2 id="使用DexClassLoader直接加载微信apk中的parser"><a href="#使用DexClassLoader直接加载微信apk中的parser" class="headerlink" title="使用DexClassLoader直接加载微信apk中的parser"></a>使用DexClassLoader直接加载微信apk中的parser</h2><p>DexClassLoader可直接解析apk中的classes.dex，并从中取得所需类，通过java反射，可以获得所需的parser方法。因此，无需再分析parser算法，而是直接调用就可以了。<br>通过DexClassLoader取得parser方法的关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader cl = <span class="keyword">new</span> DexClassLoader(</span><br><span class="line">                    apkFile.getAbsolutePath(),  <span class="comment">//apkFile为微信apk文件</span></span><br><span class="line">                    context.getDir(<span class="string">"outdex"</span>, <span class="number">0</span>).getAbsolutePath(),</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">Class SnsDetailParser = cl.loadClass(<span class="string">"com.tencent.mm.plugin.sns.f.i"</span>);</span><br><span class="line">Class SnsDetail = cl.loadClass(<span class="string">"com.tencent.mm.protocal.b.atp"</span>);</span><br><span class="line">Class SnsObject = cl.loadClass(<span class="string">"com.tencent.mm.protocal.b.aqi"</span>);</span><br><span class="line"><span class="comment">//之后只需使用java反射即可取得所需方法</span></span><br></pre></td></tr></table></figure></p><p>还需要提供一个微信的apk文件。因此将微信apk放在assets中，首次运行本工具的时候释放到外部存储中。</p><h2 id="通过su调用，拷贝微信的SQLite数据库文件"><a href="#通过su调用，拷贝微信的SQLite数据库文件" class="headerlink" title="通过su调用，拷贝微信的SQLite数据库文件"></a>通过su调用，拷贝微信的SQLite数据库文件</h2><p>需要越权操作的话，获取root权限是很难避免的。通过调用su，可以复制出微信的SQLite数据库文件到本工具可读写的目录下。<br>微信朋友圈的SQLite文件在<code>/data/data/com.tencent.mm/MicroMsg/XXXXXXXXXXXXX/SnsMicroMsg.db</code>。其中，<code>XXXXXXXXXXXXX</code>是微信生成的hash值，每台设备上都可能不一样。由于在Android的shell中没有<code>find</code>或类似的命令，需要复制出这个<code>SnsMicroMsg.db</code>还得费一点功夫。最终，博主采用<code>ls</code>列目录并循环尝试<code>cp</code>的方法强行取得<code>SnsMicroMsg.db</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copySnsDB</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String dataDir = Environment.getDataDirectory().getAbsolutePath();</span><br><span class="line">    String destDir = Config.EXT_DIR;</span><br><span class="line">    Process su = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">    DataOutputStream outputStream = <span class="keyword">new</span> DataOutputStream(su.getOutputStream());</span><br><span class="line">    outputStream.writeBytes(<span class="string">"mount -o remount,rw "</span> + dataDir + <span class="string">"\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"cd "</span> + dataDir + <span class="string">"/data/"</span> + Config.WECHAT_PACKAGE + <span class="string">"/MicroMsg\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"ls | while read line; do cp $&#123;line&#125;/SnsMicroMsg.db "</span> + destDir + <span class="string">"/ ; done \n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"sleep 1\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"chmod 777 "</span> + destDir + <span class="string">"/SnsMicroMsg.db\n"</span>);</span><br><span class="line">    outputStream.writeBytes(<span class="string">"exit\n"</span>);</span><br><span class="line">    outputStream.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，还需要修改db文件的权限为<code>777</code>，否则工具无权读取数据库。另外，<code>sleep</code>是为了避免稍后偶然性出现的读取数据库失败的情况（可能文件复制不完整或未被去锁？）。</p><h2 id="关于SQLite中数据完整性的问题"><a href="#关于SQLite中数据完整性的问题" class="headerlink" title="关于SQLite中数据完整性的问题"></a>关于SQLite中数据完整性的问题</h2><p>经过测试，微信的SQLite数据库中缓存了几乎所有加载过的朋友圈，理论上应当不会漏数据。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>本来这个app计划于2月中旬就写出来的，由于博主不是安卓开发者，没有系统地学过安卓开发，当时还不知道有<code>DexClassLoader</code>，写的第一个demo用的依然是Xposed，但是不同于WeChatMomentExport，这里用Xposed仅仅是为了取得那几个parser的类而已。2月底开学后，通过各种渠道了解到了<code>DexClassLoader</code>，才有现在的这个思路。<br>博主现在读大二，这学期开学后课程比较紧张，再者在工作室外包项目的压力下（团队管理问题，还有涉及的利益问题出现冲突的时候，处理起来非常棘手），一时失去了搞开源轮子的动力，甚至连续一个月都没有更新博客，于是才导致了这个项目拖到现在才基本完成。<br>看到了GitHub上的项目star和follower每隔几天就多一个，本站也陆续有网友来评论，每日UV也保持在100以上，就重拾了动力去继续折腾。<br>非常感谢前来光临本站和GitHub profile的各位！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GitHub-repo&quot;&gt;&lt;a href=&quot;#GitHub-repo&quot; class=&quot;headerlink&quot; title=&quot;GitHub repo&quot;&gt;&lt;/a&gt;GitHub repo&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Chion8
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="安卓" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93/"/>
    
    
      <category term="android" scheme="https://blog.chionlab.moe/tags/android/"/>
    
      <category term="wechat" scheme="https://blog.chionlab.moe/tags/wechat/"/>
    
      <category term="hack" scheme="https://blog.chionlab.moe/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>自译：如何使用服务端渲染加速React APP首屏加载</title>
    <link href="https://blog.chionlab.moe/2016/03/03/react-server-side-rendering/"/>
    <id>https://blog.chionlab.moe/2016/03/03/react-server-side-rendering/</id>
    <published>2016-03-03T12:11:17.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.terlici.com/2015/03/18/fast-react-loading-server-rendering.html" target="_blank" rel="noopener">How to build React apps that load quickly using server side rendering (by Stefan Fidanov)</a></p><p>使用客户端框架（译者注：此处指大多数在浏览器端运行的前端MV*框架）可快速开发用户交互丰富、性能高效的web app，前端开发者都非常喜欢使用该类框架。<br>不幸的是，客户端框架也有缺点，其中最主要的问题是首屏加载速度。<br>客户端首先从服务器接收少量的HTML代码，但是之后却需要接收大量的JavaScript代码。<br>然后，它们（指前端框架）需要向服务器请求数据，等待收到数据，进行必要的数据处理，并最终渲染到用户的浏览器上。<br>相比之下，传统的web做法是，全部数据由服务端进行渲染，当服务端向用户首次递交HTML时，用户端浏览器就收到了渲染完成的页面了。<br>再者，大多数情况下，web服务器的渲染速度要快于客户端的渲染。所以，（传统web）的首屏渲染是非常快速的。</p><h2 id="React的解决方案"><a href="#React的解决方案" class="headerlink" title="React的解决方案"></a>React的解决方案</h2><p>很自然的，你会想同时拥有上述两者（分别指：使用了MV*框架的web app、传统的web站点）的全部优点。快速的首屏加载、高度的交互性和快速的响应。React可以帮助你同时做到这几点。<br>React是这样做到的：首先，它可以在服务端渲染任意的组件（Component），包括这些组件的数据，这样渲染得到的结果是一些HTML代码，这些HTML代码在这之后可以直接发送到浏览器。<br>当这些HTML在用户浏览器上被显示出来时，React会在本地（这里的本地指用户浏览器）进行计算。它的智能算法将进行判断并得出：React即将要在浏览器端动态渲染出来的结果，跟当前已经被显示出来的页面一样。<br>在这之后，除了添加必要的事件处理，React不会对页面做任何的修改。<br>那么为什么这样会更快呢？我们不是在做几乎跟客户端一样的事情吗？<br>是的。但仅仅是“几乎”而已。<br>首先，当服务器响应浏览器请求时，用户马上就能看到整个页面了。所以页面响应速度更快了。<br>其次，因为React能够判断出无需再对DOM做修改，它就不会再去碰DOM。修改DOM是前端渲染中最慢的部分。<br>再者，这样可以节省请求次数。因为所有数据已经被渲染所以React不需要再向服务器请求。</p><p><strong>那么有没有可能：当页面加载时，页面已经显示出来但是用户不能对其进行交互，因为这时事件处理尚未被添加？</strong><br>理论上这种情况是有可能发生的。但是因为用了服务端渲染，我们就避免了所有的高开销操作，而且这样不但加速了页面响应速度，添加事件处理的速度也会变得很快。<br>所以，你的应用将总是可交互的，并且用户不会察觉到有什么问题。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>光说无用，我们来看看如何在代码中实现。我们的第一个示例是非常简单的。我们要显示一个”hello”消息，并且点击后会有提示。<br>我们的示例将使用NodeJS作为服务端部分，不过这里的一切都可以应用在其他平台，比如PHP, Ruby, Python, Java或者.NET。</p><p>我们需要以下Node模块：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel react react-dom express jade</span></span><br></pre></td></tr></table></figure></p><p>我们将使用<code>express</code>和<code>jade</code>来做一个示例服务器。<br><code>react</code>和<code>react-dom</code>包可提供React组件的服务端渲染。<br><code>babel</code>包允许我们通过node直接加载JSX模块，比如<code>require(&#39;some-component.jsx&#39;)</code>或者<code>require(&#39;some-component.js&#39;)</code>。<br><code>babel</code>实际上更加强大。现在你可以用ES6支持。<br>我们的应用只有3个文件，文件结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public/components.js</span><br><span class="line">views/index.jade</span><br><span class="line">app.js</span><br></pre></td></tr></table></figure></p><p><code>components.js</code>包含了我们的React组件；<code>index.jade</code>是网站的基本模板文件，将会加载全部JavaScript；<code>app.js</code>是node服务器。<br>让我们来看看<code>index.jade</code>里面有什么内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">doctype</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    title React Server Side Rendering Example</span><br><span class="line">  body</span><br><span class="line">    div(id='react-root')!= react</span><br><span class="line"></span><br><span class="line">    script(src='https://fb.me/react-0.14.0.js')</span><br><span class="line">    script(src='https://fb.me/react-dom-0.14.0.js')</span><br><span class="line">    script(src='https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js')</span><br><span class="line"></span><br><span class="line">    script(src='/components.js', type='text/babel')</span><br></pre></td></tr></table></figure></p><p><code>div(id=&#39;react-root&#39;)!= react</code>是最关键的部分。它的作用是作为React根组件的容器。另外，<code>react</code>变量的值是服务端渲染React组件后得到的HTML。<br>前两个引用进来的JavaScript文件是React本身，如果你想要在组件里面使用JSX，还需要引用一个Babel。<br>最后一个引用的文件是具体的组件。我们要把type设成<code>text/babel</code>好让Babel来处理这个文件。<br>这将提供一个基本的HTML结构，并加载全部的JavaScript和你需要的React组件。<br>来看看这个简单的服务器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">  , app = express()</span><br><span class="line">  , React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line">  , ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>)</span><br><span class="line">  , components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'jade'</span>, <span class="built_in">require</span>(<span class="string">'jade'</span>).__express)</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>)</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: ReactDOM.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening on port 3000...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这部分代码中，大部分和一个普通的express应用程序没有多大区别。但是其中有些行需要注意。<br>第一行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br></pre></td></tr></table></figure></p><p>加载Babel到你的依赖。这么做，你可以直接导入(<code>require()</code>)由JSX组成的React组件，它们会被自动翻译为JavaScript，就像后面的两行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，第一行导入JSX编写的React组件。然后，由<code>React.createFactory</code>生成一个函数，该函数可以创建<code>HelloMessage</code>的组件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: ReactDOM.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面这里就是渲染React组件的代码，并且渲染包含该组件的页面然后发送至浏览器。<br>首先，使用值为<code>John</code>的<code>name</code>属性创建一个新的<code>HelloMessage</code>组件，然后使用<code>React.renderToString</code>将这个组件渲染为HTML。<br>这里需要注意的是，组件仅仅被渲染(rendered)，而没有被挂载(mounted)，所以 <strong>所有关于挂载的方法都不会被调用</strong> 。<br>在创建组件之后，将组件的HTML传递到index模版。<br>我们的组件看起来是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNode = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports</span><br><span class="line">  , React = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.React</span><br><span class="line">  , ReactDOM = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.ReactDOM</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'You clicked!'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNode) &#123;</span><br><span class="line">  exports.HelloMessage = HelloMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, document.getElementById('react-root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>你可以看见，这跟一般的由JSX编写的React组件没有什么不同，除了开头和结尾。这里就是你要让组件能同时在浏览器和Node端运行所需要注意的地方。</p><h2 id="高级示例：加载服务端数据"><a href="#高级示例：加载服务端数据" class="headerlink" title="高级示例：加载服务端数据"></a>高级示例：加载服务端数据</h2><p>真正的Web app做的事情通常远不止你看见的这些。它们经常需要跟服务器交互并从服务器加载数据。<br>但是，我们不希望这在服务端渲染时发生。<br>我们来对这个示例程序做一些小修改。首先，模版文件需要引用jQuery，在这里它的唯一作用是从服务端请求数据。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doctype</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    title React Server Side Rendering Example</span><br><span class="line">  body</span><br><span class="line">    div(id='react-root')!= react</span><br><span class="line"></span><br><span class="line">    script(src='https://fb.me/react-0.14.0.js')</span><br><span class="line">    script(src='https://fb.me/react-dom-0.14.0.js')</span><br><span class="line">    script(src='https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js')</span><br><span class="line">    script(src='http://code.jquery.com/jquery-2.1.3.js')</span><br><span class="line"></span><br><span class="line">    script(src='/components.js', type='text/babel')</span><br></pre></td></tr></table></figure></p><p>我们的服务器现在需要增加一个请求路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel/register'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line">  , app = express()</span><br><span class="line">  , React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line">  , ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>)</span><br><span class="line">  , components = <span class="built_in">require</span>(<span class="string">'./public/components.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createFactory(components.HelloMessage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'jade'</span>, <span class="built_in">require</span>(<span class="string">'jade'</span>).__express)</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>)</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">    react: React.renderToString(HelloMessage(&#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"Paul, "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening on port 3000...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这里跟之前的例子唯一的不同之处在于这三行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">"Paul, "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这三行代码的作用是，当<code>/name</code>被请求时，返回名字<code>Paul</code>和当前时间。<br>来看看这整个应用最有趣和最重要的部分，即React组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNode = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports</span><br><span class="line">  , React = isNode ? <span class="built_in">require</span>(<span class="string">'react'</span>) : <span class="built_in">window</span>.React</span><br><span class="line">  , ReactDOM = isNode ? <span class="built_in">require</span>(<span class="string">'react-dom'</span>) : <span class="built_in">window</span>.ReactDOM</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  loadServerData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: result&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervalID = setInterval(<span class="keyword">this</span>.loadServerData, <span class="number">3000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.intervalID)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'You clicked!'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="keyword">this</span>.state.name ? <span class="keyword">this</span>.state.name : <span class="keyword">this</span>.props.name</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isNode) &#123;</span><br><span class="line">  exports.HelloMessage = HelloMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>, document.getElementById('react-root'))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>我们只添加了这4个方法，其他和之前的例子相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">loadServerData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.get(<span class="string">'/name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: result&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentDidMount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.intervalID = setInterval(<span class="keyword">this</span>.loadServerData, <span class="number">3000</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.intervalID)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>当组件被挂载后，每隔3秒它会向服务器请求数据<code>/name</code>并且显示出来。<br><code>componentDidMount</code>和<code>componentWillUnmount</code>在组件被渲染时是不会被调用的，它们只有在组件被挂载时才会被调用。<br>所以这两个方法在服务端渲染时不会被调用，<code>loadServerData</code>方法也不会被调用。<br>这三个方法只有当组件被挂载时才会被执行，而这只会发生在浏览器端。<br>由此可见，想要从整体中分离出只在浏览器运行的那部分，并且保持代码的复用是很简单的。</p><h2 id="在这之后？"><a href="#在这之后？" class="headerlink" title="在这之后？"></a>在这之后？</h2><p>你已经学会了如何借助服务端渲染创建一个能被快速加载的React应用程序。但是，我的这个示例只是针对NodeJS服务器。<br>如果你在使用其他技术（比如PHP, .NET, Ruby, Python或者Java），你一样可以利用React服务端渲染的优点，这将会是你下一步要研究的方向。<br>另外，我直接在浏览器端使用了JSX，这将多亏于Babel，但是这也会降低性能。在生产环境中，在将JSX提供给浏览器之前先将之转换为JavaScript会更快。<br>我相信你一定可以找到你最喜欢的开发语言和Web框架下的类似解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://www.terlici.com/2015/03/18/fast-react-loading-server-rendering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to build Reac
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
      <category term="React" scheme="https://blog.chionlab.moe/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>你好，老司机：种子爬虫企划</title>
    <link href="https://blog.chionlab.moe/2016/02/28/hello-old-driver/"/>
    <id>https://blog.chionlab.moe/2016/02/28/hello-old-driver/</id>
    <published>2016-02-28T05:14:53.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在老司机的安利之下，学会了从<a href="http://www.hacg.li" target="_blank" rel="noopener">琉璃神社</a>找各种神奇的资源。于是萌生了造这个轮子的欲望。国内这种福利站不知还能维持多久，所以将资源大量扒下来存档是有点卵用的。</p><h2 id="GitHub-repo"><a href="#GitHub-repo" class="headerlink" title="GitHub repo"></a>GitHub repo</h2><p><a href="https://github.com/Chion82/hello-old-driver" target="_blank" rel="noopener">https://github.com/Chion82/hello-old-driver</a></p><h2 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h2><p>为了兼容多个站点，我的爬虫脚本并没有针对某个特定的网站进行抓取逻辑定制，而是采取递归遍历网站全部页面+正则匹配磁力链hash的方式抓取整站的磁力链资源。磁力链的hash协议大多数时候是BTIH，hash值为40位的hex字符串，匹配的正则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^0-9a-fA-F]([0-9a-fA-F]&#123;40&#125;)[^0-9a-fA-F]</span><br></pre></td></tr></table></figure></p><p>注意，为了保证hash串长度为40字节，在其前后应加上非hex的匹配，即<code>[^0-9a-fA-F]</code>。</p><p>这样将可能导致一个问题，网站页面源码中可能还存在磁力链以外的SHA-1值，比如琉璃神社在每条用户评论后在一个标签属性内有40字节长的一段hash值，目前的解决方法是忽略HTML标签<code>&lt;&gt;</code>内的属性内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ignore_html_label): <span class="comment">#为了增强扩展性，这类fix逻辑应该可控</span></span><br><span class="line">result_text = re.sub(<span class="string">r'&lt;.*?&gt;'</span>, <span class="string">''</span>, result_text)</span><br></pre></td></tr></table></figure></p><p>每个磁力链资源应当要有对应的标题以方便查找，这里以网页的标题作为资源标题，匹配正则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;(.+?)&lt;/title&gt;</span><br></pre></td></tr></table></figure></p><p>经测试发现，每轮抓取结束后，抓取到的资源数量可能不一样，可能的原因是网站方对访问频次做了限制或者是本地网络质量问题，就算通过连接失败重试、服务器返回5XX后重试等方法也不能解决。于是决定：每次抓取不覆盖上次抓取的结果，而是保留上次的结果，并新增本次抓取到的、上次结果中没有的新磁力链资源。</p><p>其他的一些必需属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookie = <span class="string">''</span> <span class="comment">#每次请求需要带上的Cookie。由于琉璃神社目前不需要登录，暂为空串</span></span><br><span class="line">max_depth = <span class="number">40</span> <span class="comment">#递归最大深度，即从一个网页查找全部链接并依次往下递归访问，最大的深度为40</span></span><br><span class="line">viewed_urls = [] <span class="comment">#访问过的URL，避免重复访问</span></span><br><span class="line">found_magnets = [] <span class="comment">#查找出来的磁力链资源，避免重复抓取</span></span><br><span class="line">ignore_url_param = <span class="keyword">True</span> <span class="comment">#是否忽略URL中的参数，比如"index.html?xxx=11"将被替换为"index.html"</span></span><br><span class="line">ignore_html_label = <span class="keyword">True</span> <span class="comment">#是否忽略HTML标签内属性</span></span><br></pre></td></tr></table></figure></p><p>需要定时执行抓取脚本以保证与原网站同步。写了一个shell脚本，<code>sync.sh</code>，作用如下：</p><ul><li>测试目标网站是否可访问</li><li>复制上次的抓取结果<code>magnet_output</code>和<code>resource_list.json</code>到<code>archives</code>目录下存档，以当前时间重命名</li><li>复制上次的抓取日志<code>lastsync.log</code>和<code>lasterror.log</code>到<code>log</code>目录下存档，以当前时间重命名</li><li>运行Python抓取脚本，这将覆盖项目根目录下的上述抓取结果文件和抓取日志文件</li><li>将本次的抓取结果梗概（是否成功、新增几条记录以及一些简单统计数据）添加到<code>README.md</code>中</li><li>推送到GitHub</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在老司机的安利之下，学会了从&lt;a href=&quot;http://www.hacg.li&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;琉璃神社&lt;/a&gt;找各种神奇的资源。于是萌生了造这个轮子的欲望。国内这种福利站不知还能维持多久，所以将资源大量扒下来存档是有点卵
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Python/"/>
    
    
      <category term="crawler" scheme="https://blog.chionlab.moe/tags/crawler/"/>
    
      <category term="python" scheme="https://blog.chionlab.moe/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>逆向纪录：微信朋友圈相关的几个类</title>
    <link href="https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/"/>
    <id>https://blog.chionlab.moe/2016/02/20/wechat-sns-reflect-classes/</id>
    <published>2016-02-19T16:16:42.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本纪录针对微信安卓端版本<code>6.3.13</code>。本文纪录逆向微信过程中找到的几个朋友圈内容相关的数据结构类。</p><ol><li><p>朋友圈详细内容<br>类名: <code>com.tencent.mm.protocal.b.atp</code><br>[方法]添加属性（可作为hook的方法）: <code>protected final int a(int paramInt, object... objectArray)</code><br>[方法]从BLOB数据导入：<code>public a am(byte[])</code></p></li><li><p>可将<code>com.tencent.mm.protocal.b.atp</code>实例格式化为XML的类<br>类名: <code>com.tencent.mm.plugin.sns.f.i</code><br>[方法]输出朋友圈内容XML: <code>static public String a(com.tencent.mm.protocal.b.atp atpObject)</code></p></li><li><p>朋友圈评论和点赞数据<br>类名: <code>com.tencent.mm.protocal.b.aqi</code><br>[方法]添加属性（可作为hook的方法）: <code>protected final int a(int paramInt, object... objectArray)</code><br>[方法]从BLOB数据导入：<code>public a am(byte[])</code><br>[属性]用户ID：<code>String iYA</code><br>[属性]用户昵称：<code>String jyd</code><br>[属性]时间戳：<code>long fpL</code><br>[属性]评论列表：<code>LinkedList&lt;com.tencent.mm.protocal.b.apz&gt; jJX</code><br>[属性]点赞列表：<code>LinkedList&lt;com.tencent.mm.protocal.b.apz&gt; jJU</code></p></li><li><p>评论或点赞数据详情<br>类名: <code>com.tencent.mm.protocal.b.apz</code><br>[属性]用户ID： <code>String iYA</code><br>[属性]用户昵称：<code>String jyd</code><br>[属性]评论回复给谁(对方用户ID)：<code>String jJM</code><br>[属性]评论内容：<code>String fsI</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本纪录针对微信安卓端版本&lt;code&gt;6.3.13&lt;/code&gt;。本文纪录逆向微信过程中找到的几个朋友圈内容相关的数据结构类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;朋友圈详细内容&lt;br&gt;类名: &lt;code&gt;com.tencent.mm.protocal.b.atp&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://blog.chionlab.moe/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="android" scheme="https://blog.chionlab.moe/tags/android/"/>
    
      <category term="wechat" scheme="https://blog.chionlab.moe/tags/wechat/"/>
    
      <category term="hack" scheme="https://blog.chionlab.moe/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx image filter动态生成缩略图</title>
    <link href="https://blog.chionlab.moe/2016/02/02/generate-thumbnails-with-nginx-image-filter/"/>
    <id>https://blog.chionlab.moe/2016/02/02/generate-thumbnails-with-nginx-image-filter/</id>
    <published>2016-02-01T17:05:24.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx提供<code>ngx_http_image_filter_module</code>模块，可用来动态生成图片的缩略图。当然，最好的办法是在后端进行图片压缩。但是当不方便修改后端代码时，在牺牲些许性能的代价下，使用image filter生成缩略图还是很方便的。</p><h2 id="编译安装nginx"><a href="#编译安装nginx" class="headerlink" title="编译安装nginx"></a>编译安装nginx</h2><p>大部分预编译的nginx默认不带<code>ngx_http_image_filter_module</code>模块，这时需要手动编译nginx。<br>在执行<code>configure</code>时带上参数<code>--with-http_image_filter_module</code>。<br>在水果上编译可参考<a href="/2016/02/02/compile-nginx-on-osx/">OSX上编译安装nginx</a></p><h2 id="在配置文件中使用image-filter生成缩略图"><a href="#在配置文件中使用image-filter生成缩略图" class="headerlink" title="在配置文件中使用image_filter生成缩略图"></a>在配置文件中使用image_filter生成缩略图</h2><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">    image_filter resize 200 200;</span><br><span class="line">    image_filter_buffer 10M;</span><br><span class="line">    image_filter_jpeg_quality 90;</span><br><span class="line">    root /path/to/website;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li><code>image_filter resize 200 200</code>表示按比例缩放图片，长和宽中较大者为200。比如，原图大小为1000x500，处理后为200x100。</li><li><code>image_filter_buffer 10M</code>表示处理图片的缓冲区最大为10M。</li><li><code>image_filter_jpeg_quality 90</code>设置jpeg压缩质量为90%。</li></ul><p>经过这样的配置后，访问<code>HOSTNAME/images/XXX.jpg|png|gif</code>即可得到经过压缩的缩略图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx提供&lt;code&gt;ngx_http_image_filter_module&lt;/code&gt;模块，可用来动态生成图片的缩略图。当然，最好的办法是在后端进行图片压缩。但是当不方便修改后端代码时，在牺牲些许性能的代价下，使用image filter生成缩略图还是很方便的。&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="后端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="nginx" scheme="https://blog.chionlab.moe/tags/nginx/"/>
    
      <category term="backend" scheme="https://blog.chionlab.moe/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>在OSX上编译安装nginx</title>
    <link href="https://blog.chionlab.moe/2016/02/02/compile-nginx-on-osx/"/>
    <id>https://blog.chionlab.moe/2016/02/02/compile-nginx-on-osx/</id>
    <published>2016-02-01T16:31:21.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在OSX上，一般情况下，使用<code>brew</code>安装nginx，再链接一个plist到<code>/Library/LaunchDaemons</code>即可。但是有时候brew中的nginx缺少某些模块，比如上文提到的<code>ngx_http_image_filter_module</code>，这时就需要重新编译nginx。<br>更正：homebrew中提供<code>nginx-full</code>包，包含了常用的绝大多数模块。当然如果需要添加第三方模块还是需要手动编译。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install pcre</span><br><span class="line">$ brew install gd #image filter依赖gd</span><br><span class="line">$ brew link --force openssl #避免编译openssl时报错</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>下面的示例中，添加以下几个模块：</p><ul><li>http_image_filter_module</li><li>http_ssl_module</li><li>http_gzip_static_module</li><li>http_sub_module<br>并且其他配置和homebrew的nginx大致相同（带版本号的路径除外）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#cd到nginx源码目录</span><br><span class="line">$ ./configure --with-http_image_filter_module --with-http_ssl_module --with-http_gzip_static_module --with-http_sub_module \</span><br><span class="line">--prefix=/usr/local/Cellar/nginx/1.9.10 \</span><br><span class="line">--with-cc-opt=&quot;-I /usr/local/include&quot; --with-ld-opt=&quot;-L /usr/local/lib&quot; \</span><br><span class="line">--sbin-path=/usr/local/Cellar/nginx/1.9.10/bin/nginx \</span><br><span class="line">--conf-path=/usr/local/etc/nginx/nginx.conf \</span><br><span class="line">--pid-path=/usr/local/var/run/nginx.pid \</span><br><span class="line">--http-log-path=/usr/local/var/log/nginx/access.log \</span><br><span class="line">--error-log-path=/usr/local/var/log/nginx/error.log --with-pcre --with-ipv6 \</span><br><span class="line">--lock-path=/usr/local/var/run/nginx.lock \</span><br><span class="line">--http-client-body-temp-path=/usr/local/var/run/nginx/client_body_temp \</span><br><span class="line">--http-proxy-temp-path=/usr/local/var/run/nginx/proxy_temp \</span><br><span class="line">--http-fastcgi-temp-path=/usr/local/var/run/nginx/fastcgi_temp \</span><br><span class="line">--http-uwsgi-temp-path=/usr/local/var/run/nginx/uwsgi_temp \</span><br><span class="line">--http-scgi-temp-path=/usr/local/var/run/nginx/scgi_temp</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure></li></ul><p>其中，<code>--with-cc-opt=&quot;-I /usr/local/include&quot; --with-ld-opt=&quot;-L /usr/local/lib&quot;</code>可避免报<code>Undefined symbols for architecture x86_64</code>错误。<code>/usr/local/Cellar/nginx/1.9.10</code>这里的<code>1.9.10</code>替换为将要编译的nginx版本号。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果之前未安装过nginx，运行这条命令来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make install</span><br></pre></td></tr></table></figure></p><p>如果已使用brew安装nginx，可以通过替换文件的方式换成刚才编译的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#备份原来的binary</span><br><span class="line">$ cp /usr/local/opt/nginx/bin/nginx /usr/local/opt/nginx/bin/nginx.bak</span><br><span class="line">#先cd到nginx源码目录</span><br><span class="line">$ sudo cp objs/nginx /usr/local/opt/nginx/bin/nginx</span><br><span class="line">$ rm /usr/local/bin/nginx</span><br><span class="line">$ ln -s /usr/local/opt/nginx/bin/nginx /usr/local/bin/nginx</span><br></pre></td></tr></table></figure></p><p>现在，可以查看nginx版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -V</span><br></pre></td></tr></table></figure></p><p>强迫症患者可以像我这样在<code>Cellar</code>中建立一个新的版本目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r /usr/local/Cellar/nginx/1.8.0 /usr/local/Cellar/nginx/1.9.10</span><br><span class="line">#恢复1.8.0中的binary</span><br><span class="line">$ rm /usr/local/Cellar/nginx/1.8.0/bin/nginx</span><br><span class="line">$ mv /usr/local/Cellar/nginx/1.8.0/bin/nginx.bak /usr/local/Cellar/nginx/1.8.0/bin/nginx</span><br><span class="line">#更新/usr/local/opt/nginx</span><br><span class="line">$ rm /usr/local/opt/nginx</span><br><span class="line">$ ln -s /usr/local/Cellar/nginx/1.9.10 /usr/local/opt/nginx</span><br></pre></td></tr></table></figure></p><h2 id="将nginx加入LaunchDaemons"><a href="#将nginx加入LaunchDaemons" class="headerlink" title="将nginx加入LaunchDaemons"></a>将nginx加入LaunchDaemons</h2><p>编辑<code>/Library/LaunchDaemons/homebrew.mxcl.nginx.plist</code>内容如下：（brew的nginx自带的版本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;homebrew.mxcl.nginx&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">    &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class="line">    &lt;false/&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">        &lt;string&gt;/usr/local/opt/nginx/bin/nginx&lt;/string&gt;</span><br><span class="line">        &lt;string&gt;-g&lt;/string&gt;</span><br><span class="line">        &lt;string&gt;daemon off;&lt;/string&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line">    &lt;key&gt;WorkingDirectory&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/usr/local&lt;/string&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p><p>然后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ launchctl load -F /Library/LaunchDaemons/homebrew.mxcl.nginx.plist</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在OSX上，一般情况下，使用&lt;code&gt;brew&lt;/code&gt;安装nginx，再链接一个plist到&lt;code&gt;/Library/LaunchDaemons&lt;/code&gt;即可。但是有时候brew中的nginx缺少某些模块，比如上文提到的&lt;code&gt;ngx_http_imag
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSX" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OSX/"/>
    
    
      <category term="nginx" scheme="https://blog.chionlab.moe/tags/nginx/"/>
    
      <category term="OSX" scheme="https://blog.chionlab.moe/tags/OSX/"/>
    
      <category term="backend" scheme="https://blog.chionlab.moe/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>OSX上pf的简单配置笔记</title>
    <link href="https://blog.chionlab.moe/2016/02/01/use-pf-on-osx/"/>
    <id>https://blog.chionlab.moe/2016/02/01/use-pf-on-osx/</id>
    <published>2016-01-31T17:16:55.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>水果的OSX上没有iptables，在10.10以后以pf取代ipfw。相比于iptables，pf一般使用配置文件保存防火墙规则，语法规范上更严谨，但是配置也更复杂、规则冗长。本文记录pf的简单配置方法。</p><p><code>cat /etc/pf.conf</code>，可看到以下已有内容：（忽略注释部分）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br></pre></td></tr></table></figure></p><p><code>anchor</code>可理解为一组规则的集合。默认情况下，这里的几行anchor都是苹果留的place holder，实际上没有active的规则。<br><code>/etc/pf.conf</code>在以后的OSX更新中可能会被覆盖，最好可以另外建立一个自定义的<code>pf.conf</code>。<br>配置文件必须按照<code>Macros</code>, <code>Tables</code>, <code>Options</code>, <code>Traffic Normalization</code>, <code>Queueing</code>, <code>Translation</code>, <code>Packet Filtering</code>的顺序。<br>更详细的说明参考<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/pf.conf.5.html" target="_blank" rel="noopener">pf.conf man page</a></p><ol><li><p>添加一个<code>anchor</code>。修改<code>/etc/pf.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;custom&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;custom&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;custom&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br><span class="line">load anchor &quot;custom&quot; from &quot;/etc/pf.anchors/custom&quot;</span><br></pre></td></tr></table></figure></li><li><p>建立<code>anchor</code>规则文件<code>/etc/pf.anchors/custom</code>，内容为具体规则。<br>常用的规则：</p><ul><li><p>屏蔽IP入站TCP连接并记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block in log proto tcp from 192.168.1.136 to any</span><br></pre></td></tr></table></figure></li><li><p>转发入站TCP连接到另一本地端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdr inet proto tcp from any to any port 8081 -&gt; 127.0.0.1 port 80</span><br></pre></td></tr></table></figure></li></ul><p>经测试，rdr无法转发到另一台外部主机上（man page的示例，只可以转发到internal network），内核开启<code>net.inet.ip.forwarding=1</code>也无效。如需转发到另一个外网IP，需要配合<a href="http://mitmproxy.org/doc/transparent/osx.html" target="_blank" rel="noopener">mitmproxy的透明代理</a></p><ul><li>NAT，路由vlan12接口上(192.168.168.0/24)的出口包，经由非vlan12的接口转换到外部地址(204.92.77.111)，并允许vlan12之间的互相访问:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nat on ! vlan12 from 192.168.168.0/24 to any -&gt; 204.92.77.111</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使配置文件生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfctl -evf /etc/pf.conf</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;水果的OSX上没有iptables，在10.10以后以pf取代ipfw。相比于iptables，pf一般使用配置文件保存防火墙规则，语法规范上更严谨，但是配置也更复杂、规则冗长。本文记录pf的简单配置方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat /etc/pf.conf&lt;/co
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OSX" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OSX/"/>
    
    
      <category term="OSX" scheme="https://blog.chionlab.moe/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>在GitHub Pages上使用CloudFlare https CDN</title>
    <link href="https://blog.chionlab.moe/2016/01/28/github-pages-with-https/"/>
    <id>https://blog.chionlab.moe/2016/01/28/github-pages-with-https/</id>
    <published>2016-01-27T16:49:18.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本站就是使用<a href="https://hexo.io" target="_blank" rel="noopener">hexo</a>搭建的静态Web站点，托管在<a href="https://github.com/Chion82/Chion82.github.io" target="_blank" rel="noopener">GitHub repo</a>，并使用GitHub Pages。<br>另外，阿里云最近也提供https的CDN服务，更适合用在国内链路质量要求高的站点。</p><h2 id="GitHub-Pages应用自定义域名"><a href="#GitHub-Pages应用自定义域名" class="headerlink" title="GitHub Pages应用自定义域名"></a>GitHub Pages应用自定义域名</h2><p>默认情况下，访问GitHub Pages页面的域名为<code>username.github.io</code>，如果需要使用自己的域名（以下简称“你的域名”），可<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">参考官方的帮助文档</a>，其实非常简单：</p><ol><li>在repo根目录下创建<code>CNAME</code>文件，内容为你的域名。<a href="https://github.com/Chion82/Chion82.github.io/blob/master/CNAME" target="_blank" rel="noopener">本站的CNAME文件</a></li><li>在你的域名管理中心，添加一条<code>CNAME</code>记录，指向<code>username.github.io</code>。（将username替换为你的GitHub用户名）</li></ol><p>现在，访问<code>http://你的域名</code> ，已经可以访问到站点首页了。而如果访问<code>http://username.github.io</code> （即原来的地址），将被302跳转到<code>http://你的域名</code>。</p><h2 id="https的问题"><a href="#https的问题" class="headerlink" title="https的问题"></a>https的问题</h2><p>尝试直接访问<code>https://你的域名</code>，浏览器会报SSL_DOMAIN_NOT_MATCHED警告。因为GitHub Pages默认提供的SSL证书的根域名是<code>github.io</code>，和你的域名不相同。<br>而且，GitHub Pages不支持上传SSL证书。</p><h2 id="使用CloudFlare"><a href="#使用CloudFlare" class="headerlink" title="使用CloudFlare"></a>使用CloudFlare</h2><p><a href="https://www.cloudflare.com" target="_blank" rel="noopener">CloudFlare</a>（以下简称CF）是一家CDN提供商，它的free plan里面就提供https服务（免费计划不能上传SSL）。现在可以通过CF实现：从用户到CDN服务器的连接为https，而CDN服务器到GitHub Pages服务器的连接为http。<br>1.注册并登录到CF。按照提示，在你的域名的管理中心，将域名的name server改为CF的name server。CF提供的NS如下：</p><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">NS</td><td style="text-align:center">bob.ns.cloudflare.com</td></tr><tr><td style="text-align:center">NS</td><td style="text-align:center">jamie.ns.cloudflare.com</td></tr></tbody></table><p>2.在CF的DNS设置页中，检查对应的子域名记录。博主的DNS记录如下：<br>  <img src="/2016/01/28/github-pages-with-https/dns-config.png" title="blog.chionlab.moe的DNS记录"><br>  其中，右侧的橙色云图标代表该条记录将经过CF的CDN加速。<br>  在这里设置的DNS记录，如果是CNAME记录或者A记录，若右边的STATUS为连通状态，CF都会在name server中将其设置为A记录并指向CF的CDN服务器（并根据用户所在地选择最优CDN），当用户通过该域名访问CF的CDN时（仅限http或https），CDN再转发到刚才填写的真实目的主机（即username.github.io）<br>  <img src="/2016/01/28/github-pages-with-https/dig-result.png" title="博主的blog.chionlab.moe虽在CF中设置为CNAME到gh-pages，但dig结果是A指向CF的CDN"><br>  CF正是通过这种动态DNS的方式实现CDN加速的。</p><h2 id="设置https"><a href="#设置https" class="headerlink" title="设置https"></a>设置https</h2><ol><li>在CF的Crypto页中，SSL设置为Flexible。这将允许CDN到github pages之间的访问为http。</li><li>现在，通过<code>https://你的域名</code>已经可以访问站点首页了。</li></ol><h2 id="强制https"><a href="#强制https" class="headerlink" title="强制https"></a>强制https</h2><p>CF提供Page Rules功能，可设置路由规则。通过规则中的<code>Always use https</code>选项，可以将用户强制跳转到https。博主的设置如下：<br><img src="/2016/01/28/github-pages-with-https/page-rules.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本站就是使用&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;搭建的静态Web站点，托管在&lt;a href=&quot;https://github.com/Chion82/Chion82.github.i
      
    
    </summary>
    
      <category term="运维" scheme="https://blog.chionlab.moe/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
  </entry>
  
  <entry>
    <title>运维纪录：遭遇CC攻击，防御与查水表</title>
    <link href="https://blog.chionlab.moe/2016/01/27/cc-defence-log/"/>
    <id>https://blog.chionlab.moe/2016/01/27/cc-defence-log/</id>
    <published>2016-01-26T19:28:34.000Z</published>
    <updated>2016-09-26T15:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>博主之前完成了一个外包项目，最近两个月在负责这个项目的运维。这是一个web，主营不良资产催收O2O。由于可能存在竞争对手，有人试图攻击服务器。</p><h2 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h2><p>24日下午3点，博主正在去拜访亲戚家的路上，这时公司的菜鸟开发者突然从QQ上发消息过来，问我服务器是不是被黑了。我认为这个可能性不大。这个项目由我亲手带领团队开发，后端使用的是Python+Flask+PostgreSQL，前端使用nodejs+express实现的midway，服务器部署也是由博主亲手完成。这类技术栈，已公布的可直接利用的漏洞十分有限，再者，博主在领队开发时已多次强调安全的重要性，具体到每个API都对用户权限进行了严格认证，编码过程中也不存在可能被注入、被远程执行等低级的危险代码，于是博主认为服务器被web渗透的可能性非常小。当然，不排除黑客从web之外的服务渗透进入，但是服务器上除了web只有ssh服务（强密码+公钥认证），除非公司的开发者部署了其他服务，否则能渗进来的可能性不大。</p><p>博主于是立即用手机访问网站，网站返回了504，这说明nginx的上游没有响应了，node midway或者Python后端，肯定有一个处于freeze状态。</p><p>到达亲戚家后，经过简短的问候，我即问道有没有能用的电脑。朋友让我使用一台08年的笔记本，运行的XP系统，只有IE8和360安全浏览器，但是已经够用了。下载Putty后ssh连接上服务器，立即<code>killall supervisord &amp;&amp; supervisord</code>。因为node midway和Python后端都处于开发中状态，为了调试方便，所以直接是用supervisor作为daemon的。结果是，网站首页仍然返回504。</p><p>下意识地<code>tail /var/log/nginx/access.log -n 100</code>，出来的结果让我目瞪口呆.jpg<br><img src="/2016/01/27/cc-defence-log/cc_access_log_1.jpg" title="nginx access log:图中/api开头的URL全是短信API"><br>我立即就知道是怎么一回事了：黑客在flood发送短信的API。由于当时开发急促，没有对短信API加入图形验证码或者reCaptcha之类的验证，使得可以通过软件实现模拟请求，并且由于项目处于开发中，为方便调试没有使用wsgi容器调度请求和超时处理，再者，由于发送短信需要服务器向第三方短信平台请求，这个请求将比较费时，同时的大量请求使得Python后端完全被阻塞，难怪nginx报504。从log上看，flood来源自多个不同的IP，这是分布式的攻击，算得上是一场小型的CC攻击。后来发现参与这次CC的肉鸡大概有700～800台。</p><p><strong>出于保密原则，本文以下内容中，发送短信API的URI均由[SMS_API]代替</strong></p><h2 id="应急防御"><a href="#应急防御" class="headerlink" title="应急防御"></a>应急防御</h2><p>运行了一下<code>cat /var/log/nginx/access.log | grep &#39;[SMS_API]&#39; | wc -l</code>，返回的数字超过了30万，这时公司购买的短信平台套餐肯定已经用光了。但是现在首先要考虑恢复网站的正常访问。</p><p>对于这种小型的CC防御，除了ban ip之外我没有想到更好的解决方法。于是，我用ipset+iptables将当天访问过短信API的IP全部ban了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ipset create blacklist hash:net</span><br><span class="line"># cat /var/log/nginx/access.log | grep &apos;[SMS_API]&apos; | awk &apos;&#123;print $1&#125;&apos; | while read line;do ipset add blacklist $line;done  #将访问过短信API的IP全部加入ipset的blacklist集合</span><br><span class="line"># iptables -I INPUT -m set --match-set blacklist src -j DROP</span><br></pre></td></tr></table></figure></p><blockquote><p>笔记： iptables -m set –match-set [SET_NAME] [src|dst]</p></blockquote><p>执行后，再查看access log，flood马上就停下来了。但是现在遇到了新问题：后端跑不起来了。</p><h2 id="修复后端"><a href="#修复后端" class="headerlink" title="修复后端"></a>修复后端</h2><p>手动运行后端Python脚本，Peewee报不能连接上数据库。<br>跑了一下psql，发现正常读取数据，再查看PostgreSQL的log，没有发现异常。没有头绪，通知公司的后端开发者检查后端代码。<br>公司的开发者没有回应，我折腾了很久找不到问题所在，直到我想到会不会是刚才添加iptables过滤规则时把本机也过滤了。<br>试着运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset test blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 is in set blacklist.</span><br></pre></td></tr></table></figure></p><p>再次目瞪口呆.jpg。突然想起来，刚才我为了测试短信接口，在服务器上跑了一下<code>curl localhost/[SMS_API]</code>，于是nginx access log中就有了127.0.0.1，然后在跑脚本的时候就把127.0.0.1加入到blacklist中了。立即运行了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ipset del blacklist 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>再次重启后端，一切正常，网站也能够访问了。</p><h2 id="nginx中添加访问限制"><a href="#nginx中添加访问限制" class="headerlink" title="nginx中添加访问限制"></a>nginx中添加访问限制</h2><p>目前后端是从session判断唯一用户的，并限制每个用户每分钟只能调用短信API一次。但是如果黑客手动清空cookie，服务器将允许再次请求。在nginx的文档中快速查找了一下，发现nginx支持从IP上request limit。现在需要限制1 request/min per IP，为此修改nginx配置：</p><ol><li><p>添加limit_req_zone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /etc/nginx/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">  limit_req_zone $binary_remote_addr zone=sms:10m rate=1r/m;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>location中应用limit_req_zone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  location ~ ^([SMS_API]) &#123;</span><br><span class="line">      limit_req zone=sms nodelay;</span><br><span class="line">      proxy_pass http://127.0.0.1:5000;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>经过这样的配置，同一IP在一分钟内只能访问该URL一次，否则返回503 server unavailable。</p><h2 id="脚本实现自动Ban-IP"><a href="#脚本实现自动Ban-IP" class="headerlink" title="脚本实现自动Ban IP"></a>脚本实现自动Ban IP</h2><p>之后发现源源不断地还有更多IP试图发起CC，不可能人工一个一个的ban，于是写了一个简单shell脚本实现：当天access log中，访问短信API超过30次的IP，将被加入黑名单。当然，这只是临时的，生产环境中，对于同一内网中的多个真实用户可能会出现误ban的情况，因此攻击过后要将脚本关闭。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">while [ True ]</span><br><span class="line">do</span><br><span class="line">        cat /var/log/nginx/access.log | grep '[SMS_API]' | awk '&#123;print $1&#125;' | sort | uniq -c | awk '$1&gt;30&#123;print $2&#125;' | while read line;do echo 'Blocking IP:'$line &amp;&amp; ipset add blacklist $line;done</span><br><span class="line">        sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="找出攻击发起者"><a href="#找出攻击发起者" class="headerlink" title="找出攻击发起者"></a>找出攻击发起者</h2><p>由于CC分布式的特征，很难找出真正的攻击发起者。但是，往往可以找到第一个嫌疑者。通过翻看当天上午的access log，发现如下有趣的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:13 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;https://www.google.com/&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot; #使用Chrome进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:20 +0800] &quot;GET [SMS_API]?phone=1584059XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot; &quot;-&quot;</span><br><span class="line">#在Chrome中点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p><p>正常的UA（Chrome 21.0.1180.89），并且有静态资源访问记录，基本可以确定是人工操作。<br>继续翻：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:27 +0800] &quot;GET /register.html HTTP/1.1&quot; 200 8383 &quot;-&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#注意，这个人在1分钟内使用了IE9重新进入网站注册页</span><br><span class="line">#...</span><br><span class="line">#下面若干行纪录均为页面静态资源请求</span><br><span class="line">#...</span><br><span class="line">113.232.156.* - - [23/Jan/2016:11:19:35 +0800] &quot;GET [SMS_API]?phone=1552442XXXX HTTP/1.1&quot; 200 46 &quot;http://网站域名.com/register.html&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&quot; &quot;-&quot;</span><br><span class="line">#这个人在1分钟内使用IE9再次点击“发送短信验证码”按钮</span><br></pre></td></tr></table></figure></p><p>普通用户是不会同时使用两款浏览器登录同一个网站并点击发送短信按钮的。除非——你想要验证这个网站是否根据session判断同一用户是否在一分钟内调用了多次发送短信API。再往后翻记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">113.232.156.* - - [23/Jan/2016:11:19:51 +0800] &quot;GET [SMS_API]?phone=1504032XXXX HTTP/1.1&quot; 200 46 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure></p><p>果不其然，这个人用模拟请求调用了发送短信API（因为没有正常的UA）<br>在这的几分钟后，来自全国各地的肉鸡就开始flood服务器了。</p><h2 id="人肉攻击发起者"><a href="#人肉攻击发起者" class="headerlink" title="人肉攻击发起者"></a>人肉攻击发起者</h2><p>换位思考一下，如果我是黑客，在开始CC之前，是否需要测试一下这个API，然后再在肉鸡上配置随机手机号，最后再进行CC？<br>再次翻log，发现flood开始后，来自肉鸡的请求中，手机号码来自全国各地，但是都每个号码重复了很多次，并且每台肉鸡都有自己的手机号。据此可判断，肉鸡用的手机号码一定不是黑客本人或相关者的号码，而应该是随机生成的或者是通过非法渠道获取到的“受害者”的手机号。但是，113.232.156.* （即黑客嫌疑者）一开始在Chrome和IE9中用的号码在后面的记录中都没有找到，并且号码所属地和IP所属地吻合（都为辽宁沈阳），据此，怀疑黑客一开始在Chrome中会用真实的手机号先进行测试，然后再实施CC。<br>将黑客IP和他第一次在浏览器中提交的手机号码（1584059XXXX）告诉了公司，公司立即拨打了这个手机号码。<br>对方一开始不承认。后来对方打回来，问我们是什么网站做什么的，并且听到对面几个人在偷着乐。因此，对方很有可能就是这次攻击的发起者，并且可能是黑客团伙，专职外包。（其实博主认为，国内这种组织根本算不上真正意义上的黑客，只是非常低级的为了图利的非法技术组织，并且自身技术也是很菜…）<br>公司随后开始通过手机号码查询该人身份信息。由于公司本身性质的关系，有后台可以调查某些信息。<br>之后的事情我就没有多问了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博主之前完成了一个外包项目，最近两个月在负责这个项目的运维。这是一个web，主营不良资产催收O2O。由于可能存在竞争对手，有人试图攻击服务器。&lt;/p&gt;
&lt;h2 id=&quot;事件回顾&quot;&gt;&lt;a href=&quot;#事件回顾&quot; class=&quot;headerlink&quot; title=&quot;事件回顾&quot;
      
    
    </summary>
    
      <category term="运维" scheme="https://blog.chionlab.moe/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
  </entry>
  
  <entry>
    <title>OpenWRT路由器上的ShadowSocks+ChinaDNS搭梯子方案</title>
    <link href="https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/"/>
    <id>https://blog.chionlab.moe/2016/01/23/openwrt-bypass-gfw-solution/</id>
    <published>2016-01-23T08:07:53.000Z</published>
    <updated>2016-12-25T10:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在路由器上运行ShadowSocks科学上网是最为优雅的方案。本文将介绍其安装和配置步骤。<br>首先为智能路由器刷上OpenWRT，博主推荐<a href="http://downloads.openwrt.org.cn/PandoraBox/" target="_blank" rel="noopener">Pandorabox</a>修改版。本文将实现：连接上路由器的客户端当访问国内主机时，直接连接，而访问国外主机时，自动代理。</p><blockquote><p>2016.12.25更新：<br>openwrt shadowsocks作者已不在SourceForge上更新，大家可以直接到Github Release下载预编译包（感谢Blessing Studio博主提醒）：<br><a href="https://github.com/shadowsocks/openwrt-shadowsocks/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/openwrt-shadowsocks/releases</a><br>另外可以参考博主最新的 <a href="https://blog.chionlab.moe/2016/12/12/better-way-to-bypass-gfw-with-tinc/">tinc VPN策略路由</a> ，使用更优雅的方式科学上网</p></blockquote><h2 id="安装ShadowSocks"><a href="#安装ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><ol><li><p>因为本文讨论的是SS+ChinaDNS的翻墙方案，对于部分已集成SS+domain list的固件版本，需要先删除已安装的SS及相关工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ssh连接上路由器后运行</span><br><span class="line">$ opkg list_installed | grep shadowsocks #查询已安装的ss和相关工具</span><br><span class="line"># opkg remove shadowsocks-* #删除之</span><br></pre></td></tr></table></figure></li><li><p>下载安装shadowsocks-libev-spec<br><a href="https://github.com/shadowsocks/openwrt-shadowsocks/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/openwrt-shadowsocks/releases</a><br>经作者测试，最新版在极贰最新OpenWRT固件上会出现iptables规则失效的情况，建议使用<code>shadowsocks-libev-spec_2.3.0-1_XXXX</code>版本。<br>以MT7620系列为例，在路由器上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># opkg update</span><br><span class="line"># cd /tmp</span><br><span class="line"># wget http://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/2.3.0-3ff06a6/ramips/shadowsocks-libev-spec_2.3.0-1_ramips_24kec.ipk  #如果不是ramips平台，请根据路由器ARCH选择对应ipk</span><br><span class="line"># opkg install shadowsocks-libev-spec_2.3.0-1_ramips_24kec.ipk</span><br></pre></td></tr></table></figure></li><li><p>下载安装luci-app-shadowsocks-spec<br>luci-app提供ss的图形化配置界面。<br><a href="http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/</a><br>如果<code>shadowsocks-libev-spec</code>使用的版本是本文推荐的<code>2.3.0</code>，请下载<code>luci-app-shadowsocks-spec_1.3.2-1_all.ipk</code>。路由器上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># wget http://sourceforge.net/projects/openwrt-dist/files/luci-app/shadowsocks-spec/luci-app-shadowsocks-spec_1.3.2-1_all.ipk</span><br><span class="line"># opkg install luci-app-shadowsocks-spec_1.3.2-1_all.ipk</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装ChinaDNS"><a href="#安装ChinaDNS" class="headerlink" title="安装ChinaDNS"></a>安装ChinaDNS</h2><p>ChinaDNS用于解决国内DNS污染问题，同时可加速国内网站的访问。其原理如下：<br>提供至少一个国内DNS服务器和一个国外DNS服务器，ChinaDNS收到来自用户的DNS请求后，同时向这两个服务器发DNS请求。如果从国内DNS服务器返回的解析结果为国外IP，则选择国外DNS服务器的解析结果，否则选择国内DNS的解析结果，最后返回给用户。<br><a href="http://sourceforge.net/projects/openwrt-dist/files/chinadns/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/chinadns/</a></p><ol><li><p>ChinaDNS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://sourceforge.net/projects/openwrt-dist/files/chinadns/1.3.2-d3e75dd/ChinaDNS_1.3.2-3_ramips_24kec.ipk</span><br><span class="line"># opkg install ChinaDNS_1.3.2-3_ramips_24kec.ipk</span><br></pre></td></tr></table></figure></li><li><p>luci-app-ChinaDNS<br><a href="http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/" target="_blank" rel="noopener">http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://sourceforge.net/projects/openwrt-dist/files/luci-app/chinadns/luci-app-chinadns_1.3.4-1_all.ipk</span><br><span class="line"># opkg install luci-app-chinadns_1.3.4-1_all.ipk</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置ShadowSocks"><a href="#配置ShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><ol><li><p>创建国内IP段列表，用于忽略国内目标主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /etc/shadowsocks</span><br><span class="line"># wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/shadowsocks/ignore.list</span><br></pre></td></tr></table></figure></li><li><p>使用luci-app配置ss<br>进入路由器管理web页面，用root登录，进入服务(Services)-&gt;ShadowSocks。<br>勾选启用Shadowsocks，输入ss服务器信息（服务器IP、端口、密码、加密方式）。<br>代理方法(Proxy method)选择忽略列表(Ignore list)，并在–custom–中填入<code>/etc/shadowsocks/ignore.list</code>。代理协议(Proxy protocol)选择<code>TCP+UDP</code>。<br>开启UDP隧道，UDP本地端口5300，目的地址<code>8.8.8.8:53</code>。UDP隧道用于加密DNS查询包，稍后将会用到。<br><img src="/images/openwrt-ss-1.png" alt=""></p></li><li>保存并应用(Save and Apply)</li></ol><h2 id="配置ChinaDNS"><a href="#配置ChinaDNS" class="headerlink" title="配置ChinaDNS"></a>配置ChinaDNS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\| &apos;/CN\|ipv4/ &#123; printf(&quot;%s/%d\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/chinadns_chnroute.txt</span><br></pre></td></tr></table></figure><p>在路由器web管理页面，进入服务(Services)-&gt;ChinaDNS。<br>勾选启用ChinaDNS，启用DNS压缩指针。<br>本地端口写5353，中国路由表(CHNRoute File)填<code>/etc/chinadns_chnroute.txt</code>。<br>上游DNS服务器填<code>114.114.114.114,127.0.0.1:5300</code>。（可将114.114.114.114改成当前ISP提供的DNS服务器IP）<br>这里将ss的UDP隧道作为ChinaDNS的国外DNS上游源。<br>保存并应用</p><h2 id="配置路由器DNS-Dnsmasq"><a href="#配置路由器DNS-Dnsmasq" class="headerlink" title="配置路由器DNS(Dnsmasq)"></a>配置路由器DNS(Dnsmasq)</h2><p>进入网络(Network)-&gt;DHCP and DNS。<br>将DNS转发(DNS forwardings)设置为<code>127.0.0.1#5353</code>。这将使得路由器将DNS请求经由dnsmasq全部转发至ChinaDNS处理。<br>这样设置后，从内网主机端发出的国外DNS请求将发送至：dnsmasq-&gt;ChinaDNS-&gt;ss-tunnel-&gt;ss服务器-&gt;8.8.8.8，<br>国内DNS请求则：dnsmasq-&gt;ChinaDNS-&gt;114.114.114.114<br>还要记得勾选“忽略解析文件”(ignore resolve file)。</p><p>至此，路由器上的梯子已经搭建完毕，如不出意外，你已经可以进youtube了。<br>但是，受路由器到ss服务器的链路质量影响，可能会出现不稳定的情况。例如某些ISP下会出现境外UDP流量丢包、多TCP并发连接容易建立失败等情况。博主将在下篇文章中介绍优化方案。</p><h2 id="关于shadowsocks-libev-spec的原理"><a href="#关于shadowsocks-libev-spec的原理" class="headerlink" title="关于shadowsocks-libev-spec的原理"></a>关于shadowsocks-libev-spec的原理</h2><p>通过分析ss的启动脚本，初步确定ss-libev-spec是以以下步骤实现自动翻墙的。</p><ol><li>运行<code>/usr/bin/ss-rules</code>，设置在ipset中建立一个列表<code>ss_spec_wan_ac</code>，列表中存放了<code>/etc/shadowsocks/ignore.list</code>中的IP段（即为需要忽略的国内IP段），然后设置iptables，在<code>nat</code>表的<code>OUTPUT</code>链中将目标地址<code>match-set ss_spec_wan_ac</code>的包采取<code>RETURN</code>处理。然后再在这条规则后增加一条，将全部包<code>REDIRECT</code>到<code>127.0.0.1:1080</code></li><li>运行<code>/usr/bin/ss-redir</code>，监听本地端口<code>1080</code>，负责将收到的包经由ss，加密socks代理至ss服务器。</li><li>运行<code>/usr/bin/ss-tunnel</code>，经由ss服务器建立加密的UDP隧道，隧道一端为本地监听端口<code>5300</code>，另一端为<code>8.8.8.8:53</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在路由器上运行ShadowSocks科学上网是最为优雅的方案。本文将介绍其安装和配置步骤。&lt;br&gt;首先为智能路由器刷上OpenWRT，博主推荐&lt;a href=&quot;http://downloads.openwrt.org.cn/PandoraBox/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenWRT" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OpenWRT/"/>
    
    
      <category term="openwrt" scheme="https://blog.chionlab.moe/tags/openwrt/"/>
    
      <category term="router" scheme="https://blog.chionlab.moe/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>tldr - 懒人的man page</title>
    <link href="https://blog.chionlab.moe/2016/01/23/tldr-man-page/"/>
    <id>https://blog.chionlab.moe/2016/01/23/tldr-man-page/</id>
    <published>2016-01-23T07:48:33.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实我是十分不愿意在紧张开发时为了一个小工具翻看man page的，直到我从GitHub上找到这个工具。tldr即too long don’t read，提供简化版的man page，每页page只有非常简短的说明，十分适合懒人查询和情急时快速检索。当然，这个工具提供的page覆盖率还不够高，还有劳各位去发pull request。</p><p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p><h2 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h2><p>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm install -g tldr</span></span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tldr aria2c</span></span><br></pre></td></tr></table></figure></p><p>Done!</p><p>最后提一下，时间充裕时还是尽量去阅读完整版的man page！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实我是十分不愿意在紧张开发时为了一个小工具翻看man page的，直到我从GitHub上找到这个工具。tldr即too long don’t read，提供简化版的man page，每页page只有非常简短的说明，十分适合懒人查询和情急时快速检索。当然，这个工具提供的pa
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用Xposed框架抓取微信朋友圈数据</title>
    <link href="https://blog.chionlab.moe/2016/01/22/use-xposed-to-crawl-wechat-moments/"/>
    <id>https://blog.chionlab.moe/2016/01/22/use-xposed-to-crawl-wechat-moments/</id>
    <published>2016-01-22T15:38:02.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>因微信朋友圈为私有协议，从抓包上分析朋友圈数据几乎不可能，目前也尚未找到开源的抓取朋友圈的脚本。博主于是尝试通过使用安卓下的Xposed框架实现从微信安卓版上抓取朋友圈数据。<br>本文针对微信版本6.3.8。<br><a href="https://github.com/Chion82/WeChatMomentExport" target="_blank" rel="noopener">GitHub仓库</a></p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>从UI获取文本信息是最为简单的方法，于是应该优先逆向UI代码部分。</p><h2 id="逆向微信apk"><a href="#逆向微信apk" class="headerlink" title="逆向微信apk"></a>逆向微信apk</h2><p>首先解包微信apk，用dex2jar反编译classes.dex，然后用JD-GUI查看jar源码。<br>当然，能看到的源码都是经过高度混淆的。但是，继承自安卓重要组件（如Activity、Service等）的类名无法被混淆，于是还是能从中看到点东西。</p><ol><li>首先定位到微信APP package。我们知道这个是<code>com.tencent.mm</code>。</li><li>在<code>com.tencent.mm</code>中，我们找到一个<code>ui</code>包，有点意思。</li><li>展开<code>com.tencent.mm.ui</code>，发现多个未被混淆的类，其中发现<code>MMBaseActivity</code>直接继承自<code>Activity</code>，<code>MMFragmentActivity</code>继承自<code>ActionBarActivity</code>，<code>MMActivity</code>继承自<code>MMFragmentActivity</code>，并且<code>MMActivity</code>是微信中大多数Activity的父类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMFragmentActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ActionBarActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SwipeBackLayout</span>.<span class="title">a</span>, <span class="title">b</span>.<span class="title">a</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MMActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MMFragmentActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MMBaseActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>现在需要找出朋友圈的Activity，为此要用Xposed hook<code>MMActivity</code>。</p><h2 id="创建一个Xposed模块"><a href="#创建一个Xposed模块" class="headerlink" title="创建一个Xposed模块"></a>创建一个Xposed模块</h2><p>参考<a href="http://forum.xda-developers.com/showthread.php?t=2709324" target="_blank" rel="noopener">[TUTORIAL]Xposed module devlopment</a>，创建一个Xposed项目。<br>简单Xposed模块的基本思想是：hook某个APP中的某个方法，从而达到读写数据的目的。<br>小编尝试hook<code>com.tencent.mm.ui.MMActivity.setContentView</code>这个方法，并打印出这个Activity下的全部TextView内容。那么首先需要遍历这个Activity下的所有TextView，遍历ViewGroup的方法参考了SO的以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAllTextViews</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (v <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">       ViewGroup vg = (ViewGroup) v;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vg.getChildCount(); i++) &#123;</span><br><span class="line">           View child = vg.getChildAt(i);</span><br><span class="line">           getAllTextViews(child);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> TextView ) &#123;</span><br><span class="line">       dealWithTextView((TextView)v); <span class="comment">//dealWithTextView(TextView tv)方法：打印TextView中的显示文本</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Hook<code>MMActivity.setContentView</code>的关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(<span class="string">"com.tencent.mm.ui.MMActivity"</span>, lpparam.classLoader, <span class="string">"setContentView"</span>, View.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在findAndHookMethod方法中，第一个参数为完整类名，第三个参数为需要hook的方法名，其后若干个参数分别对应该方法的各形参类型。在这里，<code>Activity.setContentView(View view)</code>方法只有一个类型为<code>View</code>的形参，因此传入一个<code>View.class</code>。<br>现在，期望的结果是运行时可以从Log中读取到每个Activity中的所有的TextView的显示内容。<br><strong>但是，因为View中的数据并不一定在<code>setContentView()</code>时就加载完毕，因此小编的实验结果是，log中啥都没有。</strong></p><h2 id="意外的收获"><a href="#意外的收获" class="headerlink" title="意外的收获"></a>意外的收获</h2><p>当切换到朋友圈页面时，Xposed模块报了一个异常，异常源从<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI</code>这个类捕捉到。从类名上看，这个很有可能是朋友圈首页的UI类。展开这个类，发现更多有趣的东西：<br>这个类下有个子类<code>a</code>(被混淆过的类名)，该子类下有个名为<code>gyO</code>的<code>ListView</code>类的实例。我们知道，<code>ListView</code>是显示列表类的UI组件，有可能就是用来展示朋友圈的列表。</p><h2 id="顺藤摸瓜"><a href="#顺藤摸瓜" class="headerlink" title="顺藤摸瓜"></a>顺藤摸瓜</h2><p>那么，我们先要获得一个<code>SnsTimeLineUI.a.gyO</code>的实例。但是在这之前，要先获得一个<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI.a</code>的实例。继续搜索，发现<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI</code>有一个名为<code>gLZ</code>的<code>SnsTimeLineUI.a</code>实例，那么我们先取得这个实例。</p><p>经过测试，<code>com.tencent.mm.plugin.sns.ui.SnsTimeLineUI.a(boolean, boolean, String, boolean)</code>这个方法在每次初始化微信界面的时候都会被调用。因此我们将hook这个方法，并从中取得<code>gLZ</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(<span class="string">"com.tencent.mm.plugin.sns.ui.SnsTimeLineUI"</span>, lpparam.classLoader, <span class="string">"a"</span>, <span class="keyword">boolean</span>.class, <span class="keyword">boolean</span>.class, String.class, <span class="keyword">boolean</span>.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"Hooked. "</span>);</span><br><span class="line">        Object currentObject = param.thisObject;</span><br><span class="line">        <span class="keyword">for</span> (Field field : currentObject.getClass().getDeclaredFields()) &#123; <span class="comment">//遍历类成员</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object value = field.get(currentObject);</span><br><span class="line">            <span class="keyword">if</span> (field.getName().equals(<span class="string">"gLZ"</span>)) &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">"Child A found."</span>);</span><br><span class="line">                childA = value;</span><br><span class="line">                <span class="comment">//这里获得了gLZ</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在取得了<code>SnsTimeLineUI.a</code>的一个实例<code>gLZ</code>，需要取得这个类下的<code>ListView</code>类型的<code>gyO</code>属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithA</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (childA == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Field field : childA.getClass().getDeclaredFields()) &#123; <span class="comment">//遍历属性</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object value = field.get(childA);</span><br><span class="line">        <span class="keyword">if</span> (field.getName().equals(<span class="string">"gyO"</span>)) &#123;  <span class="comment">//取得了gyO</span></span><br><span class="line">            ViewGroup vg = (ListView)value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vg.getChildCount(); i++) &#123;  <span class="comment">//遍历这个ListView的每一个子View</span></span><br><span class="line">                ...</span><br><span class="line">                View child = vg.getChildAt(i);</span><br><span class="line">                getAllTextViews(child); <span class="comment">//这里调用上文的getAllTextViews()方法，每一个子View里的所有TextView的文本</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在已经可以将朋友圈页面中的全部文字信息打印出来了。我们需要根据TextView的子类名判断这些文字是朋友圈内容、好友昵称、点赞或评论等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithTextView</span><span class="params">(TextView v)</span> </span>&#123;</span><br><span class="line">        String className = v.getClass().getName();</span><br><span class="line">        String text = ((TextView)v).getText().toString().trim().replaceAll(<span class="string">"\n"</span>, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (!v.isShown())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (text.equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.AsyncTextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//好友昵称</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.SnsTextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//朋友圈文字内容</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (className.equals(<span class="string">"com.tencent.mm.plugin.sns.ui.MaskTextView"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!text.contains(<span class="string">":"</span>)) &#123;</span><br><span class="line">                <span class="comment">//点赞</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//评论</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>自此，我们已经从微信APP里取得了朋友圈数据。当然，这部分抓取代码需要定时执行。因为从<code>ListView</code>中抓到的数据只有当前显示在屏幕上的可见部分，为此需要每隔很短一段时间再次执行，让用户在下滑加载的过程中抓取更多数据。<br>剩下的就是数据分类处理和格式化输出到文件，受本文篇幅所限不再赘述，详细实现可参考作者GitHub上的源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因微信朋友圈为私有协议，从抓包上分析朋友圈数据几乎不可能，目前也尚未找到开源的抓取朋友圈的脚本。博主于是尝试通过使用安卓下的Xposed框架实现从微信安卓版上抓取朋友圈数据。&lt;br&gt;本文针对微信版本6.3.8。&lt;br&gt;&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="安卓" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93/"/>
    
    
      <category term="android" scheme="https://blog.chionlab.moe/tags/android/"/>
    
      <category term="hack" scheme="https://blog.chionlab.moe/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS6上编译安装Python2.7</title>
    <link href="https://blog.chionlab.moe/2016/01/22/python2.7-on-centos6/"/>
    <id>https://blog.chionlab.moe/2016/01/22/python2.7-on-centos6/</id>
    <published>2016-01-21T18:11:53.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考了友站的博文<a href="https://www.starduster.me/2016/01/04/py27-on-centos6/" target="_blank" rel="noopener">CentOS6上的Python2.7问题</a>，正如所言，在CentOS6上安装Python2.7是非常头疼的问题。友站的这篇博文阐述了如何了从源安装Python2.7，本站则讲述从源码编译安装要注意的问题。<br>编译依赖参考<a href="http://toomuchdata.com/2014/02/16/how-to-install-python-on-centos/" target="_blank" rel="noopener">How to install Python 2.7 and Python 3.3 on CentOS 6</a>。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><strong>十分重要:</strong> 编译Python2.7之前务必安装齐必须依赖。在configure过程中，若缺少依赖则不会报错，编译也可顺利通过，但编译出的Python将缺少几个必要模块，导致在运行<code>ez_setup.py</code>时出错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum groupinstall <span class="string">"Development tools"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span></span><br></pre></td></tr></table></figure><h2 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://python.org/ftp/python/2.7.6/Python-2.7.6.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xf Python-2.7.6.tar.xz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> Python-2.7.6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span> --<span class="built_in">enable</span>-unicode=ucs4 --<span class="built_in">enable</span>-shared LDFLAGS=<span class="string">"-Wl,-rpath /usr/local/lib"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make &amp;&amp; make altinstall</span></span><br></pre></td></tr></table></figure><p>这将会把Python2.7安装在<code>/usr/local/bin/python2.7</code></p><h2 id="将默认Python版本从2-6改为2-7"><a href="#将默认Python版本从2-6改为2-7" class="headerlink" title="将默认Python版本从2.6改为2.7"></a>将默认Python版本从2.6改为2.7</h2><p>首先将<code>/usr/bin/python</code>这个软链接指向刚刚安装的Python2.7<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm /usr/bin/python</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/bin/python2.7 /usr/bin/python</span></span><br></pre></td></tr></table></figure></p><p><strong>重要：</strong> 进行这步操作后，yum会失效，运行即报错。这是因为<code>/usr/bin/yum</code>其实是个python2.6脚本，刚刚安装的python2.7缺少yum的相关依赖。因此需要改动<code>/usr/bin/yum</code>的解释器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /usr/bin/yum</span></span><br></pre></td></tr></table></figure></p><p>将第一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2.6</span><br></pre></td></tr></table></figure></p><p>现在运行<code>yum --version</code>应该不会再报错</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> python ez_setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> easy_install-2.7 pip</span></span><br></pre></td></tr></table></figure><h2 id="替换默认pip为pip2-7"><a href="#替换默认pip为pip2-7" class="headerlink" title="替换默认pip为pip2.7"></a>替换默认pip为pip2.7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/bin/pip2.6 #第一行改为#!/usr/bin/python2.6</span><br><span class="line">$ which pip2.7  #应该返回/usr/local/bin/pip2.7</span><br><span class="line"># rm /usr/bin/pip</span><br><span class="line"># ln -s /usr/local/bin/pip2.7 /usr/bin/pip</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考了友站的博文&lt;a href=&quot;https://www.starduster.me/2016/01/04/py27-on-centos6/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS6上的Python2.7问题&lt;/a&gt;，正如所言，在Cen
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="linux" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux/"/>
    
    
      <category term="linux" scheme="https://blog.chionlab.moe/tags/linux/"/>
    
      <category term="maintenance" scheme="https://blog.chionlab.moe/tags/maintenance/"/>
    
  </entry>
  
  <entry>
    <title>PixivHack：记P站爬图脚本开发</title>
    <link href="https://blog.chionlab.moe/2016/01/20/pixivhack-development-log/"/>
    <id>https://blog.chionlab.moe/2016/01/20/pixivhack-development-log/</id>
    <published>2016-01-19T17:28:14.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于7月学校考试，预习功课有点忙，最近又忙着做外包，一直都忘了维护博客，所以现在补上上个月本来应该写的技术博文。</p><h1 id="这是啥"><a href="#这是啥" class="headerlink" title="这是啥"></a>这是啥</h1><p>跟生活在2.5次元的老司机混久了便跟着入了ACG坑（看到本站首页LL大法时您应该意识到了，博主是个死宅<em>(:з」∠)</em> ）。P站找图是每一个ACG爱好者的必备技能，然而像我这种刚入坑不久的，收藏的画师才几个，再者没有钱买Premium，不能按人气选图，每次找图都要手动一页一页翻(╯‵□′)╯︵┻━┻ 于是我想用Py写个自动爬图脚本。这个脚本可以按你输入的关键词搜索作品，并根据Rating（评分次数，以此来判断作品人气）的最小值来筛选并自动下载，也可以手动指定画师ID列表，也是按照设定最小Rating的方法下载每个画师的图。目前支持下载插画、漫画和大图。</p><h1 id="你为什么还不用！"><a href="#你为什么还不用！" class="headerlink" title="你为什么还不用！"></a>你为什么还不用！</h1><p><a href="https://github.com/Chion82/PixivHack.git" target="_blank" rel="noopener">GitHub链接</a><br>使用方法详见README.md</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul><li>要从P站搜图首先要登录。我原来的设想是通过抓包直接用Py模拟登录，但是不出所料，P站的登录API参数都是经过加密的（貌似是基于RSA的），在不知加密算法的情况下无法实现。（虽然在另一个开源项目中我已经能够分析登录部分的JS加密逻辑，但在那之前我还是懒得审查JS）<br>于是目前的解决方案是要求用户在浏览器登录进P站一次，通过浏览器debugger获取Cookies中的PHPSESSID的值并输入到脚本中，脚本向P站发出的每次http请求都要带上该Cookie，目的是让P站服务器认为我们已经登录。<br>下面贴一行每次请求带上Cookie的代码  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_result = self.__session.get(<span class="string">'http://www.pixiv.net/search.php?word='</span> + urllib.quote(self.__keyword) + <span class="string">'&amp;p='</span> + str(page), cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>更好的方法：在requests的session中通过headers.update()方法在Header中设置Cookie，该session的每次请求都能自动带上该header，这样就不需要每次都在请求中加上cookies参数</strong></p><ul><li><p>从HTML源码中提取有用数据：虽然Python中可以使用HTMLParser更灵活地分析HTML，但是由于不想在这个小项目上浪费太多时间，我直接用正则从HTML中匹配。这里贴一行匹配作品搜索列表的代码：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_list = re.findall(<span class="string">r'&lt;a href="(/member_illust\.php\?mode=.*?&amp;amp;illust_id=.*?)"&gt;'</span>, search_result.text)</span><br></pre></td></tr></table></figure></li><li><p>自动脚本的流程是：获取作品搜索结果页面，从每个搜索结果分别进入作品首页，判断Rating是否高于设定的最小值（若低于则跳过该作品），判断作品类型（插画/漫画/大图）并根据不同的流程进入作品二级页面并获取原图的URL</p></li><li><p>绕过P站的防Bot机制：P站的原图不可直接下载。用户在浏览器中访问原图链接时，浏览器会自动加上Refer这个HTTP头，P站图片服务器会验证Refer是否合法。所以，脚本在访问原图链接并下载时，也需要在header中带上Refer。经过测试，Refer的值为作品首页或者作品二级页的URL。总之，在下载原图时带上当前页面（也就是HTML中能找到原图src的页面）的URL作为Refer就不会出问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">download_result = self.__session.get(url, cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;, headers=&#123;<span class="string">'Referer'</span>:referer&#125;)</span><br></pre></td></tr></table></figure></li><li><p>连接失败处理：经过测试，在长时间连续爬图时很有可能会有一两次requests请求超时（不排除是天朝某墙的TCP RST所致，也有可能是requests2.0在同域下长时间保持单TCP连接使P站服务器拒绝所致），因此，requests每次发出http请求时，都应该用try…except捕获超时异常并重试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">page_result = self.__session.get(url, cookies=&#123;<span class="string">'PHPSESSID'</span>: self.__session_id&#125;, headers=&#123;<span class="string">'Referer'</span>:referer&#125;)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">print(<span class="string">'Connection failure. Retrying...'</span>)</span><br><span class="line">self.__enter_manga_big_page(url, referer, directory)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li><p>统计画师总评分数：按关键词爬完一波图后，需要统计所爬的每个画师的ID、Rating等值，方便我们之后能收藏人气高的画师。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__increment_author_ratings</span><span class="params">(self, author_id, increment, pixiv_id)</span>:</span></span><br><span class="line"><span class="keyword">for</span> author <span class="keyword">in</span> self.__author_ratings:</span><br><span class="line"><span class="keyword">if</span> (author[<span class="string">'author_id'</span>] == author_id):</span><br><span class="line"><span class="keyword">if</span> (pixiv_id <span class="keyword">in</span> author[<span class="string">'illust_id'</span>]):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">author[<span class="string">'total_ratings'</span>] = author[<span class="string">'total_ratings'</span>] + increment</span><br><span class="line">author[<span class="string">'illust_id'</span>].append(pixiv_id)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">self.__author_ratings.append(&#123;<span class="string">'author_id'</span>:author_id, <span class="string">'total_ratings'</span>:increment, <span class="string">'illust_id'</span>:[pixiv_id]&#125;)</span><br></pre></td></tr></table></figure></li><li><p>用户交互：用argparse实现CLI参数传入分析。在本脚本中，通过”-a”或”–authorlist”参数指定存储了画师ID列表的JSON文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, <span class="string">'--authorlist'</span>, help=<span class="string">'Crawl illustrations by author IDs. A JSON file containg the list of Pixiv member IDs is required.'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于7月学校考试，预习功课有点忙，最近又忙着做外包，一直都忘了维护博客，所以现在补上上个月本来应该写的技术博文。&lt;/p&gt;
&lt;h1 id=&quot;这是啥&quot;&gt;&lt;a href=&quot;#这是啥&quot; class=&quot;headerlink&quot; title=&quot;这是啥&quot;&gt;&lt;/a&gt;这是啥&lt;/h1&gt;&lt;p&gt;跟生
      
    
    </summary>
    
      <category term="开发笔记" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="https://blog.chionlab.moe/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Python/"/>
    
    
      <category term="crawler" scheme="https://blog.chionlab.moe/tags/crawler/"/>
    
      <category term="python" scheme="https://blog.chionlab.moe/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Using Gulp to Simplify Front end Development Workflow</title>
    <link href="https://blog.chionlab.moe/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/"/>
    <id>https://blog.chionlab.moe/2016/01/20/Using-Gulp-to-Simplify-Front-end-Development-Workflow/</id>
    <published>2016-01-19T17:20:18.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Gulp"><a href="#What-is-Gulp" class="headerlink" title="What is Gulp"></a>What is Gulp</h1><p>Gulp is a streaming build system which is usually used to simplify front-end development workflow, such as automatically minifying JavaScript or compiling LESS. In this tutorial, you’ll learn the basic usage of Gulp.</p><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>To make sure you’ll have fun following my instructions, I assume you:</p><ul><li>have node.js &amp; npm installed</li><li>have basic knowledge of node.js scripting.</li></ul><h1 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h1><p>Let’s start with the installation of Gulp.<br>Run the following command in your shell terminal. The installation requires sudo or root previlege and you may be required to enter the password.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install --global gulp</span><br></pre></td></tr></table></figure></p><h1 id="Project-Setup"><a href="#Project-Setup" class="headerlink" title="Project Setup"></a>Project Setup</h1><p><code>cd</code> into the root directory of your project and run the following command, which will save the Gulp dependencies in your project directory.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p><h1 id="Create-gulpfile-js"><a href="#Create-gulpfile-js" class="headerlink" title="Create gulpfile.js"></a>Create gulpfile.js</h1><p>At the root of your project, create a <code>gulpfile.js</code> containing the following code.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'mytask'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> <span class="comment">//All task code places here  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>The code above defines a gulp task named “mytask” with the detailed commands defined in the callback function as the second parameter passed to the <code>gulp.task()</code> method. When running this task, <code>console.log(&#39;Hello World!&#39;);</code> will be executed.</p><h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>Now you should be able to run <code>mytask</code> using the following command:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp mytask</span><br></pre></td></tr></table></figure></p><p>Assume the root directory of your project is <code>~/project</code>, the output should be like:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  project  gulp mytask</span><br><span class="line">[21:14:25] Using gulpfile ~/project/gulpfile.js</span><br><span class="line">[21:14:25] Starting <span class="string">'mytask'</span>...</span><br><span class="line">Hello World!</span><br><span class="line">[21:14:25] Finished <span class="string">'mytask'</span> after 62 μs</span><br></pre></td></tr></table></figure></p><p>You can always run specific tasks by executing <code>gulp &lt;task&gt; &lt;other_task&gt;</code></p><h1 id="Basic-File-Streaming"><a href="#Basic-File-Streaming" class="headerlink" title="Basic File Streaming"></a>Basic File Streaming</h1><p>In this section we’ll use Gulp’s streaming system which is its primary function.<br>We will use <code>Gulp.src()</code>, <code>Gulp.dest()</code>, <code>readable.pipe()</code> to implement a basic JavaScript source file copying program using Gulp.<br>For detailed API doc of the methods above, please refer to <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">Gulp API doc</a> and <a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options" target="_blank" rel="noopener">Node.js:Stream</a>.  </p><ul><li>Create a directory named <code>js</code> at the root of your project (Assume you created this directory: <code>~/project/js</code>) and place some JavaScript files in it.  </li><li><p>Add the following code at the end of <code>gulpfile.js</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'copyjs'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">           .pipe(gulp.dest(<span class="string">'dest'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>At the root of the project which is <code>~/project</code>, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp copyjs</span><br></pre></td></tr></table></figure></li><li><p>Check out <code>~/project/dest</code> to which you’ll find all js files in <code>~/project/js</code> are copied.</p></li></ul><h1 id="Using-Gulp-to-Minify-JS"><a href="#Using-Gulp-to-Minify-JS" class="headerlink" title="Using Gulp to Minify JS"></a>Using Gulp to Minify JS</h1><p>Next we’ll use Gulp to do some amazing tasks which bring great convenience for front-end development.<br>Let’s start with JavaScript minifying.<br>To make Gulp powerful enouth to do this job, we must install some plugins of Gulp. Here we’ll use <strong>gulp-uglify</strong>.(For more amazing gulp plugins, check out <a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">Gulp Plugins</a>)  </p><ul><li><p>Back to <code>~/project</code>, run the following command to install <strong>gulp-uglify</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp-uglify</span><br></pre></td></tr></table></figure></li><li><p>Replace <code>gulpfile.js</code> with the following code.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'minifyjs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.src(<span class="string">'js/*.js'</span>)<span class="comment">//Get the stream of the source file</span></span><br><span class="line">                .pipe(uglify())<span class="comment">//Pass the stream to the uglify module to minify all JS files.</span></span><br><span class="line">                .pipe(gulp.dest(<span class="string">'build'</span>));<span class="comment">//Pass the stream to the destination directory which is ~/project/build</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Exucute the task by running:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp minifyjs</span><br></pre></td></tr></table></figure></li><li><p>Check out <code>~/project/build</code>. All minified JavaScript source files are placed here!</p></li></ul><h1 id="Using-Gulp-watch"><a href="#Using-Gulp-watch" class="headerlink" title="Using Gulp.watch()"></a>Using Gulp.watch()</h1><p>Sometimes we want the JS files to be automatically minified everytime we modify them and <code>Gulp.watch()</code> will do the trick.<br><code>Gulp.watch()</code> allows us to implement a daemon to monitor file modifications and automatically execute specific tasks every time the modifications are made.  </p><ul><li><p>Add the following code at the end of <code>gulpfile.js</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'watchjs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        gulp.watch(<span class="string">'js/*.js'</span>,[<span class="string">'minifyjs'</span>]);<span class="comment">//Watch all *.js files under ~/project/js directory and run task "minifyjs" when files are modified</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Execute the daemon task by running:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp watchjs</span><br></pre></td></tr></table></figure></li><li><p>Now, JS files will be automatically minified every time you modify them.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-Gulp&quot;&gt;&lt;a href=&quot;#What-is-Gulp&quot; class=&quot;headerlink&quot; title=&quot;What is Gulp&quot;&gt;&lt;/a&gt;What is Gulp&lt;/h1&gt;&lt;p&gt;Gulp is a streaming build syst
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://blog.chionlab.moe/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="front-end" scheme="https://blog.chionlab.moe/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Project Conclusion of m.21dianping.com</title>
    <link href="https://blog.chionlab.moe/2016/01/20/Project-Conclusion-of-m-21dianping-com/"/>
    <id>https://blog.chionlab.moe/2016/01/20/Project-Conclusion-of-m-21dianping-com/</id>
    <published>2016-01-19T17:13:39.000Z</published>
    <updated>2016-09-09T16:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-This-Project"><a href="#About-This-Project" class="headerlink" title="About This Project"></a>About This Project</h1><p>The project is a commercial website where users share their experiences of renting houses.<br>I accepted this outsourced project in late April and finished in about 15 days.<br>The project required 2 developers including a front-end engineer and a back-end developer(me).</p><blockquote><p><strong>Tasks</strong>: development of the full site, deployment on server, maintainance for 3 months<br><strong>Profits</strong>: 4500 RMB in total, 3000 for back-end developer &amp; maintainer (me), 1500 for front-end engineer.</p></blockquote><h1 id="Technical-Info"><a href="#Technical-Info" class="headerlink" title="Technical Info"></a>Technical Info</h1><blockquote><p><strong>Back-end Language &amp; Framework</strong>: Python, Flask<br><strong>Database</strong>: MongoDB with mongoengine as ORM python engine<br><strong>Front-end Frameworks</strong>: Bootstrap(UI), Angular.JS(MVVM data-binding)<br><strong>Front-back Interaction Method</strong>: REST API<br><strong>Login Method</strong>: Only OAuth, logging in with Sina Weibo account or QQ account<br><strong>Production Environment</strong>: Nginx + uwsgi<br><strong>About Server</strong>: Ali Cloud, Ubuntu 14.04</p></blockquote><h1 id="What-I’ve-Done"><a href="#What-I’ve-Done" class="headerlink" title="What I’ve Done"></a>What I’ve Done</h1><ul><li>Back-end development</li><li>Significant modification of front-end code, including interaction with back-end using AJAX &amp; REST API calls (The front-end developer was really a rookie so I had to do much front-end stuff to fill his void. In fact he did nothing but wrote some static HTML &amp; CSS.)</li><li>Server-side production environment set-up</li></ul><h1 id="What-I’m-Doing"><a href="#What-I’m-Doing" class="headerlink" title="What I’m Doing"></a>What I’m Doing</h1><ul><li>Adding source code comments</li><li>Working on maintainance documentation</li><li>Website &amp; server maintainance</li></ul><h1 id="What-I’ve-learned"><a href="#What-I’ve-learned" class="headerlink" title="What I’ve learned"></a>What I’ve learned</h1><ul><li>Further understanding of Flask</li><li>Bootstrap</li><li>Front-end MVVM model using Angular.JS</li><li>Production environment setup with nginx+uwsgi</li></ul><h1 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h1><p>Search algorithm in back-end source needs to be improved. Current solution of house-info searching is to traverse all records in database and calculate match-weight for each row. However when the number of records grows there may be significant performance issues.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;About-This-Project&quot;&gt;&lt;a href=&quot;#About-This-Project&quot; class=&quot;headerlink&quot; title=&quot;About This Project&quot;&gt;&lt;/a&gt;About This Project&lt;/h1&gt;&lt;p&gt;The pr
      
    
    </summary>
    
      <category term="项目总结" scheme="https://blog.chionlab.moe/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="project" scheme="https://blog.chionlab.moe/tags/project/"/>
    
  </entry>
  
</feed>
